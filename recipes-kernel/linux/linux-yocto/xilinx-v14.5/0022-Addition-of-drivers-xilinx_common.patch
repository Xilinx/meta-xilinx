From 0567f3eb1b5acbc2ea1552b770ccdc6c5c0adaf6 Mon Sep 17 00:00:00 2001
From: Sipke Vriend <sipke.vriend@xilinx.com>
Date: Wed, 15 May 2013 15:30:57 +1000
Subject: [PATCH 22/24] Addition of drivers/xilinx_common

Signed-off-by: Sipke Vriend <sipke.vriend@xilinx.com>
---
 drivers/Kconfig                                |    4 +
 drivers/Makefile                               |    4 +
 drivers/pmods/Kconfig                          |   20 +
 drivers/pmods/Makefile                         |    4 +
 drivers/pmods/pmodoled-gpio.c                  |  863 +++++++++++++++
 drivers/xilinx_common/Kconfig                  |   33 +
 drivers/xilinx_common/Makefile                 |   19 +
 drivers/xilinx_common/xbasic_types.c           |  135 +++
 drivers/xilinx_common/xbasic_types.h           |  223 ++++
 drivers/xilinx_common/xbuf_descriptor.h        | 1095 +++++++++++++++++++
 drivers/xilinx_common/xdebug.h                 |   48 +
 drivers/xilinx_common/xdma_channel.c           |  714 +++++++++++++
 drivers/xilinx_common/xdma_channel.h           |  314 ++++++
 drivers/xilinx_common/xdma_channel_i.h         |  131 +++
 drivers/xilinx_common/xdma_channel_sg.c        | 1327 ++++++++++++++++++++++++
 drivers/xilinx_common/xdmabdv3.h               |  531 ++++++++++
 drivers/xilinx_common/xdmav3.c                 |  104 ++
 drivers/xilinx_common/xdmav3.h                 |  515 +++++++++
 drivers/xilinx_common/xdmav3_intr.c            |  129 +++
 drivers/xilinx_common/xdmav3_l.h               |  295 ++++++
 drivers/xilinx_common/xdmav3_selftest.c        |   79 ++
 drivers/xilinx_common/xdmav3_sg.c              | 1261 ++++++++++++++++++++++
 drivers/xilinx_common/xdmav3_simple.c          |  124 +++
 drivers/xilinx_common/xenv.h                   |  251 +++++
 drivers/xilinx_common/xil_assert.c             |  148 +++
 drivers/xilinx_common/xil_assert.h             |  204 ++++
 drivers/xilinx_common/xil_io.h                 |  121 +++
 drivers/xilinx_common/xil_types.h              |  128 +++
 drivers/xilinx_common/xilinx_syms.c            |   74 ++
 drivers/xilinx_common/xio.c                    |  519 +++++++++
 drivers/xilinx_common/xio.h                    |  209 ++++
 drivers/xilinx_common/xio_dcr.c                |  520 ++++++++++
 drivers/xilinx_common/xio_dcr.h                |  701 +++++++++++++
 drivers/xilinx_common/xipif_v1_23_b.c          |  324 ++++++
 drivers/xilinx_common/xipif_v1_23_b.h          |  665 ++++++++++++
 drivers/xilinx_common/xlldma.c                 |  252 +++++
 drivers/xilinx_common/xlldma.h                 |  579 +++++++++++
 drivers/xilinx_common/xlldma_bd.h              |  302 ++++++
 drivers/xilinx_common/xlldma_bdring.c          | 1124 ++++++++++++++++++++
 drivers/xilinx_common/xlldma_bdring.h          |  434 ++++++++
 drivers/xilinx_common/xlldma_hw.h              |  373 +++++++
 drivers/xilinx_common/xlldma_userip.h          |  106 ++
 drivers/xilinx_common/xllfifo.c                |  393 +++++++
 drivers/xilinx_common/xllfifo.h                |  575 ++++++++++
 drivers/xilinx_common/xllfifo_hw.h             |  211 ++++
 drivers/xilinx_common/xpacket_fifo_l_v2_00_a.c |  852 +++++++++++++++
 drivers/xilinx_common/xpacket_fifo_l_v2_00_a.h |  145 +++
 drivers/xilinx_common/xpacket_fifo_v2_00_a.c   |  329 ++++++
 drivers/xilinx_common/xpacket_fifo_v2_00_a.h   |  281 +++++
 drivers/xilinx_common/xstatus.h                |  357 +++++++
 drivers/xilinx_common/xstreamer.c              |  512 +++++++++
 drivers/xilinx_common/xstreamer.h              |  325 ++++++
 drivers/xilinx_common/xversion.c               |  341 ++++++
 drivers/xilinx_common/xversion.h               |   98 ++
 54 files changed, 19425 insertions(+), 0 deletions(-)
 create mode 100644 drivers/pmods/Kconfig
 create mode 100644 drivers/pmods/Makefile
 create mode 100644 drivers/pmods/pmodoled-gpio.c
 create mode 100644 drivers/xilinx_common/Kconfig
 create mode 100644 drivers/xilinx_common/Makefile
 create mode 100644 drivers/xilinx_common/xbasic_types.c
 create mode 100644 drivers/xilinx_common/xbasic_types.h
 create mode 100644 drivers/xilinx_common/xbuf_descriptor.h
 create mode 100644 drivers/xilinx_common/xdebug.h
 create mode 100644 drivers/xilinx_common/xdma_channel.c
 create mode 100644 drivers/xilinx_common/xdma_channel.h
 create mode 100644 drivers/xilinx_common/xdma_channel_i.h
 create mode 100644 drivers/xilinx_common/xdma_channel_sg.c
 create mode 100644 drivers/xilinx_common/xdmabdv3.h
 create mode 100644 drivers/xilinx_common/xdmav3.c
 create mode 100644 drivers/xilinx_common/xdmav3.h
 create mode 100644 drivers/xilinx_common/xdmav3_intr.c
 create mode 100644 drivers/xilinx_common/xdmav3_l.h
 create mode 100644 drivers/xilinx_common/xdmav3_selftest.c
 create mode 100644 drivers/xilinx_common/xdmav3_sg.c
 create mode 100644 drivers/xilinx_common/xdmav3_simple.c
 create mode 100644 drivers/xilinx_common/xenv.h
 create mode 100644 drivers/xilinx_common/xil_assert.c
 create mode 100644 drivers/xilinx_common/xil_assert.h
 create mode 100644 drivers/xilinx_common/xil_io.h
 create mode 100644 drivers/xilinx_common/xil_types.h
 create mode 100644 drivers/xilinx_common/xilinx_syms.c
 create mode 100644 drivers/xilinx_common/xio.c
 create mode 100644 drivers/xilinx_common/xio.h
 create mode 100644 drivers/xilinx_common/xio_dcr.c
 create mode 100644 drivers/xilinx_common/xio_dcr.h
 create mode 100644 drivers/xilinx_common/xipif_v1_23_b.c
 create mode 100644 drivers/xilinx_common/xipif_v1_23_b.h
 create mode 100644 drivers/xilinx_common/xlldma.c
 create mode 100644 drivers/xilinx_common/xlldma.h
 create mode 100644 drivers/xilinx_common/xlldma_bd.h
 create mode 100644 drivers/xilinx_common/xlldma_bdring.c
 create mode 100644 drivers/xilinx_common/xlldma_bdring.h
 create mode 100644 drivers/xilinx_common/xlldma_hw.h
 create mode 100644 drivers/xilinx_common/xlldma_userip.h
 create mode 100644 drivers/xilinx_common/xllfifo.c
 create mode 100644 drivers/xilinx_common/xllfifo.h
 create mode 100644 drivers/xilinx_common/xllfifo_hw.h
 create mode 100644 drivers/xilinx_common/xpacket_fifo_l_v2_00_a.c
 create mode 100644 drivers/xilinx_common/xpacket_fifo_l_v2_00_a.h
 create mode 100644 drivers/xilinx_common/xpacket_fifo_v2_00_a.c
 create mode 100644 drivers/xilinx_common/xpacket_fifo_v2_00_a.h
 create mode 100644 drivers/xilinx_common/xstatus.h
 create mode 100644 drivers/xilinx_common/xstreamer.c
 create mode 100644 drivers/xilinx_common/xstreamer.h
 create mode 100644 drivers/xilinx_common/xversion.c
 create mode 100644 drivers/xilinx_common/xversion.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index f5fb072..333eb26 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -112,6 +112,8 @@ source "drivers/dca/Kconfig"
 
 source "drivers/auxdisplay/Kconfig"
 
+source "drivers/xilinx_common/Kconfig"
+
 source "drivers/uio/Kconfig"
 
 source "drivers/vfio/Kconfig"
@@ -154,6 +156,8 @@ source "drivers/vme/Kconfig"
 
 source "drivers/pwm/Kconfig"
 
+source "drivers/pmods/Kconfig"
+
 source "drivers/irqchip/Kconfig"
 
 source "drivers/ipack/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 7863b9f..88d928a 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -146,3 +146,7 @@ obj-$(CONFIG_MEMORY)		+= memory/
 obj-$(CONFIG_IIO)		+= iio/
 obj-$(CONFIG_VME_BUS)		+= vme/
 obj-$(CONFIG_IPACK_BUS)		+= ipack/
+
+obj-y				+= xilinx_common/
+
+obj-$(CONFIG_PMODS)		+= pmods/
diff --git a/drivers/pmods/Kconfig b/drivers/pmods/Kconfig
new file mode 100644
index 0000000..09706b7
--- /dev/null
+++ b/drivers/pmods/Kconfig
@@ -0,0 +1,20 @@
+menuconfig PMODS
+	bool "Pmod Support"
+	depends on HAS_IOMEM && OF
+	help
+		Digilent PMOD Support
+
+if PMODS
+
+config PMODS_DEBUG
+	bool "Enable Debug Message"
+
+config PMODOLED
+	tristate "PmodOLED1"
+	select SPI_BITBANG
+	select SPI_GPIO
+	help
+		The Digilent PmodOLED1, as well as ZED on-board OLED. Uses SPI over GPIO.
+		Configuration SPI_BITBANG and SPI_GPIO will be selected automatically.
+
+endif # PMODS
diff --git a/drivers/pmods/Makefile b/drivers/pmods/Makefile
new file mode 100644
index 0000000..ef90c23
--- /dev/null
+++ b/drivers/pmods/Makefile
@@ -0,0 +1,4 @@
+
+ccflags-$(CONFIG_PMODS_DEBUG)  += -DDEBUG
+
+obj-$(CONFIG_PMODOLED) += pmodoled-gpio.o
diff --git a/drivers/pmods/pmodoled-gpio.c b/drivers/pmods/pmodoled-gpio.c
new file mode 100644
index 0000000..5c858a1
--- /dev/null
+++ b/drivers/pmods/pmodoled-gpio.c
@@ -0,0 +1,863 @@
+/*
+ * pmodolde-gpio.c - PmodOLED-GPIO driver
+ *
+ * Copyright (c) 2012 Digilent.  All right reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <asm/uaccess.h>
+
+#define DRIVER_NAME "pmodoled-gpio"
+#define SPI_DRIVER_NAME "pmodoled-gpio-spi"
+#define MAX_PMODOLED_GPIO_DEV_NUM 16
+#define DISPLAY_BUF_SZ	512 /* 32 x 128 bit monochrome  == 512 bytes        */
+#define MAX_LINE_LEN	16 /* 128 bits wide and current char width is 8 bit */
+#define MAX_ROW			4
+#define OLED_MAX_PG_CNT      4 /* number of display pages in OLED controller */
+#define OLED_CONTROLLER_PG_SZ	128
+#define OLED_CONTROLLER_CMD	0
+#define OLED_CONTROLLER_DATA	1
+
+/* commands for the OLED display controller	*/
+#define OLED_SET_PG_ADDR		0x22
+#define OLED_DISPLAY_OFF		0xAE
+#define OLED_DISPLAY_ON			0xAF
+#define OLED_CONTRAST_CTRL		0x81
+#define OLED_SET_PRECHARGE_PERIOD	0xD9
+#define OLED_SET_SEGMENT_REMAP		0xA1
+#define OLED_SET_COM_DIR			0xC8
+#define OLED_SET_COM_PINS		0xDA
+
+static dev_t gpio_pmodoled_dev_id;
+static unsigned int device_num;
+static unsigned int cur_minor;
+static unsigned int spi_drv_registered;
+/* struct mutex minor_mutex; */
+static struct class *gpio_pmodoled_class;
+
+struct gpio_pmodoled_device {
+	const char *name;
+	/* R/W Mutex Lock */
+	struct mutex mutex;
+	/* Display Buffers */
+	uint8_t disp_on;
+	uint8_t *disp_buf;
+	/* Pin Assignment */
+	unsigned long iVBAT;
+	unsigned long iVDD;
+	unsigned long iRES;
+	unsigned long iDC;
+	unsigned long iSCLK;
+	unsigned long iSDIN;
+	unsigned long iCS;
+	/* SPI Info */
+	uint32_t spi_id;
+	/* platform device structures */
+	struct platform_device *pdev;
+	/* Char Device */
+	struct cdev cdev;
+	struct spi_device *spi;
+	dev_t dev_id;
+};
+
+/**
+ * screen_buf_to_display -
+ * @screen_buf -
+ * @dev -
+ *
+ */
+static int screen_buf_to_display(uint8_t *screen_buf, struct gpio_pmodoled_device *dev)
+{
+	uint32_t pg;
+	int status;
+	uint8_t lower_start_column = 0x00;
+	uint8_t upper_start_column = 0x10;
+	uint8_t wr_buf[10];
+
+	for (pg = 0; pg < OLED_MAX_PG_CNT; pg++) {
+		wr_buf[0] = OLED_SET_PG_ADDR;
+		wr_buf[1] = pg;
+		wr_buf[2] = lower_start_column;
+		wr_buf[3] = upper_start_column;
+		gpio_set_value(dev->iDC, OLED_CONTROLLER_CMD);
+		status = spi_write(dev->spi, wr_buf, 4);
+		if (status) {
+			dev_err(&dev->spi->dev, "screen_buf_to_display: Error writing to SPI\n");
+			break;
+		}
+
+		gpio_set_value(dev->iDC, OLED_CONTROLLER_DATA);
+		status = spi_write(dev->spi, (uint8_t *) (screen_buf +
+						(pg*OLED_CONTROLLER_PG_SZ)), OLED_CONTROLLER_PG_SZ);
+		if (status) {
+			dev_err(&dev->spi->dev, "screen_buf_to_display: Error writing to SPI\n");
+			break;
+		}
+	}
+	return status;
+}
+
+/**
+ * A basic open function. It exists mainly to save the id of
+ * the OLED and some other basic information.
+ */
+static int 	gpio_pmodoled_open(struct inode *inode, struct file *fp)
+{
+	struct gpio_pmodoled_device *dev;
+
+	dev = container_of(inode->i_cdev, struct gpio_pmodoled_device, cdev);
+	fp->private_data = dev;
+
+	return 0;
+}
+
+static int 	gpio_pmodoled_close(struct inode *inode, struct file *fp)
+{
+	return 0;
+}
+
+/**
+ * Driver write function
+ *
+ * This function uses a generic SPI write to send values to the Pmod device
+ * It takes a raw data array from the app in the buffer, copied it into
+ * device dispay buffer, and finally sends the buffer to the OLED using SPI
+ */
+static ssize_t gpio_pmodoled_write(struct file *fp, const char __user *buffer, size_t length, loff_t *offset)
+{
+	ssize_t retval = 0;
+	struct gpio_pmodoled_device *dev;
+	unsigned int minor_id;
+	int cnt;
+	int status;
+
+	dev = fp->private_data;
+	minor_id = MINOR(dev->dev_id);
+
+	if (mutex_lock_interruptible(&dev->mutex)) {
+		retval = -ERESTARTSYS;
+		goto write_lock_err;
+	}
+
+	if (buffer == NULL) {
+		dev_err(&dev->spi->dev, "oled_write: ERROR: invalid buffer address: 0x%08x\n",
+					(__force unsigned int) buffer);
+		retval = -EINVAL;
+		goto quit_write;
+	}
+
+	if (length > DISPLAY_BUF_SZ)
+		cnt = DISPLAY_BUF_SZ;
+	else
+		cnt = length;
+
+	if (copy_from_user(dev->disp_buf, buffer, cnt)) {
+		dev_err(&dev->spi->dev, "oled_write: copy_from_user failed\n");
+		retval = -EFAULT;
+		goto quit_write;
+	} else
+		retval = cnt;
+
+	status = screen_buf_to_display(dev->disp_buf, dev);
+	if (status) {
+		dev_err(&dev->spi->dev, "oled_write: Error sending string to display\n");
+		retval = -EFAULT;
+		goto quit_write;
+	}
+
+quit_write:
+	mutex_unlock(&dev->mutex);
+write_lock_err:
+	return retval;
+}
+
+/**
+ * Driver Read Function
+ *
+ * This function does not actually read the Pmod as it is a write-only device. Instead
+ * It returns data in the buffer generated for the display that was used when the OLED
+ * was last programmed.
+ */
+static ssize_t	gpio_pmodoled_read(struct file *fp, char __user *buffer, size_t length, loff_t *offset)
+{
+	ssize_t retval = 0;
+	struct gpio_pmodoled_device *dev;
+	unsigned int minor_id;
+	int cnt;
+
+	dev = fp->private_data;
+	minor_id = MINOR(dev->dev_id);
+
+	if (mutex_lock_interruptible(&dev->mutex)) {
+		retval = -ERESTARTSYS;
+		goto read_lock_err;
+	}
+
+	if (buffer == NULL) {
+		dev_err(&dev->spi->dev, "OLED_read: ERROR: invalid buffer "
+				"address: 0x%08X\n", (__force unsigned int)buffer);
+		retval = -EINVAL;
+		goto quit_read;
+	}
+
+	if (length > DISPLAY_BUF_SZ)
+		cnt = DISPLAY_BUF_SZ;
+	else
+		cnt = length;
+	retval = copy_to_user((void __user *)buffer, dev->disp_buf, cnt);
+	if (!retval)
+		retval = cnt; /* copy success, return amount in buffer */
+
+quit_read:
+	mutex_unlock(&dev->mutex);
+read_lock_err:
+	return retval;
+}
+
+static struct file_operations gpio_pmodoled_cdev_fops = {
+	.owner = THIS_MODULE,
+	.write = gpio_pmodoled_write,
+	.read = gpio_pmodoled_read,
+	.open = gpio_pmodoled_open,
+	.release = gpio_pmodoled_close,
+};
+
+static int add_gpio_pmodoled_device_to_bus(struct gpio_pmodoled_device *dev)
+{
+	struct spi_master *spi_master;
+	struct spi_device *spi_device;
+	int status = 0;
+
+	spi_master = spi_busnum_to_master(dev->spi_id);
+	if (!spi_master) {
+		dev_err(&dev->pdev->dev, "spi_busnum_to_master(%d) returned NULL\n", dev->spi_id);
+		return -ENOSYS;
+	}
+
+	spi_device = spi_alloc_device(spi_master);
+	if (!spi_device) {
+		put_device(&spi_master->dev);
+		dev_err(&dev->pdev->dev, "spi_alloc_device() failed\n");
+		return -ENOMEM;
+	}
+
+	spi_device->chip_select = 0;
+	spi_device->max_speed_hz = 4000000;
+	spi_device->mode = SPI_MODE_0;
+	spi_device->bits_per_word = 8;
+	spi_device->controller_data = (void *) dev->iCS;
+	spi_device->dev.platform_data = dev;
+	strlcpy(spi_device->modalias, SPI_DRIVER_NAME, sizeof(SPI_DRIVER_NAME));
+
+	status = spi_add_device(spi_device);
+	if (status < 0) {
+		spi_dev_put(spi_device);
+		dev_err(&dev->pdev->dev, "spi_add_device() failed %d\n", status);
+		return status;
+	}
+	dev->spi = spi_device;
+
+	put_device(&spi_master->dev);
+
+	return status;
+}
+
+/**
+ * gpio_pmodoled_setup_cdev - Setup Char Device for ZED on-board OLED device.
+ * @dev: pointer to device tree node
+ * @dev_id: pointer to device major and minor number
+ * @spi: pointer to spi_device structure
+ *
+ * This function initializes char device for OLED device, and add it into
+ * kernel device structure. It returns 0, if the cdev is successfully
+ * initialized, or a negative value if there is an error.
+ */
+static int gpio_pmodoled_setup_cdev(struct gpio_pmodoled_device *dev, dev_t *dev_id, struct spi_device *spi)
+{
+	int status = 0;
+	struct device *device;
+
+	cdev_init(&dev->cdev, &gpio_pmodoled_cdev_fops);
+	dev->cdev.owner = THIS_MODULE;
+	dev->cdev.ops = &gpio_pmodoled_cdev_fops;
+	dev->spi = spi;
+
+	*dev_id = MKDEV(MAJOR(gpio_pmodoled_dev_id), cur_minor++);
+	status = cdev_add(&dev->cdev, *dev_id, 1);
+	if (status < 0)
+		return status;
+
+	/* Add Device node in system */
+	device = device_create(gpio_pmodoled_class, NULL,
+					*dev_id, NULL,
+					"%s", dev->name);
+	if (IS_ERR(device)) {
+		status = PTR_ERR(device);
+		dev_err(&spi->dev, "failed to create device node %s, err %d\n",
+				dev->name, status);
+		cdev_del(&dev->cdev);
+	}
+
+	return status;
+}
+
+/**
+ * gpio_pmodoled_init_gpio - Initialize GPIO for ZED Onboard OLED
+ * @dev - gpio_pmodoled_device
+ *
+ * Initializes OLED GPIO Control Pins.
+ * It returns 0, if the gpio pins are successfully
+ * initialized, or a negative value if there is an error.
+ */
+static int gpio_pmodoled_init_gpio(struct gpio_pmodoled_device *dev)
+{
+	struct gpio gpio_pmodoled_ctrl[] = {
+		{dev->iVBAT, GPIOF_OUT_INIT_HIGH, "OLED VBat"},
+		{dev->iVDD, GPIOF_OUT_INIT_HIGH, "OLED VDD"},
+		{dev->iRES, GPIOF_OUT_INIT_HIGH, "OLED_RESET"},
+		{dev->iDC, GPIOF_OUT_INIT_HIGH, "OLED_D/C"},
+	};
+	int status;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(gpio_pmodoled_ctrl); i++) {
+		status = gpio_is_valid(gpio_pmodoled_ctrl[i].gpio);
+		if (!status) {
+			dev_err(&dev->spi->dev, "!! gpio_is_valid for GPIO %d, %s FAILED!, status: %d\n",
+					gpio_pmodoled_ctrl[i].gpio, gpio_pmodoled_ctrl[i].label, status);
+			goto gpio_invalid;
+		}
+	}
+
+	status = gpio_request_array(gpio_pmodoled_ctrl, ARRAY_SIZE(gpio_pmodoled_ctrl));
+	if (status) {
+		dev_err(&dev->spi->dev, "!!  gpio_request_array FAILED!\n");
+		dev_err(&dev->spi->dev, "          status is: %d\n", status);
+		gpio_free_array(gpio_pmodoled_ctrl, 4);
+		goto gpio_invalid;
+	}
+
+gpio_invalid:
+	return status;
+}
+
+/**
+ * gpio_pmodoled_disp_init -
+ * @dev:
+ *
+ */
+static void gpio_pmodoled_disp_init(struct gpio_pmodoled_device *dev)
+{
+	int status;
+	uint8_t wr_buf[20];
+
+	/* We are going to be sending commands
+	 * so clear the data/cmd bit */
+	gpio_set_value(dev->iDC, OLED_CONTROLLER_CMD);
+
+	/* Start by turning VDD on and wait for the power to come up */
+	gpio_set_value(dev->iVDD, 0);
+	msleep(1);
+
+	/* Display off Command */
+	wr_buf[0] = OLED_DISPLAY_OFF;
+	status = spi_write(dev->spi, wr_buf, 1);
+
+	/* Bring Reset Low and then High */
+	gpio_set_value(dev->iRES, 1);
+	msleep(1);
+	gpio_set_value(dev->iRES, 0);
+	msleep(1);
+	gpio_set_value(dev->iRES, 1);
+
+	/* Send the set charge pump and set precharge period commands */
+	wr_buf[0] = 0x8D;
+	wr_buf[1] = 0x14;
+	wr_buf[2] = OLED_SET_PRECHARGE_PERIOD;
+	wr_buf[3] = 0xF1;
+
+	status = spi_write(dev->spi, wr_buf, 4);
+
+	/* Turn on VCC and wait 100ms */
+	gpio_set_value(dev->iVBAT, 0);
+	msleep(100);
+
+	/* Set Display COntrast */
+	wr_buf[0] = OLED_CONTRAST_CTRL;
+	wr_buf[1] = 0x0F;
+
+	/* Invert the display */
+	wr_buf[2] = OLED_SET_SEGMENT_REMAP; /* Remap Columns */
+	wr_buf[3] = OLED_SET_COM_DIR;	/* Remap Rows */
+
+	/* Select sequential COM configuration */
+	wr_buf[4] = OLED_SET_COM_PINS;
+	wr_buf[5] = 0x00;
+	wr_buf[6] = 0xC0;
+	wr_buf[7] = 0x20;
+	wr_buf[8] = 0x00;
+
+	/* Turn on Display */
+	wr_buf[9] = OLED_DISPLAY_ON;
+
+	status = spi_write(dev->spi, wr_buf, 10);
+}
+
+
+/**
+ * SPI hardware probe. Sets correct SPI mode, attempts
+ * to obtain memory needed by the driver, and performs
+ * a simple initialization of the device.
+ */
+static int gpio_pmodoled_spi_probe(struct spi_device *spi)
+{
+	int status = 0;
+	struct gpio_pmodoled_device *gpio_pmodoled_dev;
+
+	/* We rely on full duplex transfers, mostly to reduce
+	 * per transfer overheads (by making few transfers).
+	 */
+	if (spi->master->flags & SPI_MASTER_HALF_DUPLEX) {
+		status = -EINVAL;
+		dev_err(&spi->dev, "SPI settings incorrect: %d\n", status);
+		goto spi_err;
+	}
+
+	/* We must use SPI_MODE_0 */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+
+	status = spi_setup(spi);
+	if (status < 0) {
+		dev_err(&spi->dev, "needs SPI mode %02x, %d KHz; %d\n",
+				spi->mode, spi->max_speed_hz / 1000,
+				status);
+		goto spi_err;
+	}
+
+	/* Get gpio_pmodoled_device structure */
+	gpio_pmodoled_dev = (struct gpio_pmodoled_device *) spi->dev.platform_data;
+	if (gpio_pmodoled_dev == NULL) {
+		dev_err(&spi->dev, "Cannot get gpio_pmodoled_device.\n");
+		status = -EINVAL;
+		goto spi_platform_data_err;
+	}
+
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] SPI Probing\n", gpio_pmodoled_dev->name);
+
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_probe: setup char device\n", gpio_pmodoled_dev->name);
+#endif
+
+	/* Setup char driver */
+	status = gpio_pmodoled_setup_cdev(gpio_pmodoled_dev, &(gpio_pmodoled_dev->dev_id), spi);
+	if (status) {
+		dev_err(&spi->dev, "spi_probe: Error adding %s device: %d\n", SPI_DRIVER_NAME, status);
+		goto cdev_add_err;
+	}
+
+	/* Initialize Mutex */
+	mutex_init(&gpio_pmodoled_dev->mutex);
+
+	/**
+	 * It is important to the OLED's longevity that the lines that
+	 * control it's power are carefully controlled. This is a good
+	 * time to ensure that the device is ot turned on until it is
+	 * instructed to do so.
+	 */
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_probe: initialize device\n", gpio_pmodoled_dev->name);
+#endif
+
+	status = gpio_pmodoled_init_gpio(gpio_pmodoled_dev);
+	if (status) {
+		dev_err(&spi->dev, "spi_probe: Error initializing GPIO\n");
+		goto oled_init_error;
+	}
+
+	gpio_pmodoled_disp_init(gpio_pmodoled_dev);
+
+	memset(gpio_pmodoled_dev->disp_buf, 0x00, DISPLAY_BUF_SZ);
+
+	status = screen_buf_to_display(gpio_pmodoled_dev->disp_buf, gpio_pmodoled_dev);
+	if (status) {
+		dev_err(&spi->dev, "spi_probe: Error sending initial Display String\n");
+		goto oled_init_error;
+	}
+	return status;
+
+oled_init_error:
+	if (&gpio_pmodoled_dev->cdev)
+		cdev_del(&gpio_pmodoled_dev->cdev);
+cdev_add_err:
+spi_platform_data_err:
+spi_err:
+	return status;
+}
+
+static int gpio_pmodoled_spi_remove(struct spi_device *spi)
+{
+	int status;
+	struct gpio_pmodoled_device *dev;
+	uint8_t wr_buf[10];
+
+	dev = (struct gpio_pmodoled_device *) spi->dev.platform_data;
+
+	if (dev == NULL) {
+		dev_err(&spi->dev, "spi_remove: Error fetch gpio_pmodoled_device struct\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_remove: Clearing Display\n", dev->name);
+#endif
+
+	/* Clear Display */
+	memset(dev->disp_buf, 0, DISPLAY_BUF_SZ);
+	status = screen_buf_to_display(dev->disp_buf, dev);
+
+	/* Turn off display */
+	wr_buf[0] = OLED_DISPLAY_OFF;
+	status = spi_write(spi, wr_buf, 1);
+	if (status)
+		dev_err(&spi->dev, "oled_spi_remove: Error writing to SPI device\n");
+
+	/* Turn off VCC (VBAT) */
+	gpio_set_value(dev->iVBAT, 1);
+	msleep(100);
+	/* TUrn off VDD Power */
+	gpio_set_value(dev->iVDD, 1);
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_remove: Free GPIOs\n", dev->name);
+#endif
+
+{
+	struct gpio gpio_pmodoled_ctrl[] = {
+		{dev->iVBAT, GPIOF_OUT_INIT_HIGH, "OLED VBat"},
+		{dev->iVDD, GPIOF_OUT_INIT_HIGH, "OLED VDD"},
+		{dev->iRES, GPIOF_OUT_INIT_HIGH, "OLED_RESET"},
+		{dev->iDC, GPIOF_OUT_INIT_HIGH, "OLED_D/C"},
+	};
+
+	gpio_free_array(gpio_pmodoled_ctrl, 4);
+}
+
+	if (&dev->cdev) {
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_remove: Destroy Char Device\n", dev->name);
+#endif
+		device_destroy(gpio_pmodoled_class, dev->dev_id);
+		cdev_del(&dev->cdev);
+	}
+
+	cur_minor--;
+
+	printk(KERN_INFO SPI_DRIVER_NAME " [%s] spi_remove: Device Removed\n", dev->name);
+
+	return status;
+}
+
+static struct spi_driver gpio_pmodoled_spi_driver = {
+	.driver = {
+		.name = SPI_DRIVER_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+	.probe = gpio_pmodoled_spi_probe,
+	.remove = gpio_pmodoled_spi_remove,
+};
+
+static const struct of_device_id gpio_pmodoled_of_match[] = {
+	{ .compatible = "dglnt,pmodoled-gpio", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, gpio_pmodoled_of_match);
+
+/**
+ * gpio_pmodoled_of_probe - Probe method for PmodOLED device (over GPIO).
+ * @pdev: pointer to platform devices
+ *
+ * This function probes the OLED device in the device tree. It initializes the
+ * OLED driver data structure. It returns 0, if the driver is bound to the OLED
+ * device, or a negative value if there is an error.
+ */
+static int gpio_pmodoled_of_probe(struct platform_device *pdev)
+{
+	struct gpio_pmodoled_device *gpio_pmodoled_dev;
+	struct platform_device *gpio_pmodoled_pdev;
+	struct spi_gpio_platform_data *gpio_pmodoled_pdata;
+
+	struct device_node *np = pdev->dev.of_node;
+
+	const u32 *tree_info;
+	int status = 0;
+
+	/* Alloc Space for platform device structure */
+	gpio_pmodoled_dev = (struct gpio_pmodoled_device *) kzalloc(sizeof(*gpio_pmodoled_dev), GFP_KERNEL);
+	if (!gpio_pmodoled_dev) {
+		status = -ENOMEM;
+		goto dev_alloc_err;
+	}
+
+	/* Alloc Graphic Buffer for device */
+	gpio_pmodoled_dev->disp_buf = (uint8_t *) kmalloc(DISPLAY_BUF_SZ, GFP_KERNEL);
+	if (!gpio_pmodoled_dev->disp_buf) {
+		status = -ENOMEM;
+		dev_err(&pdev->dev, "Device Display data buffer allocation failed: %d\n", status);
+		goto disp_buf_alloc_err;
+	}
+
+	/* Get the GPIO Pins */
+	gpio_pmodoled_dev->iVBAT = of_get_named_gpio(np, "vbat-gpio", 0);
+	gpio_pmodoled_dev->iVDD = of_get_named_gpio(np, "vdd-gpio", 0);
+	gpio_pmodoled_dev->iRES = of_get_named_gpio(np, "res-gpio", 0);
+	gpio_pmodoled_dev->iDC = of_get_named_gpio(np, "dc-gpio", 0);
+	gpio_pmodoled_dev->iSCLK = of_get_named_gpio(np, "spi-sclk-gpio", 0);
+	gpio_pmodoled_dev->iSDIN = of_get_named_gpio(np, "spi-sdin-gpio", 0);
+	status = of_get_named_gpio(np, "spi-cs-gpio", 0);
+	gpio_pmodoled_dev->iCS = (status < 0) ? SPI_GPIO_NO_CHIPSELECT : status;
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO DRIVER_NAME " %s: iVBAT: 0x%lx\n", np->name, gpio_pmodoled_dev->iVBAT);
+	printk(KERN_INFO DRIVER_NAME " %s: iVDD : 0x%lx\n", np->name, gpio_pmodoled_dev->iVDD);
+	printk(KERN_INFO DRIVER_NAME " %s: iRES : 0x%lx\n", np->name, gpio_pmodoled_dev->iRES);
+	printk(KERN_INFO DRIVER_NAME " %s: iDC  : 0x%lx\n", np->name, gpio_pmodoled_dev->iDC);
+	printk(KERN_INFO DRIVER_NAME " %s: iSCLK: 0x%lx\n", np->name, gpio_pmodoled_dev->iSCLK);
+	printk(KERN_INFO DRIVER_NAME " %s: iSDIN: 0x%lx\n", np->name, gpio_pmodoled_dev->iSDIN);
+	printk(KERN_INFO DRIVER_NAME " %s: iCS  : 0x%lx\n", np->name, gpio_pmodoled_dev->iCS);
+#endif
+
+	/* Get SPI Related Params */
+	tree_info = of_get_property(np, "spi-bus-num", NULL);
+	if (tree_info) {
+		gpio_pmodoled_dev->spi_id = be32_to_cpup((tree_info));
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " %s: BUS_ID\t%x\n", np->name, gpio_pmodoled_dev->spi_id);
+#endif
+	}
+
+	/* Alloc Space for platform data structure */
+	gpio_pmodoled_pdata = (struct spi_gpio_platform_data *) kzalloc(sizeof(*gpio_pmodoled_pdata), GFP_KERNEL);
+	if (!gpio_pmodoled_pdata) {
+		status = -ENOMEM;
+		goto pdata_alloc_err;
+	}
+
+	/* Fill up Platform Data Structure */
+	gpio_pmodoled_pdata->sck = gpio_pmodoled_dev->iSCLK;
+	gpio_pmodoled_pdata->miso = SPI_GPIO_NO_MISO;
+	gpio_pmodoled_pdata->mosi = gpio_pmodoled_dev->iSDIN;
+	gpio_pmodoled_pdata->num_chipselect = 1;
+
+	/* Alloc Space for platform data structure */
+	gpio_pmodoled_pdev = (struct platform_device *) kzalloc(sizeof(*gpio_pmodoled_pdev), GFP_KERNEL);
+	if (!gpio_pmodoled_pdev) {
+		status = -ENOMEM;
+		goto pdev_alloc_err;
+	}
+
+	/* Fill up Platform Device Structure */
+	gpio_pmodoled_pdev->name = "spi_gpio";
+	gpio_pmodoled_pdev->id = gpio_pmodoled_dev->spi_id;
+	gpio_pmodoled_pdev->dev.platform_data = gpio_pmodoled_pdata;
+	gpio_pmodoled_dev->pdev = gpio_pmodoled_pdev;
+
+	/* Register spi_gpio master */
+	status = platform_device_register(gpio_pmodoled_dev->pdev);
+	if (status < 0) {
+		dev_err(&pdev->dev, "platform_device_register failed: %d\n", status);
+		goto pdev_reg_err;
+	}
+
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO DRIVER_NAME " %s: spi_gpio platform device registered.\n", np->name);
+#endif
+	gpio_pmodoled_dev->name = np->name;
+
+	/* Fill up Board Info for SPI device */
+	status = add_gpio_pmodoled_device_to_bus(gpio_pmodoled_dev);
+	if (status < 0) {
+		dev_err(&pdev->dev, "add_gpio_pmodoled_device_to_bus failed: %d\n", status);
+		goto spi_add_err;
+	}
+
+#ifdef CONFIG_PMODS_DEBUG
+	printk(KERN_INFO DRIVER_NAME " %s: spi device registered.\n", np->name);
+#endif
+
+	/* Point device node data to gpio_pmodoled_device structure */
+	if (np->data == NULL)
+		np->data = gpio_pmodoled_dev;
+
+	if (gpio_pmodoled_dev_id == 0) {
+		/* Alloc Major & Minor number for char device */
+		status = alloc_chrdev_region(&gpio_pmodoled_dev_id, 0, MAX_PMODOLED_GPIO_DEV_NUM, DRIVER_NAME);
+		if (status) {
+			dev_err(&pdev->dev, "Character device region not allocated correctly: %d\n", status);
+			goto err_alloc_chrdev_region;
+		}
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " : Char Device Region Registered, with Major: %d.\n",
+						MAJOR(gpio_pmodoled_dev_id));
+#endif
+	}
+
+	if (gpio_pmodoled_class == NULL) {
+		/* Create Pmodoled-gpio Device Class */
+		gpio_pmodoled_class = class_create(THIS_MODULE, DRIVER_NAME);
+		if (IS_ERR(gpio_pmodoled_class)) {
+			status = PTR_ERR(gpio_pmodoled_class);
+			goto err_create_class;
+		}
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " : pmodoled_gpio device class registered.\n");
+#endif
+	}
+
+	if (spi_drv_registered == 0) {
+		/* Register SPI Driver for Pmodoled Device */
+		status = spi_register_driver(&gpio_pmodoled_spi_driver);
+		if (status < 0) {
+			dev_err(&pdev->dev, "gpio_pmodoled_spi_driver register failed: %d\n", status);
+			goto err_spi_register;
+		}
+		spi_drv_registered = 1;
+	}
+
+	device_num++;
+
+	return status;
+
+err_spi_register:
+	class_destroy(gpio_pmodoled_class);
+	gpio_pmodoled_class = NULL;
+err_create_class:
+	unregister_chrdev_region(gpio_pmodoled_dev_id, MAX_PMODOLED_GPIO_DEV_NUM);
+	gpio_pmodoled_dev_id = 0;
+err_alloc_chrdev_region:
+	spi_unregister_device(gpio_pmodoled_dev->spi);
+spi_add_err:
+	platform_device_unregister(gpio_pmodoled_dev->pdev);
+pdev_reg_err:
+	kfree(gpio_pmodoled_pdev);
+pdev_alloc_err:
+	kfree(gpio_pmodoled_pdata);
+pdata_alloc_err:
+	kfree(gpio_pmodoled_dev->disp_buf);
+disp_buf_alloc_err:
+	kfree(gpio_pmodoled_dev);
+dev_alloc_err:
+	return status;
+}
+
+/**
+ * gpio_pmodoled_of_remove - Remove method for ZED on-board OLED device.
+ * @np: pointer to device tree node
+ *
+ * This function removes the OLED device in the device tree. It frees the
+ * OLED driver data structure. It returns 0, if the driver is successfully
+ * removed, or a negative value if there is an error.
+ */
+static int gpio_pmodoled_of_remove(struct platform_device *pdev)
+{
+	struct gpio_pmodoled_device *gpio_pmodoled_dev;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (np->data == NULL) {
+		dev_err(&pdev->dev, "pmodoled %s: ERROR: No gpio_pmodoled_device structure found!\n", np->name);
+		return -ENOSYS;
+	}
+	gpio_pmodoled_dev = (struct gpio_pmodoled_device *) (np->data);
+
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " %s : Free display buffer.\n", np->name);
+#endif
+
+	if (gpio_pmodoled_dev->disp_buf != NULL)
+		kfree(gpio_pmodoled_dev->disp_buf);
+
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " %s : Unregister gpio_spi Platform Devices.\n", np->name);
+#endif
+
+	if (gpio_pmodoled_dev->pdev != NULL)
+		platform_device_unregister(gpio_pmodoled_dev->pdev);
+
+	np->data = NULL;
+	device_num--;
+
+	/* Unregister SPI Driver, Destroy pmodoled-gpio class, Release device id Region after
+	 * all pmodoled-gpio devices have been removed.
+	 */
+	if (device_num == 0) {
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " : Unregister SPI Driver.\n");
+#endif
+		spi_unregister_driver(&gpio_pmodoled_spi_driver);
+		spi_drv_registered = 0;
+
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " : Destroy pmodoled_gpio Class.\n");
+#endif
+
+		if (gpio_pmodoled_class)
+			class_destroy(gpio_pmodoled_class);
+
+		gpio_pmodoled_class = NULL;
+
+#ifdef CONFIG_PMODS_DEBUG
+		printk(KERN_INFO DRIVER_NAME " : Release Char Device Region.\n");
+#endif
+
+		unregister_chrdev_region(gpio_pmodoled_dev_id, MAX_PMODOLED_GPIO_DEV_NUM);
+		gpio_pmodoled_dev_id = 0;
+	}
+
+	return 0;
+}
+
+static struct platform_driver gpio_pmodoled_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = gpio_pmodoled_of_match,
+	},
+	.probe = gpio_pmodoled_of_probe,
+	.remove = gpio_pmodoled_of_remove,
+};
+
+module_platform_driver(gpio_pmodoled_driver);
+
+MODULE_AUTHOR("Digilent, Inc.");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_NAME": PmodOLED display driver");
+MODULE_ALIAS(DRIVER_NAME);
diff --git a/drivers/xilinx_common/Kconfig b/drivers/xilinx_common/Kconfig
new file mode 100644
index 0000000..a956661
--- /dev/null
+++ b/drivers/xilinx_common/Kconfig
@@ -0,0 +1,33 @@
+config XILINX_EDK
+	bool
+	depends on XILINX_VIRTEX || MICROBLAZE
+	default y
+
+config XILINX_LLDMA_USE_DCR
+	bool
+	depends on NEED_XILINX_LLDMA
+	default XILINX_VIRTEX_5_FXT
+
+
+#
+# Xilinx devices and common device driver infrastructure
+#
+
+config XILINX_DRIVERS
+	bool
+	depends on PPC32 || MICROBLAZE
+	default y
+	---help---
+	  This option is used to enable all of the Xilinx drivers on
+	  supported architectures.  This is often useful if you have a
+	  Xilinx FPGA in a system, either using embedded processors
+	  internal to the FPGA or external processors.
+
+config NEED_XILINX_DMAV3
+	bool
+
+config NEED_XILINX_LLDMA
+	bool
+
+config NEED_XILINX_IPIF
+	bool
diff --git a/drivers/xilinx_common/Makefile b/drivers/xilinx_common/Makefile
new file mode 100644
index 0000000..b86ec5e
--- /dev/null
+++ b/drivers/xilinx_common/Makefile
@@ -0,0 +1,19 @@
+# The Xilinx OS common code 
+
+obj-$(CONFIG_XILINX_EDK) += xbasic_types.o xilinx_syms.o					\
+				xversion.o	xpacket_fifo_v2_00_a.o xpacket_fifo_l_v2_00_a.o	\
+				xdma_channel.o xdma_channel_sg.o xio.o xil_assert.o
+
+obj-$(CONFIG_NEED_XILINX_DMAV3) += \
+			    xdmav3.o xdmav3_intr.o xdmav3_sg.o			\
+			    xdmav3_selftest.o xdmav3_simple.o
+
+obj-$(CONFIG_NEED_XILINX_LLDMA) += \
+			    xlldma_bdring.o xlldma.o				\
+			    xllfifo.o xstreamer.o
+
+obj-$(CONFIG_XILINX_LLDMA_USE_DCR) += \
+					xio_dcr.o
+
+obj-$(CONFIG_NEED_XILINX_IPIF) += \
+			    xipif_v1_23_b.o
diff --git a/drivers/xilinx_common/xbasic_types.c b/drivers/xilinx_common/xbasic_types.c
new file mode 100644
index 0000000..14d3007
--- /dev/null
+++ b/drivers/xilinx_common/xbasic_types.c
@@ -0,0 +1,135 @@
+/* $Id $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2003 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xbasic_types.c
+*
+* This file contains basic functions for Xilinx software IP.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
+* 1.00a xd   11/03/04 Improved support for doxygen.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Variable Definitions *****************************/
+
+/**
+ * This variable allows testing to be done easier with asserts. An assert
+ * sets this variable such that a driver can evaluate this variable
+ * to determine if an assert occurred.
+ */
+unsigned int XAssertStatus;
+
+/**
+ * This variable allows the assert functionality to be changed for testing
+ * such that it does not wait infinitely. Use the debugger to disable the
+ * waiting during testing of asserts.
+ */
+u32 XWaitInAssert = TRUE;
+
+/* The callback function to be invoked when an assert is taken */
+static XAssertCallback XAssertCallbackRoutine = (XAssertCallback) NULL;
+
+/************************** Function Prototypes ******************************/
+
+/*****************************************************************************/
+/**
+*
+* Implements assert. Currently, it calls a user-defined callback function
+* if one has been set.  Then, it potentially enters an infinite loop depending
+* on the value of the XWaitInAssert variable.
+*
+* @param    File is the name of the filename of the source
+* @param    Line is the linenumber within File
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XAssert(char *File, int Line)
+{
+	/* if the callback has been set then invoke it */
+	if (XAssertCallbackRoutine != NULL) {
+		(*XAssertCallbackRoutine) (File, Line);
+	}
+
+	/* if specified, wait indefinitely such that the assert will show up
+	 * in testing
+	 */
+	while (XWaitInAssert) {
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* Sets up a callback function to be invoked when an assert occurs. If there
+* was already a callback installed, then it is replaced.
+*
+* @param    Routine is the callback to be invoked when an assert is taken
+*
+* @return   None.
+*
+* @note     This function has no effect if NDEBUG is set
+*
+******************************************************************************/
+void XAssertSetCallback(XAssertCallback Routine)
+{
+	XAssertCallbackRoutine = Routine;
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Null handler function. This follows the XInterruptHandler signature for
+* interrupt handlers. It can be used to assign a null handler (a stub) to an
+* interrupt controller vector table.
+*
+* @param    NullParameter is an arbitrary void pointer and not used.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XNullHandler(void *NullParameter)
+{
+}
diff --git a/drivers/xilinx_common/xbasic_types.h b/drivers/xilinx_common/xbasic_types.h
new file mode 100644
index 0000000..5055ece
--- /dev/null
+++ b/drivers/xilinx_common/xbasic_types.h
@@ -0,0 +1,223 @@
+/* $Id: xbasic_types.h,v 1.1 2006/12/13 14:21:22 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2004 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xbasic_types.h
+*
+* This file contains basic types for Xilinx software IP.  These types do not
+* follow the standard naming convention with respect to using the component
+* name in front of each name because they are considered to be primitives.
+*
+* @note
+*
+* This file contains items which are architecture dependent.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a rmm  12/14/01 First release
+*       rmm  05/09/03 Added "xassert always" macros to rid ourselves of diab
+*                     compiler warnings
+* 1.00a rpm  11/07/03 Added XNullHandler function as a stub interrupt handler
+* 1.00a rpm  07/21/04 Added XExceptionHandler typedef for processor exceptions
+* 1.00a xd   11/03/04 Improved support for doxygen.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XBASIC_TYPES_H		/* prevent circular inclusions */
+#define XBASIC_TYPES_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+
+#include <linux/types.h>
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE !(TRUE)
+#endif
+
+#define XCOMPONENT_IS_READY     0x11111111  /**< component has been initialized */
+#define XCOMPONENT_IS_STARTED   0x22222222  /**< component has been started */
+
+/* the following constants and declarations are for unit test purposes and are
+ * designed to be used in test applications.
+ */
+#define XTEST_PASSED    0
+#define XTEST_FAILED    1
+
+#define XASSERT_NONE     0
+#define XASSERT_OCCURRED 1
+
+extern unsigned int XAssertStatus;
+extern void XAssert(char *, int);
+
+/**************************** Type Definitions *******************************/
+/**
+ * This data type defines an interrupt handler for a device.
+ * The argument points to the instance of the component
+ */
+typedef void (*XInterruptHandler) (void *InstancePtr);
+
+/**
+ * This data type defines an exception handler for a processor.
+ * The argument points to the instance of the component
+ */
+typedef void (*XExceptionHandler) (void *InstancePtr);
+
+/**
+ * This data type defines a callback to be invoked when an
+ * assert occurs. The callback is invoked only when asserts are enabled
+ */
+typedef void (*XAssertCallback) (char *FilenamePtr, int LineNumber);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+#ifndef NDEBUG
+
+/*****************************************************************************/
+/**
+* This assert macro is to be used for functions that do not return anything
+* (void). This in conjunction with the XWaitInAssert boolean can be used to
+* accomodate tests so that asserts which fail allow execution to continue.
+*
+* @param    expression is the expression to evaluate. If it evaluates to
+*           false, the assert occurs.
+*
+* @return   Returns void unless the XWaitInAssert variable is true, in which
+*           case no return is made and an infinite loop is entered.
+*
+* @note     None.
+*
+******************************************************************************/
+#define XASSERT_VOID(expression)                   \
+{                                                  \
+    if (expression)                                \
+    {                                              \
+        XAssertStatus = XASSERT_NONE;              \
+    }                                              \
+    else                                           \
+    {                                              \
+        XAssert(__FILE__, __LINE__);               \
+                XAssertStatus = XASSERT_OCCURRED;  \
+        return;                                    \
+    }                                              \
+}
+
+/*****************************************************************************/
+/**
+* This assert macro is to be used for functions that do return a value. This in
+* conjunction with the XWaitInAssert boolean can be used to accomodate tests so
+* that asserts which fail allow execution to continue.
+*
+* @param    expression is the expression to evaluate. If it evaluates to false,
+*           the assert occurs.
+*
+* @return   Returns 0 unless the XWaitInAssert variable is true, in which case
+*           no return is made and an infinite loop is entered.
+*
+* @note     None.
+*
+******************************************************************************/
+#define XASSERT_NONVOID(expression)                \
+{                                                  \
+    if (expression)                                \
+    {                                              \
+        XAssertStatus = XASSERT_NONE;              \
+    }                                              \
+    else                                           \
+    {                                              \
+        XAssert(__FILE__, __LINE__);               \
+                XAssertStatus = XASSERT_OCCURRED;  \
+        return 0;                                  \
+    }                                              \
+}
+
+/*****************************************************************************/
+/**
+* Always assert. This assert macro is to be used for functions that do not
+* return anything (void). Use for instances where an assert should always
+* occur.
+*
+* @return Returns void unless the XWaitInAssert variable is true, in which case
+*         no return is made and an infinite loop is entered.
+*
+* @note   None.
+*
+******************************************************************************/
+#define XASSERT_VOID_ALWAYS()                      \
+{                                                  \
+   XAssert(__FILE__, __LINE__);                    \
+           XAssertStatus = XASSERT_OCCURRED;       \
+   return;                                         \
+}
+
+/*****************************************************************************/
+/**
+* Always assert. This assert macro is to be used for functions that do return
+* a value. Use for instances where an assert should always occur.
+*
+* @return Returns void unless the XWaitInAssert variable is true, in which case
+*         no return is made and an infinite loop is entered.
+*
+* @note   None.
+*
+******************************************************************************/
+#define XASSERT_NONVOID_ALWAYS()                   \
+{                                                  \
+   XAssert(__FILE__, __LINE__);                    \
+           XAssertStatus = XASSERT_OCCURRED;       \
+   return 0;                                       \
+}
+
+
+#else
+
+#define XASSERT_VOID(expression)
+#define XASSERT_VOID_ALWAYS()
+#define XASSERT_NONVOID(expression)
+#define XASSERT_NONVOID_ALWAYS()
+#endif
+
+/************************** Function Prototypes ******************************/
+
+void XAssertSetCallback(XAssertCallback Routine);
+void XNullHandler(void *NullParameter);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xbuf_descriptor.h b/drivers/xilinx_common/xbuf_descriptor.h
new file mode 100644
index 0000000..9ec9a36
--- /dev/null
+++ b/drivers/xilinx_common/xbuf_descriptor.h
@@ -0,0 +1,1095 @@
+/* $Id: xbuf_descriptor.h,v 1.1 2006/12/13 14:21:30 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2001-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xbuf_descriptor.h
+*
+* <b>Description</b>
+*
+* This file contains the interface for the XBufDescriptor component.
+* The XBufDescriptor component is a passive component that only maps over
+* a buffer descriptor data structure shared by the scatter gather DMA hardware
+* and software. The component's primary purpose is to provide encapsulation of
+* the buffer descriptor processing.  See the source file xbuf_descriptor.c for
+* details.
+*
+* @note
+*
+* Most of the functions of this component are implemented as macros in order
+* to optimize the processing.  The names are not all uppercase such that they
+* can be switched between macros and functions easily.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a xd   10/27/04 Doxygenated for inclusion in API documentation
+* 1.00b ecm  10/31/05 Updated for the check sum offload changes.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XBUF_DESCRIPTOR_H	/* prevent circular inclusions */
+#define XBUF_DESCRIPTOR_H	/* by using protection macros */
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xdma_channel_i.h"
+
+/************************** Constant Definitions *****************************/
+
+/** @name Buffer Descriptor fields
+ *
+ * @{
+ */
+/** This constant allows access to fields of a buffer descriptor
+ * and is necessary at this level of visibility to allow macros to access
+ * and modify the fields of a buffer descriptor.  It is not expected that the
+ * user of a buffer descriptor would need to use this constant.
+ */
+#define XBD_DEVICE_STATUS_OFFSET    0
+#define XBD_CONTROL_OFFSET          1
+#define XBD_SOURCE_OFFSET           2
+#define XBD_DESTINATION_OFFSET      3
+#define XBD_LENGTH_OFFSET           4
+#define XBD_STATUS_OFFSET           5
+#define XBD_NEXT_PTR_OFFSET         6
+#define XBD_ID_OFFSET               7
+#define XBD_FLAGS_OFFSET            8
+#define XBD_RQSTED_LENGTH_OFFSET    9
+#define XBD_SIZE_IN_WORDS           10
+/* @} */
+
+/**
+ * The following constants define the bits of the flags field of a buffer
+ * descriptor
+ */
+#define XBD_FLAGS_LOCKED_MASK       1UL
+
+/**************************** Type Definitions *******************************/
+
+typedef u32 XBufDescriptor[XBD_SIZE_IN_WORDS];
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/**
+ * each of the following macros are named the same as functions rather than all
+ * upper case in order to allow either the macros or the functions to be
+ * used, see the source file xbuf_descriptor.c for documentation
+ */
+
+
+/*****************************************************************************/
+/**
+*
+* This function initializes a buffer descriptor component by zeroing all of the
+* fields of the buffer descriptor.  This function should be called prior to
+* using a buffer descriptor.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_Initialize(InstancePtr)                  \
+{                                                               \
+    (*((u32 *)InstancePtr + XBD_CONTROL_OFFSET) = 0);       \
+    (*((u32 *)InstancePtr + XBD_SOURCE_OFFSET) = 0);        \
+    (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET) = 0);   \
+    (*((u32 *)InstancePtr + XBD_LENGTH_OFFSET) = 0);        \
+    (*((u32 *)InstancePtr + XBD_STATUS_OFFSET) = 0);        \
+    (*((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET) = 0); \
+    (*((u32 *)InstancePtr + XBD_NEXT_PTR_OFFSET) = 0);      \
+    (*((u32 *)InstancePtr + XBD_ID_OFFSET) = 0);            \
+    (*((u32 *)InstancePtr + XBD_FLAGS_OFFSET) = 0);         \
+    (*((u32 *)InstancePtr + XBD_RQSTED_LENGTH_OFFSET) = 0); \
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the control field of a buffer descriptor component.  The
+* DMA channel hardware transfers the control field from the buffer descriptor
+* into the DMA control register when a buffer descriptor is processed.  It
+* controls the details of the DMA transfer.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The control field contents of the buffer descriptor. One or more of the
+* following values may be contained the field.  Each of the values are
+* unique bit masks.
+*                               <br><br>
+* - XDC_DMACR_SOURCE_INCR_MASK  Increment the source address
+*                               <br><br>
+* - XDC_DMACR_DEST_INCR_MASK    Increment the destination address
+*                               <br><br>
+* - XDC_DMACR_SOURCE_LOCAL_MASK Local source address
+*                               <br><br>
+* - XDC_DMACR_DEST_LOCAL_MASK   Local destination address
+*                               <br><br>
+* - XDC_DMACR_SG_ENABLE_MASK    Scatter gather enable
+*                               <br><br>
+* - XDC_DMACR_GEN_BD_INTR_MASK  Individual buffer descriptor interrupt
+*                               <br><br>
+* - XDC_DMACR_LAST_BD_MASK      Last buffer descriptor in a packet
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetControl(InstancePtr)   \
+    (u32)(*((u32 *)InstancePtr + XBD_CONTROL_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the control field of a buffer descriptor component.  The
+* DMA channel hardware transfers the control field from the buffer descriptor
+* into the DMA control register when a buffer descriptor is processed.  It
+* controls the details of the DMA transfer such as
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Control contains the value to be written to the control field of the buffer
+* descriptor. One or more of the following values may be contained the field.
+* Each of the values are unique bit masks such that they may be ORed together
+* to enable multiple bits or inverted and ANDed to disable multiple bits.
+* - XDC_DMACR_SOURCE_INCR_MASK  Increment the source address
+* - XDC_DMACR_DEST_INCR_MASK    Increment the destination address
+* - XDC_DMACR_SOURCE_LOCAL_MASK Local source address
+* - XDC_DMACR_DEST_LOCAL_MASK   Local destination address
+* - XDC_DMACR_SG_ENABLE_MASK    Scatter gather enable
+* - XDC_DMACR_GEN_BD_INTR_MASK  Individual buffer descriptor interrupt
+* - XDC_DMACR_LAST_BD_MASK      Last buffer descriptor in a packet
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetControl(InstancePtr, Control)  \
+    (*((u32 *)InstancePtr + XBD_CONTROL_OFFSET) = (u32)Control)
+
+/*****************************************************************************/
+/**
+*
+* This function determines if this buffer descriptor is marked as being the
+* last in the control field.  A packet may be broken up across multiple
+* buffer descriptors such that the last buffer descriptor is the end of the
+* packet.  The DMA channel hardware copies the control field from the buffer
+* descriptor to the control register of the DMA channel when the buffer
+* descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* TRUE if the buffer descriptor is marked as last in the control field,
+* otherwise, FALSE.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_IsLastControl(InstancePtr) \
+    (u32)((*((u32 *)InstancePtr + XBD_CONTROL_OFFSET) & \
+               XDC_CONTROL_LAST_BD_MASK) == XDC_CONTROL_LAST_BD_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function marks the buffer descriptor as being last in the control
+* field of the buffer descriptor.  A packet may be broken up across multiple
+* buffer descriptors such that the last buffer descriptor is the end of the
+* packet.  The DMA channel hardware copies the control field from the buffer
+* descriptor to the control register of the DMA channel when the buffer
+* descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetLast(InstancePtr) \
+    (*((u32 *)InstancePtr + XBD_CONTROL_OFFSET) |= XDC_CONTROL_LAST_BD_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the source address field of the buffer descriptor.
+* The source address indicates the address of memory which is the
+* source of a DMA scatter gather operation.  The DMA channel hardware
+* copies the source address from the buffer descriptor to the source
+* address register of the DMA channel when the buffer descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The source address field of the buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetSrcAddress(InstancePtr) \
+    ((u32 *)(*((u32 *)InstancePtr + XBD_SOURCE_OFFSET)))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the source address field of the buffer descriptor.
+* The source address indicates the address of memory which is the
+* source of a DMA scatter gather operation.  The DMA channel hardware
+* copies the source address from the buffer descriptor to the source
+* address register of the DMA channel when the buffer descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* SourceAddress contains the source address field for the buffer descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetSrcAddress(InstancePtr, Source) \
+    (*((u32 *)InstancePtr + XBD_SOURCE_OFFSET) = (u32)Source)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the destination address field of the buffer descriptor.
+* The destination address indicates the address of memory which is the
+* destination of a DMA scatter gather operation.  The DMA channel hardware
+* copies the destination address from the buffer descriptor to the destination
+* address register of the DMA channel when the buffer descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The destination address field of the buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetDestAddress(InstancePtr) \
+    ((u32 *)(*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET)))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the destination address field of the buffer descriptor.
+* The destination address indicates the address of memory which is the
+* destination of a DMA scatter gather operation.  The DMA channel hardware
+* copies the destination address from the buffer descriptor to the destination
+* address register of the DMA channel when the buffer descriptor is processed.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* DestinationAddress contains the destination address field for the buffer
+* descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetDestAddress(InstancePtr, Destination) \
+    (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET) = (u32)Destination)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the length of the data transfer if the buffer descriptor
+* has been processed by the DMA channel hardware.  If the buffer descriptor
+* has not been processed, the return value will be zero indicating that no data
+* has been transferred yet.  This function uses both the length and requested
+* length fields of the buffer descriptor to determine the number of bytes
+* transferred by the DMA operation. The length field of the buffer descriptor
+* contains the number of bytes remaining from the requested length.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The number of bytes which have been transferred by a DMA operation on the
+* buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetLength(InstancePtr)                           \
+    (u32)(*((u32 *)InstancePtr + XBD_RQSTED_LENGTH_OFFSET) -    \
+              *((u32 *)InstancePtr + XBD_LENGTH_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the length and the requested length fields of the buffer
+* descriptor.  The length field indicates the number of bytes to transfer for
+* the DMA operation and the requested length is written with the same value.
+* The requested length is not modified by the DMA hardware while the length
+* field is modified by the hardware to indicate the number of bytes remaining
+* in the transfer after the transfer is complete.  The requested length allows
+* the software to calculate the actual number of bytes transferred for the DMA
+* operation.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Length contains the length to put in the length and requested length fields
+* of the buffer descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetLength(InstancePtr, Length)                       \
+{                                                                           \
+    (*((u32 *)InstancePtr + XBD_LENGTH_OFFSET) = (u32)(Length));    \
+    (*((u32 *)InstancePtr + XBD_RQSTED_LENGTH_OFFSET) = (u32)(Length));\
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the status field of a buffer descriptor component. The
+* status field is written to the buffer descriptor by the DMA channel hardware
+* after processing of a buffer descriptor is complete.  The status field
+* indicates the status of the DMA operation.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The status field contents of the buffer descriptor. One or more of the
+* following values may be contained the field. Each of the values are
+* unique bit masks.
+*                               <br><br>
+* - XDC_DMASR_BUSY_MASK         The DMA channel is busy
+*                               <br><br>
+* - XDC_DMASR_BUS_ERROR_MASK    A bus error occurred
+*                               <br><br>
+* - XDC_DMASR_BUS_TIMEOUT_MASK  A bus timeout occurred
+*                               <br><br>
+* - XDC_DMASR_LAST_BD_MASK      The last buffer descriptor of a packet
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetStatus(InstancePtr)    \
+    (u32)(*((u32 *)InstancePtr + XBD_STATUS_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the status field of a buffer descriptor component.  The
+* status field is written to the buffer descriptor by the DMA channel hardware
+* after processing of a buffer descriptor is complete.  This function would
+* typically be used during debugging of buffer descriptor processing.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Status contains the status field for the buffer descriptor.
+* The status register contents of the DMA channel. One or more of the
+* following values may be contained the register. Each of the values are
+* unique bit masks.
+* - XDC_DMASR_BUSY_MASK         The DMA channel is busy
+* - XDC_DMASR_BUS_ERROR_MASK    A bus error occurred
+* - XDC_DMASR_BUS_TIMEOUT_MASK  A bus timeout occurred
+* - XDC_DMASR_LAST_BD_MASK      The last buffer descriptor of a packet
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetStatus(InstancePtr, Status)    \
+    (*((u32 *)InstancePtr + XBD_STATUS_OFFSET) = (u32)Status)
+
+/*****************************************************************************/
+/**
+*
+* This function determines if this buffer descriptor is marked as being the
+* last in the status field.  A packet may be broken up across multiple
+* buffer descriptors such that the last buffer descriptor is the end of the
+* packet.  The DMA channel hardware copies the status register contents to
+* the buffer descriptor of the DMA channel after processing of the buffer
+* descriptor is complete.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* TRUE if the buffer descriptor is marked as last in the status field,
+* otherwise, FALSE.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_IsLastStatus(InstancePtr) \
+    (u32)((*((u32 *)InstancePtr + XBD_STATUS_OFFSET) & \
+               XDC_STATUS_LAST_BD_MASK) == XDC_STATUS_LAST_BD_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the device status field of the buffer descriptor.  The
+* device status is device specific such that the definition of the contents
+* of this field are not defined in this function. The device is defined as the
+* device which is using the DMA channel, such as an ethernet controller.  The
+* DMA channel hardware copies the contents of the device status register into
+* the buffer descriptor when processing of the buffer descriptor is complete.
+* This value is typically used by the device driver for the device to determine
+* the status of the DMA operation with respect to the device.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The device status field of the buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetDeviceStatus(InstancePtr) \
+    ((u32)(*((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET)))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the device status field of the buffer descriptor.  The
+* device status is device specific such that the definition of the contents
+* of this field are not defined in this function. The device is defined as the
+* device which is using the DMA channel, such as an ethernet controller.  This
+* function is typically only used for debugging/testing.
+*
+* The DMA channel hardware copies the contents of the device status register
+* into the buffer descriptor when processing of the buffer descriptor is
+* complete.  This value is typically used by the device driver for the device
+* to determine the status of the DMA operation with respect to the device.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Status contains the device status field for the buffer descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetDeviceStatus(InstancePtr, Status) \
+{                                                                   \
+    u32 Register;                                               \
+    Register = (*((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET));     \
+    Register &= XDC_DMASR_RX_CS_RAW_MASK;                         \
+    (*((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET)) =               \
+              Register | ((u32) (Status));               \
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the next pointer field of the buffer descriptor.  This
+* field is used to link the buffer descriptors together such that multiple DMA
+* operations can be automated for scatter gather.  It also allows a single
+* packet to be broken across multiple buffer descriptors.  The DMA channel
+* hardware traverses the list of buffer descriptors using the next pointer
+* of each buffer descriptor.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The next pointer field of the buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetNextPtr(InstancePtr) \
+    (XBufDescriptor *)(*((u32 *)InstancePtr + XBD_NEXT_PTR_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the next pointer field of the buffer descriptor.  This
+* field is used to link the buffer descriptors together such that many DMA
+* operations can be automated for scatter gather.  It also allows a single
+* packet to be broken across multiple buffer descriptors.  The DMA channel
+* hardware traverses the list of buffer descriptors using the next pointer
+* of each buffer descriptor.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* NextPtr contains the next pointer field for the buffer descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetNextPtr(InstancePtr, NextPtr) \
+    (*((u32 *)InstancePtr + XBD_NEXT_PTR_OFFSET) = (u32)NextPtr)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the ID field of the buffer descriptor.  The ID field is
+* provided to allow a device driver to correlate the buffer descriptor to other
+* data structures which may be operating system specific, such as a pointer to
+* a higher level memory block. The ID field is not used by the DMA channel
+* hardware and is application specific.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The ID field of the buffer descriptor.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetId(InstancePtr) \
+    (u32)(*((u32 *)InstancePtr + XBD_ID_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the ID field of the buffer descriptor.  The ID field is
+* provided to allow a device driver to correlate the buffer descriptor to other
+* data structures which may be operating system specific, such as a pointer to
+* a higher level memory block. The ID field is not used by the DMA channel
+* hardware and is application specific.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Id contains the ID field for the buffer descriptor.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetId(InstancePtr, Id) \
+    (*((u32 *)InstancePtr + XBD_ID_OFFSET) = (u32)Id)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the flags field of the buffer descriptor.  The flags
+* field is not used by the DMA channel hardware and is used for software
+* processing of buffer descriptors.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* The flags field of the buffer descriptor.  The field may contain one or more
+* of the following values which are bit masks.
+*                               <br><br>
+* - XBD_FLAGS_LOCKED_MASK       Indicates the buffer descriptor is locked
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetFlags(InstancePtr) \
+    (u32)(*((u32 *)InstancePtr + XBD_FLAGS_OFFSET))
+
+/*****************************************************************************/
+/**
+*
+* This function sets the flags field of the buffer descriptor.  The flags
+* field is not used by the DMA channel hardware and is used for software
+* processing of buffer descriptors.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @param
+*
+* Flags contains the flags field for the buffer descriptor.  The field may
+* contain one or more of the following values which are bit masks.
+* - XBD_FLAGS_LOCKED_MASK       Indicates the buffer descriptor is locked
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetFlags(InstancePtr, Flags) \
+    (*((u32 *)InstancePtr + XBD_FLAGS_OFFSET) = (u32)Flags)
+
+/*****************************************************************************/
+/**
+*
+* This function locks the buffer descriptor. A lock is specific to the
+* scatter gather processing and prevents a buffer descriptor from being
+* overwritten in the scatter gather list.  This field is not used by the DMA
+* channel hardware such that the hardware could still write to the buffer
+* descriptor.  Locking a buffer descriptor is application specific and not
+* necessary to allow the DMA channel to use the buffer descriptor, but is
+* provided for flexibility in designing device drivers.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_Lock(InstancePtr) \
+    (*((u32 *)InstancePtr + XBD_FLAGS_OFFSET) |= XBD_FLAGS_LOCKED_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function unlocks the buffer descriptor.  A lock is specific to the
+* scatter gather processing and prevents a buffer descriptor from being
+* overwritten in the scatter gather list.  This field is not used by the DMA
+* channel hardware such that the hardware could still write to the buffer
+* descriptor.  Locking a buffer descriptor is application specific and not
+* necessary to allow the DMA channel to use the buffer descriptor, but is
+* provided for flex ability in designing device drivers.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_Unlock(InstancePtr) \
+    (*((u32 *)InstancePtr + XBD_FLAGS_OFFSET) &= ~XBD_FLAGS_LOCKED_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function determines if the buffer descriptor is locked.  The lock
+* is not used by the DMA channel hardware and is used for software processing
+* of buffer descriptors.
+*
+* @param
+*
+* InstancePtr points to the buffer descriptor to operate on.
+*
+* @return
+*
+* TRUE if the buffer descriptor is locked, otherwise FALSE.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_IsLocked(InstancePtr) \
+    (u32) ((*((u32 *)InstancePtr + XBD_FLAGS_OFFSET) & \
+        XBD_FLAGS_LOCKED_MASK) == XBD_FLAGS_LOCKED_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the Initial value for the CS offload function.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The initial value that will be used for checksum offload operation as DMA
+* moves the data.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetCSInit(InstancePtr)\
+(*((u32 *)InstancePtr + XBD_CONTROL_OFFSET) &= XDC_DMACR_TX_CS_INIT_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function Sets the Initial value for the CS offload function.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* None
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetCSInit(InstancePtr, InitialValue)            \
+{                                                                   \
+    u32 Register;                                               \
+    Register = (*((u32 *)InstancePtr + XBD_CONTROL_OFFSET));     \
+    Register &= ~XDC_DMACR_TX_CS_INIT_MASK;                         \
+    (*((u32 *)InstancePtr + XBD_CONTROL_OFFSET)) =               \
+              Register | ((u32) (InitialValue));               \
+}
+/*****************************************************************************/
+/**
+*
+* This function gets the byte position where the CS offload function
+* inserts the calculated checksum.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The insert byte location value that will be used to place the results of
+* the checksum offload.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetCSInsertLoc(InstancePtr)                     \
+(*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET) &= XDC_DAREG_CS_INSERT_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function sets the byte position where the CS offload function
+* inserts the calculated checksum.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* None
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetCSInsertLoc(InstancePtr, InsertLocation)            \
+{                                                                   \
+    u32 Register;                                               \
+    Register = (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET));      \
+    Register &= ~XDC_DAREG_CS_INSERT_MASK;                         \
+    (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET)) =                \
+              Register | ((u32) (InsertLocation));             \
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the byte position where the CS offload function
+* begins the calculation of the checksum.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The insert byte location value that will be used to place the results of
+* the checksum offload.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetCSBegin(InstancePtr)                      \
+(u16)((*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET)) >> 16)
+/*****************************************************************************/
+/**
+*
+* This function sets the byte position where the CS offload function
+* begins the calculation of the checksum.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* None
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_SetCSBegin(InstancePtr, BeginLocation)               \
+{                                                                           \
+    u32 Register;                                                       \
+    Register = (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET));             \
+    Register &= ~XDC_DAREG_CS_BEGIN_MASK;                                 \
+    (*((u32 *)InstancePtr + XBD_DESTINATION_OFFSET)) =                       \
+              Register | (((u32) (BeginLocation)) << 16);               \
+}
+/*****************************************************************************/
+/**
+*
+* This function gets the resulting checksum from the rx channel.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The raw checksum calculation from the receive operation. It needs to
+* be adjusted to remove the header and packet FCS to be correct.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XBufDescriptor_GetCSRaw(InstancePtr)                     \
+(u16)((*((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET)) >> 16)
+
+/************************** Function Prototypes ******************************/
+
+/* The following prototypes are provided to allow each of the functions to
+ * be implemented as a function rather than a macro, and to provide the
+ * syntax to allow users to understand how to call the macros, they are
+ * commented out to prevent linker errors
+ *
+
+u32 XBufDescriptor_Initialize(XBufDescriptor* InstancePtr);
+
+u32 XBufDescriptor_GetControl(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetControl(XBufDescriptor* InstancePtr, u32 Control);
+
+u32 XBufDescriptor_IsLastControl(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetLast(XBufDescriptor* InstancePtr);
+
+u32 XBufDescriptor_GetLength(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetLength(XBufDescriptor* InstancePtr, u32 Length);
+
+u32 XBufDescriptor_GetStatus(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetStatus(XBufDescriptor* InstancePtr, u32 Status);
+u32 XBufDescriptor_IsLastStatus(XBufDescriptor* InstancePtr);
+
+u32 XBufDescriptor_GetDeviceStatus(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetDeviceStatus(XBufDescriptor* InstancePtr,
+                                    u32 Status);
+
+u32 XBufDescriptor_GetSrcAddress(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetSrcAddress(XBufDescriptor* InstancePtr,
+                                  u32 SourceAddress);
+
+u32 XBufDescriptor_GetDestAddress(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetDestAddress(XBufDescriptor* InstancePtr,
+                                   u32 DestinationAddress);
+
+XBufDescriptor* XBufDescriptor_GetNextPtr(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetNextPtr(XBufDescriptor* InstancePtr,
+                               XBufDescriptor* NextPtr);
+
+u32 XBufDescriptor_GetId(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetId(XBufDescriptor* InstancePtr, u32 Id);
+
+u32 XBufDescriptor_GetFlags(XBufDescriptor* InstancePtr);
+void XBufDescriptor_SetFlags(XBufDescriptor* InstancePtr, u32 Flags);
+
+void XBufDescriptor_Lock(XBufDescriptor* InstancePtr);
+void XBufDescriptor_Unlock(XBufDescriptor* InstancePtr);
+u32 XBufDescriptor_IsLocked(XBufDescriptor* InstancePtr);
+
+u16 XBufDescriptor_GetCSInit(XBufDescriptor* InstancePtr)
+void XBufDescriptor_SetCSInit(XBufDescriptor* InstancePtr, u16 InitialValue)
+
+u16 XBufDescriptor_GetCSInsertLoc(XBufDescriptor* InstancePtr)
+void XBufDescriptor_SetCSInsertLoc(XBufDescriptor* InstancePtr, u16 InsertLocation)
+
+u16 XBufDescriptor_GetCSBegin(XBufDescriptor* InstancePtr)
+void XBufDescriptor_SetCSBegin(XBufDescriptor* InstancePtr, u16 BeginLocation)
+
+u16 XBufDescriptor_GetCSRaw(XBufDescriptor* InstancePtr)
+
+void XBufDescriptor_Copy(XBufDescriptor* InstancePtr,
+                         XBufDescriptor* DestinationPtr);
+
+*/
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdebug.h b/drivers/xilinx_common/xdebug.h
new file mode 100644
index 0000000..85de76a
--- /dev/null
+++ b/drivers/xilinx_common/xdebug.h
@@ -0,0 +1,48 @@
+#ifndef XDEBUG
+#define XDEBUG
+
+#undef DEBUG
+
+#if defined(DEBUG) && !defined(NDEBUG)
+
+#ifndef XDEBUG_WARNING
+#define XDEBUG_WARNING
+#warning DEBUG is enabled
+#endif
+
+int printf(const char *format, ...);
+
+#define XDBG_DEBUG_ERROR             0x00000001    /* error condition messages */
+#define XDBG_DEBUG_GENERAL           0x00000002    /* general debug  messages */
+#define XDBG_DEBUG_ALL               0xFFFFFFFF    /* all debugging data */
+
+#define XDBG_DEBUG_FIFO_REG          0x00000100    /* display register reads/writes */
+#define XDBG_DEBUG_FIFO_RX           0x00000101    /* receive debug messages */
+#define XDBG_DEBUG_FIFO_TX           0x00000102    /* transmit debug messages */
+#define XDBG_DEBUG_FIFO_ALL          0x0000010F    /* all fifo debug messages */
+
+#define XDBG_DEBUG_TEMAC_REG         0x00000400    /* display register reads/writes */
+#define XDBG_DEBUG_TEMAC_RX          0x00000401    /* receive debug messages */
+#define XDBG_DEBUG_TEMAC_TX          0x00000402    /* transmit debug messages */
+#define XDBG_DEBUG_TEMAC_ALL         0x0000040F    /* all temac  debug messages */
+
+#define XDBG_DEBUG_TEMAC_ADPT_RX     0x00000800    /* receive debug messages */
+#define XDBG_DEBUG_TEMAC_ADPT_TX     0x00000801    /* transmit debug messages */
+#define XDBG_DEBUG_TEMAC_ADPT_IOCTL  0x00000802    /* ioctl debug messages */
+#define XDBG_DEBUG_TEMAC_ADPT_MISC   0x00000803    /* debug msg for other routines */
+#define XDBG_DEBUG_TEMAC_ADPT_ALL    0x0000080F    /* all temac adapter debug messages */
+
+#define xdbg_current_types (XDBG_DEBUG_ERROR | XDBG_DEBUG_GENERAL | XDBG_DEBUG_FIFO_REG | XDBG_DEBUG_TEMAC_REG)
+
+#define xdbg_stmnt(x)  x
+#define xdbg_printf(type, ...) (if ((type) & xdbg_current_types) printf (__VA_ARGS__) : 0)
+
+#else
+#define xdbg_stmnt(x)
+#define xdbg_printf(...)
+#endif
+
+
+
+
+#endif /* XDEBUG */
diff --git a/drivers/xilinx_common/xdma_channel.c b/drivers/xilinx_common/xdma_channel.c
new file mode 100644
index 0000000..14d27fe
--- /dev/null
+++ b/drivers/xilinx_common/xdma_channel.c
@@ -0,0 +1,714 @@
+/* $Id: xdma_channel.c,v 1.1 2006/12/13 14:21:45 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2001-2004 Xilinx Inc.
+*       All rights reserved. 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of the GNU General Public License as published by the 
+* Free Software Foundation; either version 2 of the License, or (at your 
+* option) any later version. 
+*
+* You should have received a copy of the GNU General Public License 
+* along with this program; if not, write to the Free Software 
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdma_channel.c
+*
+* <b>Description</b>
+*
+* This file contains the DMA channel component. This component supports
+* a distributed DMA design in which each device can have it's own dedicated
+* DMA channel, as opposed to a centralized DMA design. This component
+* performs processing for DMA on all devices.
+*
+* See xdma_channel.h for more information about this component.
+*
+* @note
+*
+* None.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a xd  10/27/04  Doxygenated for inclusion in API documentation
+* 1.00b ecm 10/31/05  Updated for the check sum offload changes.
+* 1.00b xd  03/22/06  Fixed a multi-descriptor packet related bug that sgdma
+*                     engine is restarted in case no scatter gather disabled
+*                     bit is set yet
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xdma_channel.h"
+#include "xbasic_types.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/*****************************************************************************/
+/**
+*
+* This function initializes a DMA channel.  This function must be called
+* prior to using a DMA channel.  Initialization of a channel includes setting
+* up the registers base address, and resetting the channel such that it's in a
+* known state.  Interrupts for the channel are disabled when the channel is
+* reset.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @param
+*
+* BaseAddress contains the base address of the registers for the DMA channel.
+*
+* @return
+*
+* XST_SUCCESS indicating initialization was successful.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XDmaChannel_Initialize(XDmaChannel * InstancePtr, u32 BaseAddress)
+{
+	/* assert to verify input arguments, don't assert base address */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* setup the base address of the registers for the DMA channel such
+	 * that register accesses can be done
+	 */
+	InstancePtr->RegBaseAddress = BaseAddress;
+
+	/* initialize the scatter gather list such that it indicates it has not
+	 * been created yet and the DMA channel is ready to use (initialized)
+	 */
+	InstancePtr->GetPtr = NULL;
+	InstancePtr->PutPtr = NULL;
+	InstancePtr->CommitPtr = NULL;
+	InstancePtr->LastPtr = NULL;
+
+	InstancePtr->TotalDescriptorCount = 0;
+	InstancePtr->ActiveDescriptorCount = 0;
+
+	InstancePtr->ActivePacketCount = 0;
+	InstancePtr->Committed = FALSE;
+
+	InstancePtr->IsReady = XCOMPONENT_IS_READY;
+
+	/* initialize the version of the component
+	 */
+	XVersion_FromString(&InstancePtr->Version, "1.00a");
+
+	/* reset the DMA channel such that it's in a known state and ready
+	 * and indicate the initialization occurred with no errors, note that
+	 * the is ready variable must be set before this call or reset will assert
+	 */
+	XDmaChannel_Reset(InstancePtr);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function determines if a DMA channel component has been successfully
+* initialized such that it's ready to use.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* TRUE if the DMA channel component is ready, FALSE otherwise.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_IsReady(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments used by the base component */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	return InstancePtr->IsReady == XCOMPONENT_IS_READY;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the software version for the specified DMA channel
+* component.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* A pointer to the software version of the specified DMA channel.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+XVersion *XDmaChannel_GetVersion(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* return a pointer to the version of the DMA channel */
+
+	return &InstancePtr->Version;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function performs a self test on the specified DMA channel.  This self
+* test is destructive as the DMA channel is reset and a register default is
+* verified.
+*
+* @param
+*
+* InstancePtr is a pointer to the DMA channel to be operated on.
+*
+* @return
+*
+* XST_SUCCESS is returned if the self test is successful, or one of the
+* following errors.
+*                                       <br><br>
+* - XST_DMA_RESET_REGISTER_ERROR        Indicates the control register value
+*                                       after a reset was not correct
+*
+* @note
+*
+* This test does not performs a DMA transfer to test the channel because the
+* DMA hardware will not currently allow a non-local memory transfer to non-local
+* memory (memory copy), but only allows a non-local memory to or from the device
+* memory (typically a FIFO).
+*
+******************************************************************************/
+
+#define XDC_CONTROL_REG_RESET_MASK  0x98000000UL	/* control reg reset value */
+
+int XDmaChannel_SelfTest(XDmaChannel * InstancePtr)
+{
+	u32 ControlReg;
+
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* reset the DMA channel such that it's in a known state before the test
+	 * it resets to no interrupts enabled, the desired state for the test
+	 */
+	XDmaChannel_Reset(InstancePtr);
+
+	/* this should be the first test to help prevent a lock up with the polling
+	 * loop that occurs later in the test, check the reset value of the DMA
+	 * control register to make sure it's correct, return with an error if not
+	 */
+	ControlReg = XDmaChannel_GetControl(InstancePtr);
+	if (ControlReg != XDC_CONTROL_REG_RESET_MASK) {
+		return XST_DMA_RESET_REGISTER_ERROR;
+	}
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function resets the DMA channel. This is a destructive operation such
+* that it should not be done while a channel is being used.  If the DMA channel
+* is transferring data into other blocks, such as a FIFO, it may be necessary
+* to reset other blocks.  This function does not modify the contents of a
+* scatter gather list for a DMA channel such that the user is responsible for
+* getting buffer descriptors from the list if necessary.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_Reset(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* reset the DMA channel such that it's in a known state, the reset
+	 * register is self clearing such that it only has to be set
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_RST_REG_OFFSET,
+		  XDC_RESET_MASK);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the control register contents of the DMA channel.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The control register contents of the DMA channel. One or more of the
+* following values may be contained the register.  Each of the values are
+* unique bit masks.
+*                               <br><br>
+* - XDC_DMACR_SOURCE_INCR_MASK  Increment the source address
+*                               <br><br>
+* - XDC_DMACR_DEST_INCR_MASK    Increment the destination address
+*                               <br><br>
+* - XDC_DMACR_SOURCE_LOCAL_MASK Local source address
+*                               <br><br>
+* - XDC_DMACR_DEST_LOCAL_MASK   Local destination address
+*                               <br><br>
+* - XDC_DMACR_SG_ENABLE_MASK    Scatter gather enable
+*                               <br><br>
+* - XDC_DMACR_GEN_BD_INTR_MASK  Individual buffer descriptor interrupt
+*                               <br><br>
+* - XDC_DMACR_LAST_BD_MASK      Last buffer descriptor in a packet
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetControl(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* return the contents of the DMA control register */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_DMAC_REG_OFFSET);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the control register of the specified DMA channel.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @param
+*
+* Control contains the value to be written to the control register of the DMA
+* channel. One or more of the following values may be contained the register.
+* Each of the values are unique bit masks such that they may be ORed together
+* to enable multiple bits or inverted and ANDed to disable multiple bits.
+* - XDC_DMACR_SOURCE_INCR_MASK  Increment the source address
+* - XDC_DMACR_DEST_INCR_MASK    Increment the destination address
+* - XDC_DMACR_SOURCE_LOCAL_MASK Local source address
+* - XDC_DMACR_DEST_LOCAL_MASK   Local destination address
+* - XDC_DMACR_SG_ENABLE_MASK    Scatter gather enable
+* - XDC_DMACR_GEN_BD_INTR_MASK  Individual buffer descriptor interrupt
+* - XDC_DMACR_LAST_BD_MASK      Last buffer descriptor in a packet
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_SetControl(XDmaChannel * InstancePtr, u32 Control)
+{
+	u32 Register;
+
+	/* assert to verify input arguments except the control which can't be
+	 * asserted since all values are valid
+	 */
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/*
+	 * set the DMA control register to the specified value, not altering the
+	 * other fields in the register
+	 */
+
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_DMAC_REG_OFFSET);
+	Register &= XDC_DMACR_TX_CS_INIT_MASK;
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_DMAC_REG_OFFSET,
+		  Register | Control);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the status register contents of the DMA channel.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The status register contents of the DMA channel. One or more of the
+* following values may be contained the register. Each of the values are
+* unique bit masks.
+*                               <br><br>
+* - XDC_DMASR_BUSY_MASK         The DMA channel is busy
+*                               <br><br>
+* - XDC_DMASR_BUS_ERROR_MASK    A bus error occurred
+*                               <br><br>
+* - XDC_DMASR_BUS_TIMEOUT_MASK  A bus timeout occurred
+*                               <br><br>
+* - XDC_DMASR_LAST_BD_MASK      The last buffer descriptor of a packet
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetStatus(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* return the contents of the DMA status register */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_DMAS_REG_OFFSET);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the interrupt status register of the specified DMA channel.
+* Setting any bit of the interrupt status register will clear the bit to
+* indicate the interrupt processing has been completed. The definitions of each
+* bit in the register match the definition of the bits in the interrupt enable
+* register.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @param
+*
+* Status contains the value to be written to the status register of the DMA
+* channel.  One or more of the following values may be contained the register.
+* Each of the values are unique bit masks such that they may be ORed together
+* to enable multiple bits or inverted and ANDed to disable multiple bits.
+* - XDC_IXR_DMA_DONE_MASK       The dma operation is done
+* - XDC_IXR_DMA_ERROR_MASK      The dma operation had an error
+* - XDC_IXR_PKT_DONE_MASK       A packet is complete
+* - XDC_IXR_PKT_THRESHOLD_MASK  The packet count threshold reached
+* - XDC_IXR_PKT_WAIT_BOUND_MASK The packet wait bound reached
+* - XDC_IXR_SG_DISABLE_ACK_MASK The scatter gather disable completed
+* - XDC_IXR_BD_MASK             A buffer descriptor is done
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_SetIntrStatus(XDmaChannel * InstancePtr, u32 Status)
+{
+	/* assert to verify input arguments except the status which can't be
+	 * asserted since all values are valid
+	 */
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* set the interrupt status register with the specified value such that
+	 * all bits which are set in the register are cleared effectively clearing
+	 * any active interrupts
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_IS_REG_OFFSET, Status);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the interrupt status register of the specified DMA channel.
+* The interrupt status register indicates which interrupts are active
+* for the DMA channel.  If an interrupt is active, the status register must be
+* set (written) with the bit set for each interrupt which has been processed
+* in order to clear the interrupts.  The definitions of each bit in the register
+* match the definition of the bits in the interrupt enable register.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The interrupt status register contents of the specified DMA channel.
+* One or more of the following values may be contained the register.
+* Each of the values are unique bit masks.
+*                               <br><br>
+* - XDC_IXR_DMA_DONE_MASK       The dma operation is done
+*                               <br><br>
+* - XDC_IXR_DMA_ERROR_MASK      The dma operation had an error
+*                               <br><br>
+* - XDC_IXR_PKT_DONE_MASK       A packet is complete
+*                               <br><br>
+* - XDC_IXR_PKT_THRESHOLD_MASK  The packet count threshold reached
+*                               <br><br>
+* - XDC_IXR_PKT_WAIT_BOUND_MASK The packet wait bound reached
+*                               <br><br>
+* - XDC_IXR_SG_DISABLE_ACK_MASK The scatter gather disable completed
+*                               <br><br>
+* - XDC_IXR_SG_END_MASK         Current descriptor was the end of the list
+*                               <br><br>
+* - XDC_IXR_BD_MASK             A buffer descriptor is done
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetIntrStatus(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* return the contents of the interrupt status register */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_IS_REG_OFFSET);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function sets the interrupt enable register of the specified DMA
+* channel.  The interrupt enable register contains bits which enable
+* individual interrupts for the DMA channel.  The definitions of each bit
+* in the register match the definition of the bits in the interrupt status
+* register.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @param
+*
+* Enable contains the interrupt enable register contents to be written
+* in the DMA channel. One or more of the following values may be contained
+* the register. Each of the values are unique bit masks such that they may be
+* ORed together to enable multiple bits or inverted and ANDed to disable
+* multiple bits.
+* - XDC_IXR_DMA_DONE_MASK       The dma operation is done
+* - XDC_IXR_DMA_ERROR_MASK      The dma operation had an error
+* - XDC_IXR_PKT_DONE_MASK       A packet is complete
+* - XDC_IXR_PKT_THRESHOLD_MASK  The packet count threshold reached
+* - XDC_IXR_PKT_WAIT_BOUND_MASK The packet wait bound reached
+* - XDC_IXR_SG_DISABLE_ACK_MASK The scatter gather disable completed
+* - XDC_IXR_SG_END_MASK         Current descriptor was the end of the list
+* - XDC_IXR_BD_MASK             A buffer descriptor is done
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_SetIntrEnable(XDmaChannel * InstancePtr, u32 Enable)
+{
+	/* assert to verify input arguments except the enable which can't be
+	 * asserted since all values are valid
+	 */
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* set the interrupt enable register to the specified value */
+
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_IE_REG_OFFSET, Enable);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function gets the interrupt enable of the DMA channel.  The
+* interrupt enable contains flags which enable individual interrupts for the
+* DMA channel. The definitions of each bit in the register match the definition
+* of the bits in the interrupt status register.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @return
+*
+* The interrupt enable of the DMA channel.  One or more of the following values
+* may be contained the register. Each of the values are unique bit masks.
+*                               <br><br>
+* - XDC_IXR_DMA_DONE_MASK       The dma operation is done
+*                               <br><br>
+* - XDC_IXR_DMA_ERROR_MASK      The dma operation had an error
+*                               <br><br>
+* - XDC_IXR_PKT_DONE_MASK       A packet is complete
+*                               <br><br>
+* - XDC_IXR_PKT_THRESHOLD_MASK  The packet count threshold reached
+*                               <br><br>
+* - XDC_IXR_PKT_WAIT_BOUND_MASK The packet wait bound reached
+*                               <br><br>
+* - XDC_IXR_SG_DISABLE_ACK_MASK The scatter gather disable completed
+*                               <br><br>
+* - XDC_IXR_BD_MASK             A buffer descriptor is done
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetIntrEnable(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* return the contents of the interrupt enable register */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_IE_REG_OFFSET);
+}
+
+/*****************************************************************************/
+/**
+*
+* This function starts the DMA channel transferring data from a memory source
+* to a memory destination. This function only starts the operation and returns
+* before the operation may be complete.  If the interrupt is enabled, an
+* interrupt will be generated when the operation is complete, otherwise it is
+* necessary to poll the channel status to determine when it's complete.  It is
+* the responsibility of the caller to determine when the operation is complete
+* by handling the generated interrupt or polling the status.  It is also the
+* responsibility of the caller to ensure that the DMA channel is not busy with
+* another transfer before calling this function.
+*
+* @param
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.
+*
+* @param
+*
+* SourcePtr contains a pointer to the source memory where the data is to
+* be transferred from and must be 32 bit aligned.
+*
+* @param
+*
+* DestinationPtr contains a pointer to the destination memory where the data
+* is to be transferred and must be 32 bit aligned.
+*
+* @param
+*
+* ByteCount contains the number of bytes to transfer during the DMA operation.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* The DMA hw will not currently allow a non-local memory transfer to non-local
+* memory (memory copy), but only allows a non-local memory to or from the device
+* memory (typically a FIFO).
+* <br><br>
+* It is the responsibility of the caller to ensure that the cache is
+* flushed and invalidated both before and after the DMA operation completes
+* if the memory pointed to is cached. The caller must also ensure that the
+* pointers contain a physical address rather than a virtual address
+* if address translation is being used.
+*
+******************************************************************************/
+void XDmaChannel_Transfer(XDmaChannel * InstancePtr,
+			  u32 *SourcePtr, u32 *DestinationPtr, u32 ByteCount)
+{
+	/* assert to verify input arguments and the alignment of any arguments
+	 * which have expected alignments
+	 */
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(SourcePtr != NULL);
+	XASSERT_VOID(((u32) SourcePtr & 3) == 0);
+	XASSERT_VOID(DestinationPtr != NULL);
+	XASSERT_VOID(((u32) DestinationPtr & 3) == 0);
+	XASSERT_VOID(ByteCount != 0);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* setup the source and destination address registers for the transfer */
+
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_SA_REG_OFFSET,
+		  (u32) SourcePtr);
+
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_DA_REG_OFFSET,
+		  (u32) DestinationPtr);
+
+	/* start the DMA transfer to copy from the source buffer to the
+	 * destination buffer by writing the length to the length register
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_LEN_REG_OFFSET, ByteCount);
+}
diff --git a/drivers/xilinx_common/xdma_channel.h b/drivers/xilinx_common/xdma_channel.h
new file mode 100644
index 0000000..f98cdf9
--- /dev/null
+++ b/drivers/xilinx_common/xdma_channel.h
@@ -0,0 +1,314 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2002-2004 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+* FILENAME:
+*
+* xdma_channel.h
+*
+* DESCRIPTION:
+*
+* This file contains the DMA channel component implementation. This component
+* supports a distributed DMA design in which each device can have it's own
+* dedicated DMA channel, as opposed to a centralized DMA design.
+* A device which uses DMA typically contains two DMA channels, one for
+* sending data and the other for receiving data.
+*
+* This component is designed to be used as a basic building block for
+* designing a device driver. It provides registers accesses such that all
+* DMA processing can be maintained easier, but the device driver designer
+* must still understand all the details of the DMA channel.
+*
+* The DMA channel allows a CPU to minimize the CPU interaction required to move
+* data between a memory and a device.  The CPU requests the DMA channel to
+* perform a DMA operation and typically continues performing other processing
+* until the DMA operation completes.  DMA could be considered a primitive form
+* of multiprocessing such that caching and address translation can be an issue.
+*
+* Scatter Gather Operations
+*
+* The DMA channel may support scatter gather operations. A scatter gather
+* operation automates the DMA channel such that multiple buffers can be
+* sent or received with minimal software interaction with the hardware.  Buffer
+* descriptors, contained in the XBufDescriptor component, are used by the
+* scatter gather operations of the DMA channel to describe the buffers to be
+* processed.
+*
+* Scatter Gather List Operations
+*
+* A scatter gather list may be supported by each DMA channel.  The scatter
+* gather list allows buffer descriptors to be put into the list by a device
+* driver which requires scatter gather.  The hardware processes the buffer
+* descriptors which are contained in the list and modifies the buffer
+* descriptors to reflect the status of the DMA operations.  The device driver
+* is notified by interrupt that specific DMA events occur including scatter
+* gather events.  The device driver removes the completed buffer descriptors
+* from the scatter gather list to evaluate the status of each DMA operation.
+*
+* The scatter gather list is created and buffer descriptors are inserted into
+* the list.  Buffer descriptors are never removed from the list after it's
+* creation such that a put operation copies from a temporary buffer descriptor
+* to a buffer descriptor in the list.  Get operations don't copy from the list
+* to a temporary, but return a pointer to the buffer descriptor in the list.
+* A buffer descriptor in the list may be locked to prevent it from being
+* overwritten by a put operation.  This allows the device driver to get a
+* descriptor from a scatter gather list and prevent it from being overwritten
+* until the buffer associated with the buffer descriptor has been processed.
+*
+* Typical Scatter Gather Processing
+*
+* The following steps illustrate the typical processing to use the
+* scatter gather features of a DMA channel.
+*
+* 1. Create a scatter gather list for the DMA channel which puts empty buffer
+*    descriptors into the list.
+* 2. Create buffer descriptors which describe the buffers to be filled with
+*    receive data or the buffers which contain data to be sent.
+* 3. Put buffer descriptors into the DMA channel scatter list such that scatter
+*    gather operations are requested.
+* 4. Commit the buffer descriptors in the list such that they are ready to be
+*    used by the DMA channel hardware.
+* 5. Start the scatter gather operations of the DMA channel.
+* 6. Process any interrupts which occur as a result of the scatter gather
+*    operations or poll the DMA channel to determine the status.
+*
+* Interrupts
+*
+* Each DMA channel has the ability to generate an interrupt.  This component
+* does not perform processing for the interrupt as this processing is typically
+* tightly coupled with the device which is using the DMA channel.  It is the
+* responsibility of the caller of DMA functions to manage the interrupt
+* including connecting to the interrupt and enabling/disabling the interrupt.
+*
+* Critical Sections
+*
+* It is the responsibility of the device driver designer to use critical
+* sections as necessary when calling functions of the DMA channel.  This
+* component does not use critical sections and it does access registers using
+* read-modify-write operations.  Calls to DMA functions from a main thread
+* and from an interrupt context could produce unpredictable behavior such that
+* the caller must provide the appropriate critical sections.
+*
+* Address Translation
+*
+* All addresses of data structures which are passed to DMA functions must
+* be physical (real) addresses as opposed to logical (virtual) addresses.
+*
+* Caching
+*
+* The memory which is passed to the function which creates the scatter gather
+* list must not be cached such that buffer descriptors are non-cached.  This
+* is necessary because the buffer descriptors are kept in a ring buffer and
+* not directly accessible to the caller of DMA functions.
+*
+* The caller of DMA functions is responsible for ensuring that any data
+* buffers which are passed to the DMA channel are cache-line aligned if
+* necessary.
+*
+* The caller of DMA functions is responsible for ensuring that any data
+* buffers which are passed to the DMA channel have been flushed from the cache.
+*
+* The caller of DMA functions is responsible for ensuring that the cache is
+* invalidated prior to using any data buffers which are the result of a DMA
+* operation.
+*
+* Memory Alignment
+*
+* The addresses of data buffers which are passed to DMA functions must be
+* 32 bit word aligned since the DMA hardware performs 32 bit word transfers.
+*
+* Mutual Exclusion
+*
+* The functions of the DMA channel are not thread safe such that the caller
+* of all DMA functions is responsible for ensuring mutual exclusion for a
+* DMA channel.  Mutual exclusion across multiple DMA channels is not
+* necessary.
+*
+* NOTES:
+*
+* Many of the provided functions which are register accessors don't provide
+* a lot of error detection. The caller is expected to understand the impact
+* of a function call based upon the current state of the DMA channel.  This
+* is done to minimize the overhead in this component.
+*
+******************************************************************************/
+
+#ifndef XDMA_CHANNEL_H		/* prevent circular inclusions */
+#define XDMA_CHANNEL_H		/* by using protection macros */
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xversion.h"
+#include "xbuf_descriptor.h"
+#include "xdma_channel_i.h"	/* constants shared with buffer descriptor */
+
+/************************** Constant Definitions *****************************/
+
+/* the following constants provide access to the bit fields of the DMA control
+ * register (DMACR)
+ */
+#define XDC_DMACR_SOURCE_INCR_MASK  0x80000000UL	/* increment source address */
+#define XDC_DMACR_DEST_INCR_MASK    0x40000000UL	/* increment dest address */
+#define XDC_DMACR_SOURCE_LOCAL_MASK 0x20000000UL	/* local source address */
+#define XDC_DMACR_DEST_LOCAL_MASK   0x10000000UL	/* local dest address */
+#define XDC_DMACR_SG_DISABLE_MASK   0x08000000UL	/* scatter gather disable */
+#define XDC_DMACR_GEN_BD_INTR_MASK  0x04000000UL	/* descriptor interrupt */
+#define XDC_DMACR_LAST_BD_MASK      XDC_CONTROL_LAST_BD_MASK	/* last buffer */
+				    /*     descriptor  */
+#define XDC_DMACR_DRE_MODE_MASK     0x01000000UL	/* DRE/normal mode */
+
+#define XDC_DMACR_TX_CS_INIT_MASK    0x0000FFFFUL	/* Initial value for TX
+							   CS offload */
+#define XDC_DMACR_CS_OFFLOAD_MASK    0x00800000UL	/* Enable CS offload */
+
+/* the following constants provide access to the bit fields of the DMA status
+ * register (DMASR)
+ */
+#define XDC_DMASR_BUSY_MASK         0x80000000UL	/* channel is busy */
+#define XDC_DMASR_BUS_ERROR_MASK    0x40000000UL	/* bus error occurred */
+#define XDC_DMASR_BUS_TIMEOUT_MASK  0x20000000UL	/* bus timeout occurred */
+#define XDC_DMASR_LAST_BD_MASK      XDC_STATUS_LAST_BD_MASK	/* last buffer */
+				/* descriptor  */
+#define XDC_DMASR_SG_BUSY_MASK      0x08000000UL	/* scatter gather is busy */
+/* @} */
+
+/** @name DMA destination address register bit fields when checksum offload is
+ * used
+ *
+ * the following constants provide access to the bit fields of the
+ * Destination Address Register (DAREG)
+ * @{
+ */
+#define XDC_DAREG_CS_BEGIN_MASK      0xFFFF0000UL	/* byte position to begin
+							   checksum calculation */
+#define XDC_DAREG_CS_INSERT_MASK     0x0000FFFFUL	/* byte position to place
+							   calculated checksum */
+/* the following constants provide access to the bit fields of the interrupt
+ * status register (ISR) and the interrupt enable register (IER), bit masks
+ * match for both registers such that they are named IXR
+ */
+#define XDC_IXR_DMA_DONE_MASK       0x1UL	/* dma operation done */
+#define XDC_IXR_DMA_ERROR_MASK      0x2UL	/* dma operation error */
+#define XDC_IXR_PKT_DONE_MASK       0x4UL	/* packet done */
+#define XDC_IXR_PKT_THRESHOLD_MASK  0x8UL	/* packet count threshold */
+#define XDC_IXR_PKT_WAIT_BOUND_MASK 0x10UL	/* packet wait bound reached */
+#define XDC_IXR_SG_DISABLE_ACK_MASK 0x20UL	/* scatter gather disable
+						   acknowledge occurred */
+#define XDC_IXR_SG_END_MASK         0x40UL	/* last buffer descriptor
+						   disabled scatter gather */
+#define XDC_IXR_BD_MASK             0x80UL	/* buffer descriptor done */
+
+/**************************** Type Definitions *******************************/
+
+/*
+ * the following structure contains data which is on a per instance basis
+ * for the XDmaChannel component
+ */
+typedef struct XDmaChannelTag {
+	XVersion Version;	/* version of the driver */
+	u32 RegBaseAddress;	/* base address of registers */
+	u32 IsReady;		/* device is initialized and ready */
+
+	XBufDescriptor *PutPtr;	/* keep track of where to put into list */
+	XBufDescriptor *GetPtr;	/* keep track of where to get from list */
+	XBufDescriptor *CommitPtr;	/* keep track of where to commit in list */
+	XBufDescriptor *LastPtr;	/* keep track of the last put in the list */
+	void *VirtPtr;		/* virtual base of memory */
+	void *PhyPtr;		/* physical base of memory */
+	u32 TotalDescriptorCount;	/* total # of descriptors in the list */
+	u32 ActiveDescriptorCount;	/* # of descriptors pointing to buffers
+					 * in the buffer descriptor list */
+	u32 ActivePacketCount;	/* # of packets that have been put into
+				   the list and transmission confirmation
+				   have not been received by the driver */
+	u32 Committed;		/* CommitPuts is called? */
+} XDmaChannel;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+int XDmaChannel_Initialize(XDmaChannel * InstancePtr, u32 BaseAddress);
+u32 XDmaChannel_IsReady(XDmaChannel * InstancePtr);
+XVersion *XDmaChannel_GetVersion(XDmaChannel * InstancePtr);
+int XDmaChannel_SelfTest(XDmaChannel * InstancePtr);
+void XDmaChannel_Reset(XDmaChannel * InstancePtr);
+
+/* Control functions */
+
+u32 XDmaChannel_GetControl(XDmaChannel * InstancePtr);
+void XDmaChannel_SetControl(XDmaChannel * InstancePtr, u32 Control);
+
+/* Status functions */
+
+u32 XDmaChannel_GetStatus(XDmaChannel * InstancePtr);
+void XDmaChannel_SetIntrStatus(XDmaChannel * InstancePtr, u32 Status);
+u32 XDmaChannel_GetIntrStatus(XDmaChannel * InstancePtr);
+void XDmaChannel_SetIntrEnable(XDmaChannel * InstancePtr, u32 Enable);
+u32 XDmaChannel_GetIntrEnable(XDmaChannel * InstancePtr);
+
+/* DMA without scatter gather functions */
+
+void XDmaChannel_Transfer(XDmaChannel * InstancePtr,
+			  u32 *SourcePtr, u32 *DestinationPtr, u32 ByteCount);
+
+/* Scatter gather functions */
+
+int XDmaChannel_SgStart(XDmaChannel * InstancePtr);
+int XDmaChannel_SgStop(XDmaChannel * InstancePtr,
+		       XBufDescriptor ** BufDescriptorPtr);
+int XDmaChannel_CreateSgList(XDmaChannel * InstancePtr,
+			     u32 *MemoryPtr, u32 ByteCount, void *PhyPtr);
+u32 XDmaChannel_IsSgListEmpty(XDmaChannel * InstancePtr);
+
+int XDmaChannel_PutDescriptor(XDmaChannel * InstancePtr,
+			      XBufDescriptor * BufDescriptorPtr);
+int XDmaChannel_CommitPuts(XDmaChannel * InstancePtr);
+int XDmaChannel_GetDescriptor(XDmaChannel * InstancePtr,
+			      XBufDescriptor ** BufDescriptorPtr);
+
+/* Packet functions for interrupt collescing */
+
+u32 XDmaChannel_GetPktCount(XDmaChannel * InstancePtr);
+void XDmaChannel_DecrementPktCount(XDmaChannel * InstancePtr);
+int XDmaChannel_SetPktThreshold(XDmaChannel * InstancePtr, u8 Threshold);
+u8 XDmaChannel_GetPktThreshold(XDmaChannel * InstancePtr);
+void XDmaChannel_SetPktWaitBound(XDmaChannel * InstancePtr, u32 WaitBound);
+u32 XDmaChannel_GetPktWaitBound(XDmaChannel * InstancePtr);
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdma_channel_i.h b/drivers/xilinx_common/xdma_channel_i.h
new file mode 100644
index 0000000..9d4b90e
--- /dev/null
+++ b/drivers/xilinx_common/xdma_channel_i.h
@@ -0,0 +1,131 @@
+/* $Id: xdma_channel_i.h,v 1.1 2006/12/13 14:22:04 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2001-2004 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdma_channel_i.h
+*
+* <b>Description</b>
+*
+* This file contains data which is shared internal data for the DMA channel
+* component. It is also shared with the buffer descriptor component which is
+* very tightly coupled with the DMA channel component.
+*
+* @note
+*
+* The last buffer descriptor constants must be located here to prevent a
+* circular dependency between the DMA channel component and the buffer
+* descriptor component.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a xd   10/27/04 Doxygenated for inclusion in API documentation
+* 1.00b ecm  10/31/05 Updated for the check sum offload changes.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XDMA_CHANNEL_I_H	/* prevent circular inclusions */
+#define XDMA_CHANNEL_I_H	/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xversion.h"
+
+/************************** Constant Definitions *****************************/
+
+#define XDC_DMA_CHANNEL_V1_00_B     "1.00b"
+
+/** @name DMA control register bit fields
+ *
+ * the following constant provides access to the bit fields of the DMA control
+ * register (DMACR) which must be shared between the DMA channel component
+ * and the buffer descriptor component
+ * @{
+ */
+#define XDC_CONTROL_LAST_BD_MASK    0x02000000UL /**< last buffer descriptor */
+/* @} */
+
+/** @name DMA status register bit fields
+ *
+ * the following constant provides access to the bit fields of the DMA status
+ * register (DMASR) which must be shared between the DMA channel component
+ * and the buffer descriptor component
+ * @{
+ */
+#define XDC_STATUS_LAST_BD_MASK     0x10000000UL /**< last buffer descriptor */
+
+#define XDC_DMASR_RX_CS_RAW_MASK    0xFFFF0000UL /**< RAW CS value for RX data */
+/* @} */
+
+/** @name DMA Channel register offsets
+ *
+ * the following constants provide access to each of the registers of a DMA
+ * channel
+ * @{
+ */
+#define XDC_RST_REG_OFFSET  0	/**< reset register */
+#define XDC_MI_REG_OFFSET   0	/**< module information register */
+#define XDC_DMAC_REG_OFFSET 4	/**< DMA control register */
+#define XDC_SA_REG_OFFSET   8	/**< source address register */
+#define XDC_DA_REG_OFFSET   12	/**< destination address register */
+#define XDC_LEN_REG_OFFSET  16	/**< length register */
+#define XDC_DMAS_REG_OFFSET 20	/**< DMA status register */
+#define XDC_BDA_REG_OFFSET  24	/**< buffer descriptor address register */
+#define XDC_SWCR_REG_OFFSET 28	/**< software control register */
+#define XDC_UPC_REG_OFFSET  32	/**< unserviced packet count register */
+#define XDC_PCT_REG_OFFSET  36	/**< packet count threshold register */
+#define XDC_PWB_REG_OFFSET  40	/**< packet wait bound register */
+#define XDC_IS_REG_OFFSET   44	/**< interrupt status register */
+#define XDC_IE_REG_OFFSET   48	/**< interrupt enable register */
+/* @} */
+
+/**
+ * the following constant is written to the reset register to reset the
+ * DMA channel
+ */
+#define XDC_RESET_MASK              0x0000000AUL
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdma_channel_sg.c b/drivers/xilinx_common/xdma_channel_sg.c
new file mode 100644
index 0000000..fc5dd8e
--- /dev/null
+++ b/drivers/xilinx_common/xdma_channel_sg.c
@@ -0,0 +1,1327 @@
+/******************************************************************************
+*
+*     Author: Xilinx, Inc.
+*
+*
+*     This program is free software; you can redistribute it and/or modify it
+*     under the terms of the GNU General Public License as published by the
+*     Free Software Foundation; either version 2 of the License, or (at your
+*     option) any later version.
+*
+*
+*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
+*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
+*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
+*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
+*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
+*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
+*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
+*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
+*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
+*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
+*     FITNESS FOR A PARTICULAR PURPOSE.
+*
+*
+*     Xilinx hardware products are not intended for use in life support
+*     appliances, devices, or systems. Use in such applications is
+*     expressly prohibited.
+*
+*
+*     (c) Copyright 2002-2004 Xilinx Inc.
+*     All rights reserved.
+*
+*
+*     You should have received a copy of the GNU General Public License along
+*     with this program; if not, write to the Free Software Foundation, Inc.,
+*     675 Mass Ave, Cambridge, MA 02139, USA.
+*
+* FILENAME:
+*
+* xdma_channel_sg.c
+*
+* DESCRIPTION:
+*
+* This file contains the implementation of the XDmaChannel component which is
+* related to scatter gather operations.
+*
+* Scatter Gather Operations
+*
+* The DMA channel may support scatter gather operations. A scatter gather
+* operation automates the DMA channel such that multiple buffers can be
+* sent or received with minimal software interaction with the hardware.  Buffer
+* descriptors, contained in the XBufDescriptor component, are used by the
+* scatter gather operations of the DMA channel to describe the buffers to be
+* processed.
+*
+* Scatter Gather List Operations
+*
+* A scatter gather list may be supported by each DMA channel.  The scatter
+* gather list allows buffer descriptors to be put into the list by a device
+* driver which requires scatter gather.  The hardware processes the buffer
+* descriptors which are contained in the list and modifies the buffer
+* descriptors to reflect the status of the DMA operations.  The device driver
+* is notified by interrupt that specific DMA events occur including scatter
+* gather events.  The device driver removes the completed buffer descriptors
+* from the scatter gather list to evaluate the status of each DMA operation.
+*
+* The scatter gather list is created and buffer descriptors are inserted into
+* the list.  Buffer descriptors are never removed from the list after it's
+* creation such that a put operation copies from a temporary buffer descriptor
+* to a buffer descriptor in the list.  Get operations don't copy from the list
+* to a temporary, but return a pointer to the buffer descriptor in the list.
+* A buffer descriptor in the list may be locked to prevent it from being
+* overwritten by a put operation.  This allows the device driver to get a
+* descriptor from a scatter gather list and prevent it from being overwritten
+* until the buffer associated with the buffer descriptor has been processed.
+*
+* The get and put functions only operate on the list and are asynchronous from
+* the hardware which may be using the list of descriptors.  This is important
+* because there are no checks in the get and put functions to ensure that the
+* hardware has processed the descriptors.  This must be handled by the driver
+* using the DMA scatter gather channel through the use of the other functions.
+* When a scatter gather operation is started, the start function does ensure
+* that the descriptor to start has not already been processed by the hardware
+* and is not the first of a series of descriptors that have not been committed
+* yet.
+*
+* Descriptors are put into the list but not marked as ready to use by the
+* hardware until a commit operation is done.  This allows multiple descriptors
+* which may contain a single packet of information for a protocol to be
+* guaranteed not to cause any underflow conditions during transmission. The
+* hardware design only allows descriptors to cause it to stop after a descriptor
+* has been processed rather than before it is processed.  A series of
+* descriptors are put into the list followed by a commit operation, or each
+* descriptor may be commited.  A commit operation is performed by changing a
+* single descriptor, the first of the series of puts, to indicate that the
+* hardware may now use all descriptors after it.  The last descriptor in the
+* list is always set to cause the hardware to stop after it is processed.
+*
+* Typical Scatter Gather Processing
+*
+* The following steps illustrate the typical processing to use the
+* scatter gather features of a DMA channel.
+*
+* 1. Create a scatter gather list for the DMA channel which puts empty buffer
+*    descriptors into the list.
+* 2. Create buffer descriptors which describe the buffers to be filled with
+*    receive data or the buffers which contain data to be sent.
+* 3. Put buffer descriptors into the DMA channel scatter list such that scatter
+*    gather operations are requested.
+* 4. Commit the buffer descriptors in the list such that they are ready to be
+*    used by the DMA channel hardware.
+* 5. Start the scatter gather operations of the DMA channel.
+* 6. Process any interrupts which occur as a result of the scatter gather
+*    operations or poll the DMA channel to determine the status.  This may
+*    be accomplished by getting the packet count for the channel and then
+*    getting the appropriate number of descriptors from the list for that
+*    number of packets.
+*
+* Minimizing Interrupts
+*
+* The Scatter Gather operating mode is designed to reduce the amount of CPU
+* throughput necessary to manage the hardware for devices. A key to the CPU
+* throughput is the number and rate of interrupts that the CPU must service.
+* Devices with higher data rates can cause larger numbers of interrupts and
+* higher frequency interrupts. Ideally the number of interrupts can be reduced
+* by only generating an interrupt when a specific amount of data has been
+* received from the interface. This design suffers from a lack of interrupts
+* when the amount of data received is less than the specified amount of data
+* to generate an interrupt. In order to help minimize the number of interrupts
+* which the CPU must service, an algorithm referred to as "interrupt coalescing"
+* is utilized.
+*
+* Interrupt Coalescing
+*
+* The principle of interrupt coalescing is to wait before generating an
+* interrupt until a certain number of packets have been received or sent. An
+* interrupt is also generated if a smaller number of packets have been received
+* followed by a certain period of time with no packet reception. This is a
+* trade-off of latency for bandwidth and is accomplished using several
+* mechanisms of the hardware including a counter for packets received or
+* transmitted and a packet timer. These two hardware mechanisms work in
+* combination to allow a reduction in the number of interrupts processed by the
+* CPU for packet reception.
+*
+* Unserviced Packet Count
+*
+* The purpose of the packet counter is to count the number of packets received
+* or transmitted and provide an interrupt when a specific number of packets
+* have been processed by the hardware. An interrupt is generated whenever the
+* counter is greater than or equal to the Packet Count Threshold. This counter
+* contains an accurate count of the number of packets that the hardware has
+* processed, either received or transmitted, and the software has not serviced.
+*
+* The packet counter allows the number of interrupts to be reduced by waiting
+* to generate an interrupt until enough packets are received. For packet
+* reception, packet counts of less than the number to generate an interrupt
+* would not be serviced without the addition of a packet timer. This counter is
+* continuously updated by the hardware, not latched to the value at the time
+* the interrupt occurred.
+*
+* The packet counter can be used within the interrupt service routine for the
+* device to reduce the number of interrupts. The interrupt service routine
+* loops while performing processing for each packet which has been received or
+* transmitted and decrements the counter by a specified value. At the same time,
+* the hardware is possibly continuing to receive or transmit more packets such
+* that the software may choose, based upon the value in the packet counter, to
+* remain in the interrupt service routine rather than exiting and immediately
+* returning. This feature should be used with caution as reducing the number of
+* interrupts is beneficial, but unbounded interrupt processing is not desirable.
+*
+* Since the hardware may be incrementing the packet counter simultaneously
+* with the software decrementing the counter, there is a need for atomic
+* operations. The hardware ensures that the operation is atomic such that
+* simultaneous accesses are properly handled.
+*
+* Packet Wait Bound
+*
+* The purpose of the packet wait bound is to augment the unserviced packet
+* count. Whenever there is no pending interrupt for the channel and the
+* unserviced packet count is non-zero, a timer starts counting timeout at the
+* value contained the the packet wait bound register.  If the timeout is
+* reached, an interrupt is generated such that the software may service the
+* data which was buffered.
+*
+* NOTES:
+*
+* Special Test Conditions:
+*
+* The scatter gather list processing must be thoroughly tested if changes are
+* made.  Testing should include putting and committing single descriptors and
+* putting multiple descriptors followed by a single commit.  There are some
+* conditions in the code which handle the exception conditions.
+*
+* The Put Pointer points to the next location in the descriptor list to copy
+* in a new descriptor. The Get Pointer points to the next location in the
+* list to get a descriptor from.  The Get Pointer only allows software to
+* have a traverse the list after the hardware has finished processing some
+* number of descriptors.  The Commit Pointer points to the descriptor in the
+* list which is to be committed.  It is also used to determine that no
+* descriptor is waiting to be commited (NULL).  The Last Pointer points to
+* the last descriptor that was put into the list.  It typically points
+* to the previous descriptor to the one pointed to by the Put Pointer.
+* Comparisons are done between these pointers to determine when the following
+* special conditions exist.
+
+* Single Put And Commit
+*
+* The buffer descriptor is ready to be used by the hardware so it is important
+* for the descriptor to not appear to be waiting to be committed.  The commit
+* pointer is reset when a commit is done indicating there are no descriptors
+* waiting to be committed.  In all cases but this one, the descriptor is
+* changed to cause the hardware to go to the next descriptor after processing
+* this one.  But in this case, this is the last descriptor in the list such
+* that it must not be changed.
+*
+* 3 Or More Puts And Commit
+*
+* A series of 3 or more puts followed by a single commit is different in that
+* only the 1st descriptor put into the list is changed when the commit is done.
+* This requires each put starting on the 3rd to change the previous descriptor
+* so that it allows the hardware to continue to the next descriptor in the list.
+*
+* The 1st Put Following A Commit
+*
+* The commit caused the commit pointer to be NULL indicating that there are no
+* descriptors waiting to be committed.  It is necessary for the next put to set
+* the commit pointer so that a commit must follow the put for the hardware to
+* use the descriptor.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- ------------------------------------------------------
+* 1.00a rpm  02/03/03 Removed the XST_DMA_SG_COUNT_EXCEEDED return code
+*                     from SetPktThreshold.
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xdma_channel.h"
+#include "xbasic_types.h"
+#include "xio.h"
+#include "xbuf_descriptor.h"
+#include "xstatus.h"
+
+/* simple virt<-->phy pointer conversions for a single dma channel */
+#define P_TO_V(p) \
+    ((p) ? \
+     (InstancePtr->VirtPtr + ((u32)(p) - (u32)InstancePtr->PhyPtr)) : \
+     0)
+
+#define V_TO_P(v) \
+    ((v) ? \
+     (InstancePtr->PhyPtr + ((u32)(v) - (u32)InstancePtr->VirtPtr)) : \
+     0)
+
+/************************** Constant Definitions *****************************/
+
+#define XDC_SWCR_SG_ENABLE_MASK 0x80000000UL	/* scatter gather enable */
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/* the following macro copies selected fields of a buffer descriptor to another
+ * buffer descriptor, this was provided by the buffer descriptor component but
+ * was moved here since it is only used internally to this component and since
+ * it does not copy all fields
+ */
+#define CopyBufferDescriptor(InstancePtr, DestinationPtr)          \
+{                                                                  \
+    *((u32 *)DestinationPtr + XBD_CONTROL_OFFSET) =            \
+        *((u32 *)InstancePtr + XBD_CONTROL_OFFSET);            \
+    *((u32 *)DestinationPtr + XBD_SOURCE_OFFSET) =             \
+        *((u32 *)InstancePtr + XBD_SOURCE_OFFSET);             \
+    *((u32 *)DestinationPtr + XBD_DESTINATION_OFFSET) =        \
+        *((u32 *)InstancePtr + XBD_DESTINATION_OFFSET);        \
+    *((u32 *)DestinationPtr + XBD_LENGTH_OFFSET) =             \
+        *((u32 *)InstancePtr + XBD_LENGTH_OFFSET);             \
+    *((u32 *)DestinationPtr + XBD_STATUS_OFFSET) =             \
+        *((u32 *)InstancePtr + XBD_STATUS_OFFSET);             \
+    *((u32 *)DestinationPtr + XBD_DEVICE_STATUS_OFFSET) =      \
+        *((u32 *)InstancePtr + XBD_DEVICE_STATUS_OFFSET);      \
+    *((u32 *)DestinationPtr + XBD_ID_OFFSET) =                 \
+        *((u32 *)InstancePtr + XBD_ID_OFFSET);                 \
+    *((u32 *)DestinationPtr + XBD_FLAGS_OFFSET) =              \
+        *((u32 *)InstancePtr + XBD_FLAGS_OFFSET);              \
+    *((u32 *)DestinationPtr + XBD_RQSTED_LENGTH_OFFSET) =      \
+        *((u32 *)InstancePtr + XBD_RQSTED_LENGTH_OFFSET);      \
+}
+
+/************************** Variable Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SgStart
+*
+* DESCRIPTION:
+*
+* This function starts a scatter gather operation for a scatter gather
+* DMA channel.  The first buffer descriptor in the buffer descriptor list
+* will be started with the scatter gather operation.  A scatter gather list
+* should have previously been created for the DMA channel and buffer
+* descriptors put into the scatter gather list such that there are scatter
+* operations ready to be performed.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* A status containing XST_SUCCESS if scatter gather was started successfully
+* for the DMA channel.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
+*
+* A value of XST_DMA_SG_LIST_EMPTY indicates scatter gather was not started
+* because the scatter gather list of the DMA channel does not contain any
+* buffer descriptors that are ready to be processed by the hardware.
+*
+* A value of XST_DMA_SG_IS_STARTED indicates scatter gather was not started
+* because the scatter gather was not stopped, but was already started.
+*
+* A value of XST_DMA_SG_BD_NOT_COMMITTED indicates the buffer descriptor of
+* scatter gather list which was to be started is not committed to the list.
+* This status is more likely if this function is being called from an ISR
+* and non-ISR processing is putting descriptors into the list.
+*
+* A value of XST_DMA_SG_NO_DATA indicates that the buffer descriptor of the
+* scatter gather list which was to be started had already been used by the
+* hardware for a DMA transfer that has been completed.
+*
+* NOTES:
+*
+* It is the responsibility of the caller to get all the buffer descriptors
+* after performing a stop operation and before performing a start operation.
+* If buffer descriptors are not retrieved between stop and start operations,
+* buffer descriptors may be processed by the hardware more than once.
+*
+******************************************************************************/
+int XDmaChannel_SgStart(XDmaChannel * InstancePtr)
+{
+	u32 Register;
+	XBufDescriptor *LastDescriptorPtr;
+
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if a scatter gather list has not been created yet, return a status */
+
+	if (InstancePtr->TotalDescriptorCount == 0) {
+		return XST_DMA_SG_NO_LIST;
+	}
+
+	/* if the scatter gather list exists but is empty then return a status */
+
+	if (XDmaChannel_IsSgListEmpty(InstancePtr)) {
+		return XST_DMA_SG_LIST_EMPTY;
+	}
+
+	/* if scatter gather is busy for the DMA channel, return a status because
+	 * restarting it could lose data
+	 */
+
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_DMAS_REG_OFFSET);
+	if (Register & XDC_DMASR_SG_BUSY_MASK) {
+		return XST_DMA_SG_IS_STARTED;
+	}
+
+	/* get the address of the last buffer descriptor which the DMA hardware
+	 * finished processing
+	 */
+	LastDescriptorPtr = (XBufDescriptor *)
+		P_TO_V(XIo_In32
+		       (InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
+
+	/* setup the first buffer descriptor that will be sent when the scatter
+	 * gather channel is enabled, this is only necessary one time since
+	 * the BDA register of the channel maintains the last buffer descriptor
+	 * processed
+	 */
+	if (LastDescriptorPtr == NULL) {
+		XIo_Out32(InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET,
+			  (u32) V_TO_P(InstancePtr->GetPtr));
+	}
+	else {
+		XBufDescriptor *NextDescriptorPtr;
+
+		/* get the next descriptor to be started, if the status indicates it
+		 * hasn't already been used by the h/w, then it's OK to start it,
+		 * s/w sets the status of each descriptor to busy and then h/w clears
+		 * the busy when it is complete
+		 */
+		NextDescriptorPtr =
+			P_TO_V(XBufDescriptor_GetNextPtr(LastDescriptorPtr));
+
+		if ((XBufDescriptor_GetStatus(NextDescriptorPtr) &
+		     XDC_DMASR_BUSY_MASK) == 0) {
+			return XST_DMA_SG_NO_DATA;
+		}
+		/* don't start the DMA SG channel if the descriptor to be processed
+		 * by h/w is to be committed by the s/w, this function can be called
+		 * such that it interrupts a thread that was putting into the list
+		 */
+		if (NextDescriptorPtr == InstancePtr->CommitPtr) {
+			return XST_DMA_SG_BD_NOT_COMMITTED;
+		}
+	}
+
+	/* start the scatter gather operation by clearing the stop bit in the
+	 * control register and setting the enable bit in the s/w control register,
+	 * both of these are necessary to cause it to start, right now the order of
+	 * these statements is important, the software control register should be
+	 * set 1st.  The other order can cause the CPU to have a loss of sync
+	 * because it cannot read/write the register while the DMA operation is
+	 * running
+	 */
+
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_SWCR_REG_OFFSET);
+
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_SWCR_REG_OFFSET,
+		  Register | XDC_SWCR_SG_ENABLE_MASK);
+
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_DMAC_REG_OFFSET);
+
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_DMAC_REG_OFFSET,
+		  Register & ~XDC_DMACR_SG_DISABLE_MASK);
+
+	/* indicate the DMA channel scatter gather operation was started
+	 * successfully
+	 */
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SgStop
+*
+* DESCRIPTION:
+*
+* This function stops a scatter gather operation for a scatter gather
+* DMA channel. This function starts the process of stopping a scatter
+* gather operation that is in progress and waits for the stop to be completed.
+* Since it waits for the operation to stopped before returning, this function
+* could take an amount of time relative to the size of the DMA scatter gather
+* operation which is in progress.  The scatter gather list of the DMA channel
+* is not modified by this function such that starting the scatter gather
+* channel after stopping it will cause it to resume.  This operation is
+* considered to be a graceful stop in that the scatter gather operation
+* completes the current buffer descriptor before stopping.
+*
+* If the interrupt is enabled, an interrupt will be generated when the
+* operation is stopped and the caller is responsible for handling the
+* interrupt.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* BufDescriptorPtr is also a return value which contains a pointer to the
+* buffer descriptor which the scatter gather operation completed when it
+* was stopped.
+*
+* RETURN VALUE:
+*
+* A status containing XST_SUCCESS if scatter gather was stopped successfully
+* for the DMA channel.
+*
+* A value of XST_DMA_SG_IS_STOPPED indicates scatter gather was not stoppped
+* because the scatter gather is not started, but was already stopped.
+*
+* BufDescriptorPtr contains a pointer to the buffer descriptor which was
+* completed when the operation was stopped.
+*
+* NOTES:
+*
+* This function implements a loop which polls the hardware for an infinite
+* amount of time. If the hardware is not operating correctly, this function
+* may never return.
+*
+******************************************************************************/
+int
+XDmaChannel_SgStop(XDmaChannel * InstancePtr,
+		   XBufDescriptor ** BufDescriptorPtr)
+{
+	u32 Register;
+
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufDescriptorPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* get the contents of the software control register, if scatter gather is not
+	 * enabled (started), then return a status because the disable acknowledge
+	 * would not be generated
+	 */
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_SWCR_REG_OFFSET);
+
+	if ((Register & XDC_SWCR_SG_ENABLE_MASK) == 0) {
+		return XST_DMA_SG_IS_STOPPED;
+	}
+
+	/* disable scatter gather by writing to the software control register
+	 * without modifying any other bits of the register
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_SWCR_REG_OFFSET,
+		  Register & ~XDC_SWCR_SG_ENABLE_MASK);
+
+	/* scatter gather does not disable immediately, but after the current
+	 * buffer descriptor is complete, so wait for the DMA channel to indicate
+	 * the disable is complete
+	 */
+	do {
+		Register =
+			XIo_In32(InstancePtr->RegBaseAddress +
+				 XDC_DMAS_REG_OFFSET);
+	}
+	while (Register & XDC_DMASR_SG_BUSY_MASK);
+
+	/* set the specified buffer descriptor pointer to point to the buffer
+	 * descriptor that the scatter gather DMA channel was processing
+	 */
+	*BufDescriptorPtr = (XBufDescriptor *)
+		P_TO_V(XIo_In32
+		       (InstancePtr->RegBaseAddress + XDC_BDA_REG_OFFSET));
+
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_CreateSgList
+*
+* DESCRIPTION:
+*
+* This function creates a scatter gather list in the DMA channel.  A scatter
+* gather list consists of a list of buffer descriptors that are available to
+* be used for scatter gather operations.  Buffer descriptors are put into the
+* list to request a scatter gather operation to be performed.
+*
+* A number of buffer descriptors are created from the specified memory and put
+* into a buffer descriptor list as empty buffer descriptors. This function must
+* be called before non-empty buffer descriptors may be put into the DMA channel
+* to request scatter gather operations.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* MemoryPtr contains a pointer to the memory which is to be used for buffer
+* descriptors and must not be cached (virtual).
+*
+* ByteCount contains the number of bytes for the specified memory to be used
+* for buffer descriptors.
+*
+* PhyPtr contains a pointer to the physical memory use for buffer descriptors.
+*
+* RETURN VALUE:
+*
+* A status contains XST_SUCCESS if the scatter gather list was successfully
+* created.
+*
+* A value of XST_DMA_SG_LIST_EXISTS indicates that the scatter gather list
+* was not created because the list has already been created.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+int
+XDmaChannel_CreateSgList(XDmaChannel * InstancePtr,
+			 u32 *MemoryPtr, u32 ByteCount, void *PhyPtr)
+{
+	XBufDescriptor *BufferDescriptorPtr = (XBufDescriptor *) MemoryPtr;
+	XBufDescriptor *PreviousDescriptorPtr = NULL;
+	XBufDescriptor *StartOfListPtr = BufferDescriptorPtr;
+	u32 UsedByteCount;
+
+	/* assert to verify valid input arguments, alignment for those
+	 * arguments that have alignment restrictions, and at least enough
+	 * memory for one buffer descriptor
+	 */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(MemoryPtr != NULL);
+	XASSERT_NONVOID(((u32) MemoryPtr & 3) == 0);
+	XASSERT_NONVOID(ByteCount != 0);
+	XASSERT_NONVOID(ByteCount >= sizeof(XBufDescriptor));
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if the scatter gather list has already been created, then return
+	 * with a status
+	 */
+	if (InstancePtr->TotalDescriptorCount != 0) {
+		return XST_DMA_SG_LIST_EXISTS;
+	}
+
+	/* save this up front so V_TO_P() works correctly */
+	InstancePtr->VirtPtr = MemoryPtr;
+	InstancePtr->PhyPtr = PhyPtr;
+
+	/* loop thru the specified memory block and create as many buffer
+	 * descriptors as possible putting each into the list which is
+	 * implemented as a ring buffer, make sure not to use any memory which
+	 * is not large enough for a complete buffer descriptor
+	 */
+	UsedByteCount = 0;
+	while ((UsedByteCount + sizeof(XBufDescriptor)) <= ByteCount) {
+		/* setup a pointer to the next buffer descriptor in the memory and
+		 * update # of used bytes to know when all of memory is used
+		 */
+		BufferDescriptorPtr = (XBufDescriptor *) ((u32) MemoryPtr +
+							  UsedByteCount);
+
+		/* initialize the new buffer descriptor such that it doesn't contain
+		 * garbage which could be used by the DMA hardware
+		 */
+		XBufDescriptor_Initialize(BufferDescriptorPtr);
+
+		/* if this is not the first buffer descriptor to be created,
+		 * then link it to the last created buffer descriptor
+		 */
+		if (PreviousDescriptorPtr != NULL) {
+			XBufDescriptor_SetNextPtr(PreviousDescriptorPtr,
+						  V_TO_P(BufferDescriptorPtr));
+		}
+
+		/* always keep a pointer to the last created buffer descriptor such
+		 * that they can be linked together in the ring buffer
+		 */
+		PreviousDescriptorPtr = BufferDescriptorPtr;
+
+		/* keep a count of the number of descriptors in the list to allow
+		 * error processing to be performed
+		 */
+		InstancePtr->TotalDescriptorCount++;
+
+		UsedByteCount += sizeof(XBufDescriptor);
+	}
+
+	/* connect the last buffer descriptor created and inserted in the list
+	 * to the first such that a ring buffer is created
+	 */
+	XBufDescriptor_SetNextPtr(BufferDescriptorPtr, V_TO_P(StartOfListPtr));
+
+	/* initialize the ring buffer to indicate that there are no
+	 * buffer descriptors in the list which point to valid data buffers
+	 */
+	InstancePtr->PutPtr = BufferDescriptorPtr;
+	InstancePtr->GetPtr = BufferDescriptorPtr;
+	InstancePtr->CommitPtr = NULL;
+	InstancePtr->LastPtr = BufferDescriptorPtr;
+	InstancePtr->ActiveDescriptorCount = 0;
+	InstancePtr->ActivePacketCount = 0;
+	InstancePtr->Committed = FALSE;
+
+	/* indicate the scatter gather list was successfully created */
+
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_IsSgListEmpty
+*
+* DESCRIPTION:
+*
+* This function determines if the scatter gather list of a DMA channel is
+* empty with regard to buffer descriptors which are pointing to buffers to be
+* used for scatter gather operations.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* A value of TRUE if the scatter gather list is empty, otherwise a value of
+* FALSE.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_IsSgListEmpty(XDmaChannel * InstancePtr)
+{
+	/* assert to verify valid input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if the number of descriptors which are being used in the list is zero
+	 * then the list is empty
+	 */
+	return (InstancePtr->ActiveDescriptorCount == 0);
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_PutDescriptor
+*
+* DESCRIPTION:
+*
+* This function puts a buffer descriptor into the DMA channel scatter
+* gather list. A DMA channel maintains a list of buffer descriptors which are
+* to be processed.  This function puts the specified buffer descriptor
+* at the next location in the list.  Note that since the list is already intact,
+* the information in the parameter is copied into the list (rather than modify
+* list pointers on the fly).
+*
+* After buffer descriptors are put into the list, they must also be committed
+* by calling another function.  This allows multiple buffer descriptors which
+* span a single packet to be put into the list while preventing the hardware
+* from starting the first buffer descriptor of the packet.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* BufferDescriptorPtr is a pointer to the buffer descriptor to be put into
+* the next available location of the scatter gather list.
+*
+* RETURN VALUE:
+*
+* A status which indicates XST_SUCCESS if the buffer descriptor was
+* successfully put into the scatter gather list.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
+*
+* A value of XST_DMA_SG_LIST_FULL indicates the buffer descriptor was not
+* put into the list because the list was full.
+*
+* A value of XST_DMA_SG_BD_LOCKED indicates the buffer descriptor was not
+* put into the list because the buffer descriptor in the list which is to
+* be overwritten was locked.  A locked buffer descriptor indicates the higher
+* layered software is still using the buffer descriptor.
+*
+* NOTES:
+*
+* It is necessary to create a scatter gather list for a DMA channel before
+* putting buffer descriptors into it.
+*
+******************************************************************************/
+int
+XDmaChannel_PutDescriptor(XDmaChannel * InstancePtr,
+			  XBufDescriptor * BufferDescriptorPtr)
+{
+	u32 Control;
+
+	/* assert to verify valid input arguments and alignment for those
+	 * arguments that have alignment restrictions
+	 */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufferDescriptorPtr != NULL);
+	XASSERT_NONVOID(((u32) BufferDescriptorPtr & 3) == 0);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if a scatter gather list has not been created yet, return a status */
+
+	if (InstancePtr->TotalDescriptorCount == 0) {
+		return XST_DMA_SG_NO_LIST;
+	}
+
+	/* if the list is full because all descriptors are pointing to valid
+	 * buffers, then indicate an error, this code assumes no list or an
+	 * empty list is detected above
+	 */
+	if (InstancePtr->ActiveDescriptorCount ==
+	    InstancePtr->TotalDescriptorCount) {
+		return XST_DMA_SG_LIST_FULL;
+	}
+
+	/* if the buffer descriptor in the list which is to be overwritten is
+	 * locked, then don't overwrite it and return a status
+	 */
+	if (XBufDescriptor_IsLocked(InstancePtr->PutPtr)) {
+		return XST_DMA_SG_BD_LOCKED;
+	}
+
+	/* set the scatter gather stop bit in the control word of the descriptor
+	 * to cause the h/w to stop after it processes this descriptor since it
+	 * will be the last in the list
+	 */
+	Control = XBufDescriptor_GetControl(BufferDescriptorPtr);
+	XBufDescriptor_SetControl(BufferDescriptorPtr,
+				  Control | XDC_DMACR_SG_DISABLE_MASK);
+
+	/* set both statuses in the descriptor so we tell if they are updated with
+	 * the status of the transfer, the hardware should change the busy in the
+	 * DMA status to be false when it completes
+	 */
+	XBufDescriptor_SetStatus(BufferDescriptorPtr, XDC_DMASR_BUSY_MASK);
+	XBufDescriptor_SetDeviceStatus(BufferDescriptorPtr, 0);
+
+	/* copy the descriptor into the next position in the list so it's ready to
+	 * be used by the h/w, this assumes the descriptor in the list prior to this
+	 * one still has the stop bit in the control word set such that the h/w
+	 * use this one yet
+	 */
+	CopyBufferDescriptor(BufferDescriptorPtr, InstancePtr->PutPtr);
+
+	/* End of a packet is reached. Bump the packet counter */
+	if (XBufDescriptor_IsLastControl(InstancePtr->PutPtr)) {
+		InstancePtr->ActivePacketCount++;
+	}
+
+	/* only the last in the list and the one to be committed have scatter gather
+	 * disabled in the control word, a commit requires only one descriptor
+	 * to be changed, when # of descriptors to commit > 2 all others except the
+	 * 1st and last have scatter gather enabled
+	 */
+	if ((InstancePtr->CommitPtr != InstancePtr->LastPtr) &&
+	    (InstancePtr->CommitPtr != NULL)) {
+		Control = XBufDescriptor_GetControl(InstancePtr->LastPtr);
+		XBufDescriptor_SetControl(InstancePtr->LastPtr,
+					  Control & ~XDC_DMACR_SG_DISABLE_MASK);
+	}
+
+	/* update the list data based upon putting a descriptor into the list,
+	 * these operations must be last
+	 */
+	InstancePtr->ActiveDescriptorCount++;
+
+	/* only update the commit pointer if it is not already active, this allows
+	 * it to be deactivated after every commit such that a single descriptor
+	 * which is committed does not appear to be waiting to be committed
+	 */
+	if (InstancePtr->CommitPtr == NULL) {
+		InstancePtr->CommitPtr = InstancePtr->LastPtr;
+	}
+
+	/* these updates MUST BE LAST after the commit pointer update in order for
+	 * the commit pointer to track the correct descriptor to be committed
+	 */
+	InstancePtr->LastPtr = InstancePtr->PutPtr;
+	InstancePtr->PutPtr =
+		P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->PutPtr));
+
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_CommitPuts
+*
+* DESCRIPTION:
+*
+* This function commits the buffer descriptors which have been put into the
+* scatter list for the DMA channel since the last commit operation was
+* performed.  This enables the calling functions to put several buffer
+* descriptors into the list (e.g.,a packet's worth) before allowing the scatter
+* gather operations to start.  This prevents the DMA channel hardware from
+* starting to use the buffer descriptors in the list before they are ready
+* to be used (multiple buffer descriptors for a single packet).
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* A status indicating XST_SUCCESS if the buffer descriptors of the list were
+* successfully committed.
+*
+* A value of XST_DMA_SG_NOTHING_TO_COMMIT indicates that the buffer descriptors
+* were not committed because there was nothing to commit in the list.  All the
+* buffer descriptors which are in the list are commited.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+int XDmaChannel_CommitPuts(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if the buffer descriptor to be committed is already committed or
+	 * the list is empty (none have been put in), then indicate an error
+	 */
+	if ((InstancePtr->CommitPtr == NULL) ||
+	    XDmaChannel_IsSgListEmpty(InstancePtr)) {
+		return XST_DMA_SG_NOTHING_TO_COMMIT;
+	}
+
+	/* last descriptor in the list must have scatter gather disabled so the end
+	 * of the list is hit by h/w, if descriptor to commit is not last in list,
+	 * commit descriptors by enabling scatter gather in the descriptor
+	 */
+	if (InstancePtr->CommitPtr != InstancePtr->LastPtr) {
+		u32 Control;
+
+		Control = XBufDescriptor_GetControl(InstancePtr->CommitPtr);
+		XBufDescriptor_SetControl(InstancePtr->CommitPtr, Control &
+					  ~XDC_DMACR_SG_DISABLE_MASK);
+	}
+
+	/* Buffer Descriptors are committed. DMA is ready to be enabled */
+	InstancePtr->Committed = TRUE;
+
+	/* Update the commit pointer to indicate that there is nothing to be
+	 * committed, this state is used by start processing to know that the
+	 * buffer descriptor to start is not waiting to be committed
+	 */
+	InstancePtr->CommitPtr = NULL;
+
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetDescriptor
+*
+* DESCRIPTION:
+*
+* This function gets a buffer descriptor from the scatter gather list of the
+* DMA channel. The buffer descriptor is retrieved from the scatter gather list
+* and the scatter gather list is updated to not include the retrieved buffer
+* descriptor.  This is typically done after a scatter gather operation
+* completes indicating that a data buffer has been successfully sent or data
+* has been received into the data buffer. The purpose of this function is to
+* allow the device using the scatter gather operation to get the results of the
+* operation.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* BufDescriptorPtr is a pointer to a pointer to the buffer descriptor which
+* was retrieved from the list.  The buffer descriptor is not really removed
+* from the list, but it is changed to a state such that the hardware will not
+* use it again until it is put into the scatter gather list of the DMA channel.
+*
+* RETURN VALUE:
+*
+* A status indicating XST_SUCCESS if a buffer descriptor was retrieved from
+* the scatter gather list of the DMA channel.
+*
+* A value of XST_DMA_SG_NO_LIST indicates the scatter gather list has not
+* been created.
+*
+* A value of XST_DMA_SG_LIST_EMPTY indicates no buffer descriptor was
+* retrieved from the list because there are no buffer descriptors to be
+* processed in the list.
+*
+* BufDescriptorPtr is updated to point to the buffer descriptor which was
+* retrieved from the list if the status indicates success.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+int
+XDmaChannel_GetDescriptor(XDmaChannel * InstancePtr,
+			  XBufDescriptor ** BufDescriptorPtr)
+{
+	u32 Control;
+
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufDescriptorPtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if a scatter gather list has not been created yet, return a status */
+
+	if (InstancePtr->TotalDescriptorCount == 0) {
+		return XST_DMA_SG_NO_LIST;
+	}
+
+	/* if the buffer descriptor list is empty, then indicate an error */
+
+	if (XDmaChannel_IsSgListEmpty(InstancePtr)) {
+		return XST_DMA_SG_LIST_EMPTY;
+	}
+
+	/* retrieve the next buffer descriptor which is ready to be processed from
+	 * the buffer descriptor list for the DMA channel, set the control word
+	 * such that hardware will stop after the descriptor has been processed
+	 */
+	Control = XBufDescriptor_GetControl(InstancePtr->GetPtr);
+	XBufDescriptor_SetControl(InstancePtr->GetPtr,
+				  Control | XDC_DMACR_SG_DISABLE_MASK);
+
+	/* set the input argument, which is also an output, to point to the
+	 * buffer descriptor which is to be retrieved from the list
+	 */
+	*BufDescriptorPtr = InstancePtr->GetPtr;
+
+	/* update the pointer of the DMA channel to reflect the buffer descriptor
+	 * was retrieved from the list by setting it to the next buffer descriptor
+	 * in the list and indicate one less descriptor in the list now
+	 */
+	InstancePtr->GetPtr =
+		P_TO_V(XBufDescriptor_GetNextPtr(InstancePtr->GetPtr));
+	InstancePtr->ActiveDescriptorCount--;
+
+	return XST_SUCCESS;
+}
+
+/*********************** Interrupt Collescing Functions **********************/
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktCount
+*
+* DESCRIPTION:
+*
+* This function returns the value of the unserviced packet count register of
+* the DMA channel.  This count represents the number of packets that have been
+* sent or received by the hardware, but not processed by software.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* The unserviced packet counter register contents for the DMA channel.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetPktCount(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* get the unserviced packet count from the register and return it */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_UPC_REG_OFFSET);
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_DecrementPktCount
+*
+* DESCRIPTION:
+*
+* This function decrements the value of the unserviced packet count register.
+* This informs the hardware that the software has processed a packet.  The
+* unserviced packet count register may only be decremented by one in the
+* hardware.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* None.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_DecrementPktCount(XDmaChannel * InstancePtr)
+{
+	u32 Register;
+
+	/* assert to verify input arguments */
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* if the unserviced packet count register can be decremented (rather
+	 * than rolling over) decrement it by writing a 1 to the register,
+	 * this is the only valid write to the register as it serves as an
+	 * acknowledge that a packet was handled by the software
+	 */
+	Register = XIo_In32(InstancePtr->RegBaseAddress + XDC_UPC_REG_OFFSET);
+	if (Register > 0) {
+		XIo_Out32(InstancePtr->RegBaseAddress + XDC_UPC_REG_OFFSET,
+			  1UL);
+	}
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SetPktThreshold
+*
+* DESCRIPTION:
+*
+* This function sets the value of the packet count threshold register of the
+* DMA channel.  It reflects the number of packets that must be sent or
+* received before generating an interrupt.  This value helps implement
+* a concept called "interrupt coalescing", which is used to reduce the number
+* of interrupts from devices with high data rates.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* Threshold is the value that is written to the threshold register of the
+* DMA channel.
+*
+* RETURN VALUE:
+*
+* A status containing XST_SUCCESS if the packet count threshold was
+* successfully set.
+*
+* NOTES:
+*
+* The packet threshold could be set to larger than the number of descriptors
+* allocated to the DMA channel. In this case, the wait bound will take over
+* and always indicate data arrival. There was a check in this function that
+* returned an error if the treshold was larger than the number of descriptors,
+* but that was removed because users would then have to set the threshold
+* only after they set descriptor space, which is an order dependency that
+* caused confustion.
+*
+******************************************************************************/
+int XDmaChannel_SetPktThreshold(XDmaChannel * InstancePtr, u8 Threshold)
+{
+	/* assert to verify input arguments, don't assert the threshold since
+	 * it's range is unknown
+	 */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* set the packet count threshold in the register such that an interrupt
+	 * may be generated, if enabled, when the packet count threshold is
+	 * reached or exceeded
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_PCT_REG_OFFSET,
+		  (u32) Threshold);
+
+	/* indicate the packet count threshold was successfully set */
+
+	return XST_SUCCESS;
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktThreshold
+*
+* DESCRIPTION:
+*
+* This function gets the value of the packet count threshold register of the
+* DMA channel.  This value reflects the number of packets that must be sent or
+* received before generating an interrupt.  This value helps implement a concept
+* called "interrupt coalescing", which is used to reduce the number of
+* interrupts from devices with high data rates.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* The packet threshold register contents for the DMA channel and is a value in
+* the range 0 - 1023.  A value of 0 indicates the packet wait bound timer is
+* disabled.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+u8 XDmaChannel_GetPktThreshold(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* get the packet count threshold from the register and return it,
+	 * since only 8 bits are used, cast it to return only those bits */
+
+	return (u8) XIo_In32(InstancePtr->RegBaseAddress + XDC_PCT_REG_OFFSET);
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_SetPktWaitBound
+*
+* DESCRIPTION:
+*
+* This function sets the value of the packet wait bound register of the
+* DMA channel.  This value reflects the timer value used to trigger an
+* interrupt when not enough packets have been received to reach the packet
+* count threshold.
+*
+* The timer is in millisecond units with +/- 33% accuracy.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* WaitBound is the value, in milliseconds, to be stored in the wait bound
+* register of the DMA channel and is a value in the range 0  - 1023.  A value
+* of 0 disables the packet wait bound timer.
+*
+* RETURN VALUE:
+*
+* None.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+void XDmaChannel_SetPktWaitBound(XDmaChannel * InstancePtr, u32 WaitBound)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(WaitBound < 1024);
+	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* set the packet wait bound in the register such that interrupt may be
+	 * generated, if enabled, when packets have not been handled for a specific
+	 * amount of time
+	 */
+	XIo_Out32(InstancePtr->RegBaseAddress + XDC_PWB_REG_OFFSET, WaitBound);
+}
+
+/******************************************************************************
+*
+* FUNCTION:
+*
+* XDmaChannel_GetPktWaitBound
+*
+* DESCRIPTION:
+*
+* This function gets the value of the packet wait bound register of the
+* DMA channel.  This value contains the timer value used to trigger an
+* interrupt when not enough packets have been received to reach the packet
+* count threshold.
+*
+* The timer is in millisecond units with +/- 33% accuracy.
+*
+* ARGUMENTS:
+*
+* InstancePtr contains a pointer to the DMA channel to operate on.  The DMA
+* channel should be configured to use scatter gather in order for this function
+* to be called.
+*
+* RETURN VALUE:
+*
+* The packet wait bound register contents for the DMA channel.
+*
+* NOTES:
+*
+* None.
+*
+******************************************************************************/
+u32 XDmaChannel_GetPktWaitBound(XDmaChannel * InstancePtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* get the packet wait bound from the register and return it */
+
+	return XIo_In32(InstancePtr->RegBaseAddress + XDC_PWB_REG_OFFSET);
+}
diff --git a/drivers/xilinx_common/xdmabdv3.h b/drivers/xilinx_common/xdmabdv3.h
new file mode 100644
index 0000000..2af6711
--- /dev/null
+++ b/drivers/xilinx_common/xdmabdv3.h
@@ -0,0 +1,531 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file xdmabdv3.h
+ *
+ * This header provides operations to manage buffer descriptors in support
+ * of simple and scatter-gather DMA (see xdmav3.h).
+ *
+ * The API exported by this header defines abstracted macros that allow the
+ * user to read/write specific BD fields.
+ *
+ * <b>Buffer Descriptors</b>
+ *
+ * A buffer descriptor (BD) defines a DMA transaction (see "Transaction"
+ * section in xdmav3.h). The macros defined by this header file allow access
+ * to most fields within a BD to tailor a DMA transaction according to user
+ * and HW requirements.  See the HW IP DMA spec for more information on BD
+ * fields and how they affect transfers.
+ *
+ * The XDmaBdV3 structure defines a BD. The organization of this structure is
+ * driven mainly by the hardware for use in scatter-gather DMA transfers.
+ *
+ * <b>Accessor Macros</b>
+ *
+ * Most of the BD attributes can be accessed through macro functions defined
+ * here in this API. Words such as XDMAV3_BD_USR0_OFFSET (see xdmav3_l.h)
+ * should be accessed using XDmaV3_mReadBd() and XDmaV3_mWriteBd() as defined in
+ * xdmav3_l.h. The USR words are implementation dependent. For example, they may
+ * implement checksum offloading fields for Ethernet devices. Accessor macros
+ * may be defined in the device specific API to get at this data.
+ *
+ * <b>Performance</b>
+ *
+ * BDs are typically in a non-cached memory space. Limiting I/O to BDs can
+ * improve overall performance of the DMA channel.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 3.00a rmm  03/11/06 First release
+ *       rmm  06/22/06 Added extern "C"
+ * </pre>
+ *
+ * ***************************************************************************
+ */
+
+#ifndef XDMABD_H		/* prevent circular inclusions */
+#define XDMABD_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include <asm/delay.h>
+#include "xdmav3_l.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * The XDmaBdV3 is the type for buffer descriptors (BDs).
+ */
+typedef u32 XDmaBdV3[XDMAV3_BD_NUM_WORDS];
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+ * Zero out BD fields
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Nothing
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mClear(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mClear(BdPtr)                    \
+    memset((BdPtr), 0, sizeof(XDmaBdV3))
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the BD's Packet DMA transfer status word.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Word at offset XDMAV3_BD_DMASR_OFFSET
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetStatus(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetStatus(BdPtr)              \
+    XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMASR_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the BD's Packet status word. This is the first word of local link
+ * footer information for receive channels.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Word at offset XDMAV3_BD_SR_OFFSET
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetPacketStatus(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetPacketStatus(BdPtr)                \
+    XDmaV3_mReadBd((BdPtr), XDMAV3_BD_SR_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the BD length field.
+ *
+ * For Tx channels, the returned value is the same as that written with
+ * XDmaBdV3_mSetLength().
+ *
+ * For Rx channels, the returned value is the size of the received packet.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Bytes processed by HW or set by XDmaBdV3_mSetLength().
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetLength(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetLength(BdPtr)                      \
+    XDmaV3_mReadBd((BdPtr), XDMAV3_BD_LENGTH_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the BD length copy field. See XDmaBdV3_mSetLengthCopy() for
+ * more information.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Value as set by XDmaBdV3_mSetLengthCopy().
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetLengthCopy(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetLengthCopy(BdPtr)                  \
+    XDmaV3_mReadBd((BdPtr), XDMAV3_BD_LENCPY_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Test whether the given BD has been marked as the last BD of a packet.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return TRUE if BD represents the "Last" BD of a packet, FALSE otherwise
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mIsLast(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mIsLast(BdPtr)                                         \
+    ((XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) & XDMAV3_DMACR_LAST_MASK) ? \
+     TRUE : FALSE)
+
+/*****************************************************************************/
+/**
+ * Set the ID field of the given BD. The ID is an arbitrary piece of data the
+ * user can associate with a specific BD.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Id is a 32 bit quantity to set in the BD
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetId(XDmaBdV3* BdPtr, void Id)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetId(BdPtr, Id)                                      \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_ID_OFFSET, (u32)Id))
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the ID field of the given BD previously set with XDmaBdV3_mSetId.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetId(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetId(BdPtr) (XDmaV3_mReadBd((BdPtr), XDMAV3_BD_ID_OFFSET))
+
+
+/*****************************************************************************/
+/**
+ * Causes the DMA engine to increment the buffer address during the DMA
+ * transfer for this BD. This is the desirable setting when the buffer data
+ * occupies a memory range.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetBufIncrement(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetBufIncrement(BdPtr)                                \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+     XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) | XDMAV3_DMACR_AINC_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Cause the DMA engine to use the same memory buffer address during the DMA
+ * transfer for this BD. This is the desirable setting when the buffer data
+ * occupies a single address as may be the case if transferring to/from a FIFO.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetBufNoIncrement(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetBufNoIncrement(BdPtr)                              \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+        XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) & ~XDMAV3_DMACR_AINC_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Bypass data realignment engine (DRE) if DMA channel has DRE capability.
+ * Has no effect if channel does not have DRE.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mIgnoreDre(XDmaBdV3* BdPtr)
+ *
+ ******************************************************************************/
+#define XDmaBdV3_mIgnoreDre(BdPtr)                                      \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+        XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) | XDMAV3_DMACR_BPDRE_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Use data realignment engine (DRE) if DMA channel has DRE capability.
+ * Has no effect if channel does not have DRE.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mUseDre(XDmaBdV3* BdPtr)
+ *
+ ******************************************************************************/
+#define XDmaBdV3_mUseDre(BdPtr)                                         \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+        XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) & ~XDMAV3_DMACR_BPDRE_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Tell the SG DMA engine that the given BD marks the end of the current packet
+ * to be processed.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetLast(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetLast(BdPtr)                                        \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+        XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) | XDMAV3_DMACR_LAST_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Tell the SG DMA engine that the current packet does not end with the given
+ * BD.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mClearLast(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mClearLast(BdPtr)                                      \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+        XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) & ~XDMAV3_DMACR_LAST_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Set the Device Select field of the given BD.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  DevSel is the IP device select to use with LSB of 1. This value
+ *         selects which IP block the transaction will address. Normally this
+ *         is set to 0, but complex IP may require a specific DEVSEL.
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetDevSel(XDmaBdV3* BdPtr, unsigned DevSel)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetDevSel(BdPtr, DevSel)                              \
+    {                                                                   \
+        u32 Dmacr;                                                  \
+        Dmacr = XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET);        \
+        Dmacr = Dmacr | (((DevSel) << XDMAV3_DMACR_DEVSEL_SHIFT) &      \
+                  XDMAV3_DMACR_DEVSEL_MASK);                            \
+        XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET, Dmacr);        \
+    }
+
+
+/*****************************************************************************/
+/**
+ * Set the Page field of the given BD. The Page must be in terms of a physical
+ * address. Use this macro if using 36 bit bus addressing.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Page is the page to set. LSB=1
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetBdPage(XDmaBdV3* BdPtr, unsigned Page)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetBdPage(BdPtr, Page)                                \
+    {                                                                   \
+        u32 Dmacr;                                                  \
+        Dmacr = XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET);        \
+        Dmacr = Dmacr | (((Page) << XDMAV3_DMACR_BDPAGE_SHIFT) &        \
+                  XDMAV3_DMACR_BDPAGE_MASK);                            \
+        XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET, Dmacr);        \
+    }
+
+
+/*****************************************************************************/
+/**
+ * Set transfer attributes for the given BD.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Type defines whether the transfer occurs with single beat or burst
+ *         transfers on the target bus. This parameter must be one of the
+ *         XDMAV3_DMACR_TYPE_*_MASK constants defined in xdma_l.h.
+ * @param  Width defines the width of the transfer as it occurs on the target
+ *         bus. This parameter must be one of the XDMAV3_DMACR_DSIZE_*_MASK
+ *         constants defined in xdma_l.h
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetTransferType(XDmaBdV3* BdPtr, unsigned Type,
+ *                                   unsigned Width)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetTransferType(BdPtr, Type, Width)                   \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_DMACR_OFFSET,                   \
+         XDmaV3_mReadBd((BdPtr), XDMAV3_BD_DMACR_OFFSET) |              \
+         ((Type) & XDMAV3_DMACR_TYPE_MASK) | ((Width) & XDMAV3_DMACR_DSIZE_MASK)))
+
+
+/*****************************************************************************/
+/**
+ * Set transfer length in bytes for the given BD. The length must be set each
+ * time a BD is submitted to HW.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  LenBytes is the number of bytes to transfer.
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetLength(XDmaBdV3* BdPtr, u32 LenBytes)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetLength(BdPtr, LenBytes)                            \
+    XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_LENGTH_OFFSET, (LenBytes))
+
+
+/*****************************************************************************/
+/**
+ * Write the given length to the length copy offset of the BD. This function
+ * is useful only if an application needs to recover the number of bytes
+ * originally set by XDmaBdV3_mSetLength() for Rx channels.
+ *
+ * To effectively use this function, an application would call
+ * XDmaBdV3_mSetLength() to set the length on a Rx descriptor, followed by a
+ * call to this macro to set the same length. When HW has processed the Rx
+ * descriptor it will overwrite the BD length field with the actual length of
+ * the packet. When the application performs post processing of the Rx
+ * descriptor, it can call XDmaBdV3_mGetLengthCopy() to find out how many bytes
+ * were originally allocated to the descriptor.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  LenBytes is the number of bytes to transfer.
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetLengthCopy(XDmaBdV3* BdPtr, u32 LenBytes)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetLengthCopy(BdPtr, LenBytes)                            \
+    XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_LENCPY_OFFSET, (LenBytes))
+
+
+/*****************************************************************************/
+/**
+ * Set the high order address of the BD's buffer address. Use this macro when
+ * the address bus width is greater than 32 bits.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  HighAddr is the high order address bits to set, LSB = 2^32.
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetBufAddrHigh(XDmaBdV3* BdPtr, u32 HighAddr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetBufAddrHigh(BdPtr, HighAddr)               \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_MSBA_OFFSET, (u32)(HighAddr)))
+
+
+/*****************************************************************************/
+/**
+ * Set the low order address (bits 0..31) of the BD's buffer address.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  LowAddr is the low order address bits to set, LSB = 1.
+ *
+ * @note
+ * C-style signature:
+ *    void XDmaBdV3_mSetBufAddrLow(XDmaBdV3* BdPtr, u32 LowAddr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mSetBufAddrLow(BdPtr, LowAddr)                 \
+    (XDmaV3_mWriteBd((BdPtr), XDMAV3_BD_LSBA_OFFSET, (u32)(LowAddr)))
+
+
+/*****************************************************************************/
+/**
+ * Get the high order address of the BD's buffer address. Use this macro when
+ * the address bus width is greater than 32 bits.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetBufAddrHigh(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetBufAddrHigh(BdPtr)                 \
+    (XDmaV3_mReadBd((BdPtr), XDMAV3_BD_MSBA_OFFSET))
+
+
+/*****************************************************************************/
+/**
+ * Get the low order address (bits 0..31) of the BD's buffer address.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    u32 XDmaBdV3_mGetBufAddrLow(XDmaBdV3* BdPtr)
+ *
+ *****************************************************************************/
+#define XDmaBdV3_mGetBufAddrLow(BdPtr)                  \
+    (XDmaV3_mReadBd((BdPtr), XDMAV3_BD_LSBA_OFFSET))
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdmav3.c b/drivers/xilinx_common/xdmav3.c
new file mode 100644
index 0000000..adde840
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3.c
@@ -0,0 +1,104 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3.c
+*
+* This file implements initialization and control related functions. For more
+* information on this driver, see xdmav3.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/05 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include <linux/string.h>
+#include <asm/delay.h>
+
+#include "xdmav3.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+* This function initializes a DMA channel.  This function must be called
+* prior to using a DMA channel. Initialization of a channel includes setting
+* up the register base address, setting up the instance data, and ensuring the
+* HW is in a quiescent state.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param BaseAddress is where the registers for this channel can be found.
+*        If address translation is being used, then this parameter must
+*        reflect the virtual base address.
+*
+* @return
+* - XST_SUCCESS if initialization was successful
+*
+******************************************************************************/
+int XDmaV3_Initialize(XDmaV3 * InstancePtr, u32 BaseAddress)
+{
+	u32 Dmasr;
+
+	/* Setup the instance */
+	memset(InstancePtr, 0, sizeof(XDmaV3));
+	InstancePtr->RegBase = BaseAddress;
+	InstancePtr->IsReady = XCOMPONENT_IS_READY;
+	InstancePtr->BdRing.RunState = XST_DMA_SG_IS_STOPPED;
+
+	/* If this is SGDMA channel, then make sure it is stopped */
+	Dmasr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (Dmasr & (XDMAV3_DMASR_DMACNFG_SGDMARX_MASK |
+		     XDMAV3_DMASR_DMACNFG_SGDMATX_MASK |
+		     XDMAV3_DMASR_DMACNFG_SSGDMA_MASK)) {
+		XDmaV3_SgStop(InstancePtr);
+	}
+
+	return (XST_SUCCESS);
+}
diff --git a/drivers/xilinx_common/xdmav3.h b/drivers/xilinx_common/xdmav3.h
new file mode 100644
index 0000000..5020d13f
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3.h
@@ -0,0 +1,515 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3.h
+*
+* The Xilinx Simple and Scatter Gather DMA driver.  This component supports a
+* distributed DMA design in which each device can have it's own dedicated DMA
+* channel, as opposed to a centralized DMA design. A device which uses DMA
+* typically contains two DMA channels, one for sending data and the other for
+* receiving data.
+*
+* This component is designed to be used as a basic building block for
+* designing a device driver. It provides registers accesses such that all
+* DMA processing can be maintained easier, but the device driver designer
+* must still understand all the details of the DMA channel.
+*
+* For a full description of DMA features, please see the HW spec. This driver
+* supports the following features:
+*   - Simple DMA
+*   - Scatter-Gather DMA (SGDMA)
+*   - Interrupts
+*   - Programmable interrupt coalescing for SGDMA
+*   - 36 Bit bus addressing
+*   - Programmable transaction types
+*   - APIs to manage Buffer Descriptors (BD) movement to and from the SGDMA
+*     engine
+*   - Virtual memory support
+*
+* <b>Transactions</b>
+*
+* To describe a DMA transaction in its simplest form, you need a source address,
+* destination address, and the number of bytes to transfer. When using a DMA
+* receive channel, the source address is within some piece of IP HW and doesn't
+* require the user explicitly set it. Likewise with a transmit channel and the
+* destination address. So this leaves a user buffer address and the number
+* bytes to transfer as the primary transaction attributes. There are more
+* obscure attributes such as:
+*
+*   - Is the user buffer a fixed address FIFO or a range of memory
+*   - The size of the data bus over which the transaction occurs.
+*   - Does the transfer use single beat or bursting capabilities of the
+*     bus over which the transaction occurs.
+*   - If the transaction occurs on a bus wider than 32 bits, what are the
+*     highest order address bits.
+*   - If SGDMA, does this transaction represent the end of a packet.
+*
+* The object used to describe a transaction is referred to as a Buffer
+* Descriptor (BD). The format of a BD closely matches that of the DMA HW.
+* Many fields within the BD correspond directly with the same fields within the
+* HW registers. See xdmabdv3.h for a detailed description of and the API for
+* manipulation of these objects.
+*
+* <b>Simple DMA</b>
+*
+* Simple DMA is a single transaction type of operation. The user uses this
+* driver to setup a transaction, initiate the transaction, then either wait for
+* an interrupt or poll the HW for completion of the transaction. A new
+* transaction may not be initiated until the current one completes.
+*
+* <b>Scatter-Gather DMA</b>
+*
+* SGDMA is more sophisticated in that it allows the user to define a list of
+* transactions in memory which the HW will process without further user
+* intervention. During this time, the user is free to continue adding more work
+* to keep the HW busy.
+*
+* Notification of completed transactions can be done either by polling the HW,
+* or using interrupts that signal a transaction has completed or a series of
+* transactions have been processed.
+*
+* SGDMA processes in units of packets. A packet is defined as a series of
+* data bytes that represent a message. SGDMA allows a packet of data to be
+* broken up into one or more transactions. For example, take an Ethernet IP
+* packet which consists of a 14 byte header followed by a 1 or more byte
+* payload. With SGDMA, the user may point a BD to the header and another BD to
+* the payload, then transfer them as a single message. This strategy can make a
+* TCP/IP stack more efficient by allowing it to keep packet headers and data in
+* different memory regions instead of assembling packets into contiguous blocks
+* of memory.
+*
+* <b>Interrupt Coalescing</b>
+*
+* SGDMA provides control over the frequency of interrupts. On a high speed link
+* significant processor overhead may be used servicing interrupts. Interrupt
+* coalescing provides two mechanisms that help control interrupt frequency.
+*
+* The packet threshold will hold off interrupting the CPU until a programmable
+* number of packets have been processed by the engine. The packet waitbound
+* timer is used to interrupt the CPU if after a programmable amount of time
+* after processing the last packet, no new packets were processed.
+*
+* <b>Interrupts</b>
+*
+* This driver does not service interrupts. This is done typically within
+* a higher level driver that uses DMA. This driver does provide an API to
+* enable or disable specific interrupts.
+*
+* <b>SGDMA List Management</b>
+*
+* The HW expectes BDs to be setup as a singly linked list. As BDs are completed,
+* the DMA engine will dereference BD.Next and load the next BD to process.
+* This driver uses a fixed buffer ring where all BDs are linked to the next
+* adjacent BD in memory. The last BD in the ring is linked to the first.
+*
+* Within the BD ring, the driver maintains four groups of BDs. Each group
+* consists of 0 or more adjacent BDs:
+*
+*   - Free group: Those BDs that can be allocated by the user with
+*     XDmaV3_SgBdAlloc(). These BDs are under driver control.
+*
+*   - Pre-work group: Those BDs that have been allocated with
+*     XDmaV3_SgBdAlloc(). These BDs are under user control. The user modifies
+*     these BDs in preparation for future DMA transactions.
+*
+*   - Work group: Those BDs that have been enqueued to HW with
+*     XDmaV3_SgBdToHw(). These BDs are under HW control and may be in a
+*     state of awaiting HW processing, in process, or processed by HW.
+*
+*   - Post-work group: Those BDs that have been processed by HW and have been
+*     extracted from the work group with XDmaV3_SgBdFromHw(). These BDs are under
+*     user control. The user may access these BDs to determine the result
+*     of DMA transactions. When the user is finished, XDmaV3_SgBdFree() should
+*     be called to place them back into the Free group.
+*
+* It is considered an error for the user to change BDs while they are in the
+* Work group. Doing so can cause data corruption and lead to system instability.
+*
+* The API provides macros that allow BD list traversal. These macros should be
+* used with care as they do not understand where one group ends and another
+* begins.
+*
+* The driver does not cache or keep copies of any BD. When the user modifies
+* BDs returned by XDmaV3_SgBdAlloc() or XDmaV3_SgBdFromHw(), they are modifying
+* the same BD list that HW accesses.
+*
+* Certain pairs of list modification functions have usage restrictions. See
+* the function headers for XDmaV3_SgBdAlloc() and XDmaV3_SgBdFromHw() for
+* more information.
+*
+* <b>SGDMA List Creation</b>
+*
+* During initialization, the function XDmaV3_SgListCreate() is used to setup
+* a user supplied memory block to contain all BDs for the DMA channel. This
+* function takes as an argument the number of BDs to place in the list. To
+* arrive at this number, the user is given two methods of calculating it.
+*
+* The first method assumes the user has a block of memory and they just
+* want to fit as many BDs as possible into it. The user must calculate the
+* number of BDs that will fit with XDmaV3_mSgListCntCalc(), then supply that
+* number into the list creation function.
+*
+* The second method allows the user to just supply the number directly. The
+* driver assumes the memory block is large enough to contain them all. To
+* double-check, the user should invoke XDmaV3_mSgListMemCalc() to verify the
+* memory block is adequate.
+*
+* Once the list has been created, it can be used right away to perform DMA
+* transactions. However, there are optional steps that can be done to increase
+* throughput and decrease user code complexity by the use of XDmaV3_SgListClone().
+*
+* BDs have many user accessible attributes that affect how DMA transactions are
+* carried out. Many of these attributes (such as the bus width) will probably
+* be constant at run-time. The cloning function can be used to copy a template
+* BD to every BD in the list relieving the user of having to setup transactions
+* from scratch every time a BD is submitted to HW.
+*
+* Ideally, the only transaction parameters that need to be set at run-time
+* should be: buffer address, bytes to transfer, and whether the BD is the
+* "Last" BD of a packet.
+*
+* <b>Adding / Removing BDs from the SGDMA Engine</b>
+*
+* BDs may be enqueued (see XDmaV3_SgBdToHw()) to the engine any time after
+* the SGDMA list is created. If the channel is running (see XDmaV3_SgStart()),
+* then newly added BDs will be processed as soon as the engine reaches them.
+* If the channel is stopped (see XDmaV3_SgStop()), the newly added BDs will
+* be accepted but not processed by the engine until it is restarted.
+*
+* Processed BDs may be removed (see XDmaV3_SgBdFromHw()) at any time
+* after the SGDMA list is created provided the engine has processed any.
+*
+* <b>Address Translation</b>
+*
+* When the BD list is setup with XDmaV3_SgListCreate(), a physical and
+* virtual address is supplied for the segment of memory containing the
+* descriptors. The driver will handle any translations internally. Subsequent
+* access of descriptors by the user is done in terms of the virtual address.
+*
+* <b>Alignment</b>
+*
+* Except for 4 byte alignment of BDs there are no other alignment restrictions
+* imposed by this driver. Individual DMA channels may, based on their
+* capabilities or which bus they are a master of, have more stringent alignment
+* requirements. It is up to the user to match the requirements of the DMA
+* channel being used.
+*
+* Aside from the initial creation of BD list (see XDmaV3_SgListCreate()),
+* there are no other run-time checks for proper alignment. Misaligned user
+* buffers or BDs may result in corrupted data.
+*
+* <b>Cache Coherency</b>
+*
+* This driver expects all user buffers attached to BDs to be in cache coherent
+* memory. Buffers for transmit should be flushed from the cache before passing
+* the associated BD to this driver. Buffers for receive should be invalidated
+* before being accessed.
+*
+* If the user wishes that the BD space itself be in cached memory, then
+* modification of this driver is required. The driver helps the user in
+* this area by: 1) Allowing the user to specify what alignment BDs should
+* use (ie. aligned along cache lines); 2) Provide unimplemented invalidate/flush
+* macro placeholders in the driver source code where needed.
+*
+* <b>Reset After Stopping</b>
+*
+* This driver is designed to allow for stop-reset-start cycles of the DMA
+* HW while keeping the BD list intact. When restarted after a reset, this
+* driver will point the DMA engine to where it left off after stopping it.
+*
+* <b>Limitations</b>
+*
+* This driver requires exclusive use of the hardware DMACR.SGS bit. This
+* applies to the actual HW register and BDs submitted through this driver to
+* be processed. If a BD is encountered with this bit set, then it will be
+* cleared within the driver.
+*
+* This driver does not have any mechanism for mutual exclusion. It is up to the
+* user to provide this protection.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+*       rmm  06/22/06 Added extern "C"
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XDMAV3_H		/* prevent circular inclusions */
+#define XDMAV3_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xdmabdv3.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+/* Minimum alignment */
+#define XDMABDV3_MINIMUM_ALIGNMENT  4
+
+
+/**************************** Type Definitions *******************************/
+
+/** This is an internal structure used to maintain the SGDMA list */
+typedef struct {
+	u32 PhysBaseAddr;
+		       /**< Physical address of 1st BD in list */
+	u32 BaseAddr;  /**< Virtual address of 1st BD in list */
+	u32 HighAddr;  /**< Virtual address of last BD in the list */
+	u32 Length;    /**< Total size of ring in bytes */
+	u32 RunState;  /**< Flag to indicate SGDMA is started */
+	u32 Separation;/**< Number of bytes between the starting address
+                                of adjacent BDs */
+	XDmaBdV3 *FreeHead;/**< First BD in the free group */
+	XDmaBdV3 *PreHead; /**< First BD in the pre-work group */
+	XDmaBdV3 *HwHead;  /**< First BD in the work group */
+	XDmaBdV3 *HwTail;  /**< Last BD in the work group */
+	XDmaBdV3 *PostHead;/**< First BD in the post-work group */
+	XDmaBdV3 *BdaRestart;
+			   /**< BDA to load when channel is started */
+	unsigned HwCnt;	   /**< Number of BDs in work group */
+	unsigned PreCnt;   /**< Number of BDs in pre-work group */
+	unsigned FreeCnt;  /**< Number of allocatable BDs in the free group */
+	unsigned PostCnt;  /**< Number of BDs in post-work group */
+	unsigned AllCnt;   /**< Total Number of BDs for channel */
+} XDmaV3_BdRing;
+
+/**
+ * The XDmaV3 driver instance data. An instance must be allocated for each DMA
+ * channel in use. If address translation is enabled, then all addresses and
+ * pointers excluding PhysBase are expressed in terms of the virtual address.
+ */
+typedef struct XDmaV3 {
+	u32 RegBase;	   /**< Base address of channel registers */
+	u32 IsReady;	   /**< Flag to indicate device is ready to use */
+	XDmaV3_BdRing BdRing;  /**< BD storage for SGDMA */
+} XDmaV3;
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+* Use this macro at initialization time to determine how many BDs will fit
+* in a BD list within the given memory constraints.
+*
+* The results of this macro can be provided to XDmaV3_SgListCreate().
+*
+* @param Alignment specifies what byte alignment the BDs must fall on and
+*        must be a power of 2 to get an accurate calculation (32, 64, 126,...)
+* @param Bytes is the number of bytes to be used to store BDs.
+*
+* @return Number of BDs that can fit in the given memory area
+*
+* @note
+* C-style signature:
+*    u32 XDmaV3_mSgListCntCalc(u32 Alignment, u32 Bytes)
+*
+******************************************************************************/
+#define XDmaV3_mSgListCntCalc(Alignment, Bytes)                           \
+    (u32)((Bytes) / ((sizeof(XDmaBdV3) + ((Alignment)-1)) & ~((Alignment)-1)))
+
+/*****************************************************************************/
+/**
+* Use this macro at initialization time to determine how many bytes of memory
+* is required to contain a given number of BDs at a given alignment.
+*
+* @param Alignment specifies what byte alignment the BDs must fall on. This
+*        parameter must be a power of 2 to get an accurate calculation (32, 64,
+*        128,...)
+* @param NumBd is the number of BDs to calculate memory size requirements for
+*
+* @return The number of bytes of memory required to create a BD list with the
+*         given memory constraints.
+*
+* @note
+* C-style signature:
+*    u32 XDmaV3_mSgListMemCalc(u32 Alignment, u32 NumBd)
+*
+******************************************************************************/
+#define XDmaV3_mSgListMemCalc(Alignment, NumBd)                           \
+    (u32)((sizeof(XDmaBdV3) + ((Alignment)-1)) & ~((Alignment)-1)) * (NumBd)
+
+
+/****************************************************************************/
+/**
+* Return the total number of BDs allocated by this channel with
+* XDmaV3_SgListCreate().
+*
+* @param  InstancePtr is the DMA channel to operate on.
+*
+* @return The total number of BDs allocated for this channel.
+*
+* @note
+* C-style signature:
+*    u32 XDmaBdV3_mSgGetCnt(XDmaV3* InstancePtr)
+*
+*****************************************************************************/
+#define XDmaV3_mSgGetCnt(InstancePtr)       ((InstancePtr)->BdRing.AllCnt)
+
+
+/****************************************************************************/
+/**
+* Return the number of BDs allocatable with XDmaV3_SgBdAlloc() for pre-
+* processing.
+*
+* @param  InstancePtr is the DMA channel to operate on.
+*
+* @return The number of BDs currently allocatable.
+*
+* @note
+* C-style signature:
+*    u32 XDmaBdV3_mSgGetFreeCnt(XDmaV3* InstancePtr)
+*
+*****************************************************************************/
+#define XDmaV3_mSgGetFreeCnt(InstancePtr)   ((InstancePtr)->BdRing.FreeCnt)
+
+
+/****************************************************************************/
+/**
+* Return the next BD in a list.
+*
+* @param  InstancePtr is the DMA channel to operate on.
+* @param  BdPtr is the BD to operate on.
+*
+* @return The next BD in the list relative to the BdPtr parameter.
+*
+* @note
+* C-style signature:
+*    XDmaBdV3 *XDmaV3_mSgBdNext(XDmaV3* InstancePtr, XDmaBdV3 *BdPtr)
+*
+*****************************************************************************/
+#define XDmaV3_mSgBdNext(InstancePtr, BdPtr)                            \
+    (((u32)(BdPtr) >= (InstancePtr)->BdRing.HighAddr) ?             \
+     (XDmaBdV3*)(InstancePtr)->BdRing.BaseAddr :                        \
+     (XDmaBdV3*)((u32)(BdPtr) + (InstancePtr)->BdRing.Separation))
+
+
+/****************************************************************************/
+/**
+* Return the previous BD in the list.
+*
+* @param  InstancePtr is the DMA channel to operate on.
+* @param  BdPtr is the BD to operate on
+*
+* @return The previous BD in the list relative to the BdPtr parameter.
+*
+* @note
+* C-style signature:
+*    XDmaBdV3 *XDmaV3_mSgBdPrev(XDmaV3* InstancePtr, XDmaBdV3 *BdPtr)
+*
+*****************************************************************************/
+#define XDmaV3_mSgBdPrev(InstancePtr, BdPtr)                            \
+    (((u32)(BdPtr) <= (InstancePtr)->BdRing.BaseAddr) ?             \
+     (XDmaBdV3*)(InstancePtr)->BdRing.HighAddr :                        \
+     (XDmaBdV3*)((u32)(BdPtr) - (InstancePtr)->BdRing.Separation))
+
+
+/****************************************************************************/
+/**
+* Retrieve the current contents of the DMASR register. This macro can be
+* used to poll the DMA HW for completion of a transaction.
+*
+* @param  InstancePtr is the DMA channel to operate on.
+*
+* @return The current contents of the DMASR register.
+*
+* @note
+* C-style signature:
+*    u32 XDmaV3_mGetStatus(XDmaV3* InstancePtr)
+*
+*****************************************************************************/
+#define XDmaV3_mGetStatus(InstancePtr)                                  \
+    XDmaV3_mReadReg((InstancePtr)->RegBase, XDMAV3_DMASR_OFFSET)
+
+
+/************************** Function Prototypes ******************************/
+
+/*
+ * Initialization and control functions in xdmav3.c
+ */
+int XDmaV3_Initialize(XDmaV3 * InstancePtr, u32 BaseAddress);
+
+/*
+ * Interrupt related functions in xdmav3_intr.c
+ */
+void XDmaV3_SetInterruptStatus(XDmaV3 * InstancePtr, u32 Mask);
+u32 XDmaV3_GetInterruptStatus(XDmaV3 * InstancePtr);
+void XDmaV3_SetInterruptEnable(XDmaV3 * InstancePtr, u32 Mask);
+u32 XDmaV3_GetInterruptEnable(XDmaV3 * InstancePtr);
+
+/*
+ * Simple DMA related functions in xdmav3_simple.c
+ */
+int XDmaV3_SimpleTransfer(XDmaV3 * InstancePtr, XDmaBdV3 * Bdptr);
+
+/*
+ * Scatter gather DMA related functions in xdmav3_sg.c
+ */
+int XDmaV3_SgStart(XDmaV3 * InstancePtr);
+void XDmaV3_SgStop(XDmaV3 * InstancePtr);
+int XDmaV3_SgSetPktThreshold(XDmaV3 * InstancePtr, u16 Threshold);
+int XDmaV3_SgSetPktWaitbound(XDmaV3 * InstancePtr, u16 TimerVal);
+u16 XDmaV3_SgGetPktThreshold(XDmaV3 * InstancePtr);
+u16 XDmaV3_SgGetPktWaitbound(XDmaV3 * InstancePtr);
+
+int XDmaV3_SgListCreate(XDmaV3 * InstancePtr, u32 PhysAddr,
+			u32 VirtAddr, u32 Alignment, unsigned BdCount);
+int XDmaV3_SgListClone(XDmaV3 * InstancePtr, XDmaBdV3 * SrcBdPtr);
+int XDmaV3_SgCheck(XDmaV3 * InstancePtr);
+int XDmaV3_SgBdAlloc(XDmaV3 * InstancePtr, unsigned NumBd,
+		     XDmaBdV3 ** BdSetPtr);
+int XDmaV3_SgBdUnAlloc(XDmaV3 * InstancePtr, unsigned NumBd,
+		       XDmaBdV3 * BdSetPtr);
+int XDmaV3_SgBdToHw(XDmaV3 * InstancePtr, unsigned NumBd, XDmaBdV3 * BdSetPtr);
+int XDmaV3_SgBdFree(XDmaV3 * InstancePtr, unsigned NumBd, XDmaBdV3 * BdSetPtr);
+unsigned XDmaV3_SgBdFromHw(XDmaV3 * InstancePtr, unsigned BdLimit,
+			   XDmaBdV3 ** BdSetPtr);
+
+/*
+ * Selftest functions in xdmav3_selftest.c
+ */
+int XDmaV3_SelfTest(XDmaV3 * InstancePtr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdmav3_intr.c b/drivers/xilinx_common/xdmav3_intr.c
new file mode 100644
index 0000000..781bcc2
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3_intr.c
@@ -0,0 +1,129 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3_intr.c
+*
+* This file implements interrupt control related functions. For more
+* information on this driver, see xdmav3.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xdmav3.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+* Set the interrupt status register for this channel. Use this function
+* to ack pending interrupts.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Mask is a logical OR of XDMAV3_IPXR_*_MASK constants found in
+*        xdmav3_l.h.
+*
+******************************************************************************/
+void XDmaV3_SetInterruptStatus(XDmaV3 * InstancePtr, u32 Mask)
+{
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_ISR_OFFSET, Mask);
+}
+
+
+/*****************************************************************************/
+/**
+* Retrieve the interrupt status for this channel. OR the results of this
+* function with results from XDmaV3_GetInterruptEnable() to determine which
+* interrupts are currently pending to the processor.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @return Mask of interrupt bits made up of XDMAV3_IPXR_*_MASK constants found
+*         in xdmav3_l.h.
+*
+******************************************************************************/
+u32 XDmaV3_GetInterruptStatus(XDmaV3 * InstancePtr)
+{
+	return (XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_ISR_OFFSET));
+}
+
+
+/*****************************************************************************/
+/**
+* Enable specific DMA interrupts.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param Mask is a logical OR of of XDMAV3_IPXR_*_MASK constants found in
+*        xdmav3_l.h.
+*
+******************************************************************************/
+void XDmaV3_SetInterruptEnable(XDmaV3 * InstancePtr, u32 Mask)
+{
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_IER_OFFSET, Mask);
+}
+
+
+/*****************************************************************************/
+/**
+* Retrieve the interrupt enable register for this channel. Use this function to
+* determine which interrupts are currently enabled to the processor.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @return Mask of interrupt bits made up of XDMAV3_IPXR_*_MASK constants found in
+*         xdmav3_l.h.
+*
+******************************************************************************/
+u32 XDmaV3_GetInterruptEnable(XDmaV3 * InstancePtr)
+{
+	return (XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_IER_OFFSET));
+}
diff --git a/drivers/xilinx_common/xdmav3_l.h b/drivers/xilinx_common/xdmav3_l.h
new file mode 100644
index 0000000..2ea5196
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3_l.h
@@ -0,0 +1,295 @@
+/* $Id: */
+
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file xdmav3_l.h
+*
+* This header file contains identifiers and low-level driver functions (or
+* macros) that can be used to access the Direct Memory Access and Scatter
+* Gather (SG DMA) device.
+*
+* For more information about the operation of this device, see the hardware
+* specification and documentation in the higher level driver xdma.h source
+* code file.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+*       rmm  06/22/06 Added extern "C"
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XDMAV3_L_H		/* prevent circular inclusions */
+#define XDMAV3_L_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/* Register offset definitions. Unless otherwise noted, register access is
+ * 32 bit.
+ */
+
+/** @name DMA channel registers
+ *  @{
+ */
+#define XDMAV3_DMASR_OFFSET  0x00000000	 /**< DMA Status Register */
+#define XDMAV3_DMACR_OFFSET  0x00000004	 /**< DMA Control Register */
+#define XDMAV3_MSBA_OFFSET   0x00000008	 /**< Most Significant Bus Address */
+#define XDMAV3_LSBA_OFFSET   0x0000000C	 /**< Least Significant Bus Address */
+#define XDMAV3_BDA_OFFSET    0x00000010	 /**< Buffer Descriptor Address */
+#define XDMAV3_LENGTH_OFFSET 0x00000014	 /**< DMA Length */
+#define XDMAV3_ISR_OFFSET    0x00000018	 /**< Interrupt Status Register */
+#define XDMAV3_IER_OFFSET    0x0000001C	 /**< Interrupt Enable Register */
+#define XDMAV3_SWCR_OFFSET   0x00000020	 /**< Software Control Register */
+/*@}*/
+
+/** @name Buffer Descriptor register offsets
+ *  @{
+ */
+#define XDMAV3_BD_DMASR_OFFSET     0x00	 /**< Channel DMASR register contents */
+#define XDMAV3_BD_DMACR_OFFSET     0x04	 /**< Channel DMACR register contents */
+#define XDMAV3_BD_MSBA_OFFSET      0x08	 /**< Channel MSBA register contents */
+#define XDMAV3_BD_LSBA_OFFSET      0x0C	 /**< Channel LSBA register contents */
+#define XDMAV3_BD_BDA_OFFSET       0x10	 /**< Next buffer descriptor pointer */
+#define XDMAV3_BD_LENGTH_OFFSET    0x14	 /**< Channel LENGTH register contents */
+#define XDMAV3_BD_SR_OFFSET        0x18	 /**< Packet Status */
+#define XDMAV3_BD_RSVD_OFFSET      0x1C	 /**< Reserved */
+#define XDMAV3_BD_USR0_OFFSET      0x20	 /**< HW User defined */
+#define XDMAV3_BD_USR1_OFFSET      0x24	 /**< HW User defined */
+#define XDMAV3_BD_USR2_OFFSET      0x28	 /**< HW User defined */
+#define XDMAV3_BD_USR3_OFFSET      0x2C	 /**< HW User defined */
+#define XDMAV3_BD_USR4_OFFSET      0x30	 /**< HW User defined */
+#define XDMAV3_BD_USR5_OFFSET      0x34	 /**< HW User defined */
+#define XDMAV3_BD_LENCPY_OFFSET    0x38	 /**< SW Driver usage */
+#define XDMAV3_BD_ID_OFFSET        0x3C	 /**< SW Driver usage */
+
+#define XDMAV3_BD_NUM_WORDS        16	 /**< Number of 32-bit words that make
+                                              up a BD */
+/*@}*/
+
+/* Register masks. The following constants define bit locations of various
+ * control bits in the registers. Constants are not defined for those registers
+ * that have a single bit field representing all 32 bits. For further
+ * information on the meaning of the various bit masks, refer to the HW spec.
+ */
+
+
+/** @name DMA Status Register (DMASR) bitmasks
+ *  @note These bitmasks are identical between XDMAV3_DMASR_OFFSET and
+ *  XDMAV3_BD_DMASR_OFFSET
+ * @{
+ */
+#define XDMAV3_DMASR_DMABSY_MASK  0x80000000  /**< DMA busy */
+#define XDMAV3_DMASR_DBE_MASK     0x40000000  /**< Bus error */
+#define XDMAV3_DMASR_DBT_MASK     0x20000000  /**< Bus timeout */
+#define XDMAV3_DMASR_DMADONE_MASK 0x10000000  /**< DMA done */
+#define XDMAV3_DMASR_SGBSY_MASK   0x08000000  /**< SG channel busy */
+#define XDMAV3_DMASR_LAST_MASK    0x04000000  /**< Last BD of packet */
+#define XDMAV3_DMASR_SGDONE_MASK  0x01000000  /**< SGDMA done */
+#define XDMAV3_DMASR_DMACNFG_MASK 0x00300000  /**< DMA configuration */
+
+#define XDMAV3_DMASR_DMACNFG_SIMPLE_MASK  0x00000000  /**< Simple DMA config */
+#define XDMAV3_DMASR_DMACNFG_SSGDMA_MASK  0x00100000  /**< Simple SGDMA config */
+#define XDMAV3_DMASR_DMACNFG_SGDMATX_MASK 0x00200000  /**< SGDMA xmit config */
+#define XDMAV3_DMASR_DMACNFG_SGDMARX_MASK 0x00300000  /**< SGDMA recv config */
+#define XDMAV3_DMASR_DMACNFG_MASK         0x00300000  /**< Mask for all */
+
+/*@}*/
+
+/** @name DMA Control Register (DMACR) bitmasks
+ *  @note These bitmasks are identical between XDMAV3_DMACR_OFFSET and
+ *  XDMAV3_BD_DMACR_OFFSET
+ * @{
+ */
+#define XDMAV3_DMACR_AINC_MASK    0x80000000  /**< Address increment */
+#define XDMAV3_DMACR_BPDRE_MASK   0x20000000  /**< Bypass DRE */
+#define XDMAV3_DMACR_SGS_MASK     0x08000000  /**< Scatter gather stop */
+#define XDMAV3_DMACR_LAST_MASK    0x04000000  /**< Last BD of packet */
+#define XDMAV3_DMACR_DEVSEL_MASK  0x00FF0000  /**< Device select */
+#define XDMAV3_DMACR_BDPAGE_MASK  0x00000F00  /**< BD page address */
+#define XDMAV3_DMACR_TYPE_MASK    0x00000070  /**< DMA transfer type */
+#define XDMAV3_DMACR_DSIZE_MASK   0x00000007  /**< DMA transfer width */
+
+/* Sub-fields within XDMAV3_DMACR_DIR_MASK */
+#define XDMAV3_DMACR_DIR_RX_MASK       0x40000000  /**< Xfer in Rx direction */
+#define XDMAV3_DMACR_DIR_TX_MASK       0x00000000  /**< Xfer in Tx direction */
+
+/* Sub-fields within XDMAV3_DMACR_TYPE_MASK */
+#define XDMAV3_DMACR_TYPE_BFBURST_MASK 0x00000010  /**< Bounded fixed length
+                                                        burst */
+#define XDMAV3_DMACR_TYPE_BIBURST_MASK 0x00000020  /**< Bounded indeterminate
+                                                        burst */
+
+/* Sub-fields within XDMAV3_DMACR_DSIZE_MASK */
+#define XDMAV3_DMACR_DSIZE_8_MASK      0x00000000  /**< Xfer width = 8 bits */
+#define XDMAV3_DMACR_DSIZE_16_MASK     0x00000001  /**< Xfer width = 16 bits */
+#define XDMAV3_DMACR_DSIZE_32_MASK     0x00000002  /**< Xfer width = 32 bits */
+#define XDMAV3_DMACR_DSIZE_64_MASK     0x00000003  /**< Xfer width = 64 bits */
+#define XDMAV3_DMACR_DSIZE_128_MASK    0x00000004  /**< Xfer width = 128 bits */
+
+/* Left shift values for selected masks */
+#define XDMAV3_DMACR_DEVSEL_SHIFT      16
+#define XDMAV3_DMACR_BDPAGE_SHIFT      8
+/*@}*/
+
+/** @name Interrupt status bits for MAC interrupts
+ *  These bits are associated with XDMAV3_ISR_OFFSET and
+ *  XDMAV3_IER_OFFSET registers.
+ *  @{
+ */
+#define XDMAV3_IPXR_DD_MASK      0x00000040  /**< DMA complete */
+#define XDMAV3_IPXR_DE_MASK      0x00000020  /**< DMA error */
+#define XDMAV3_IPXR_PD_MASK      0x00000010  /**< Pkt done */
+#define XDMAV3_IPXR_PCTR_MASK    0x00000008  /**< Pkt count threshold reached */
+#define XDMAV3_IPXR_PWBR_MASK    0x00000004  /**< Pkt waitbound reached */
+#define XDMAV3_IPXR_SGDA_MASK    0x00000002  /**< SG Disable ack */
+#define XDMAV3_IPXR_SGEND_MASK   0x00000001  /**< SG End */
+/*@}*/
+
+/** @name Software control register (SWCR) bitmasks
+ *  @{
+ */
+#define XDMAV3_SWCR_SGE_MASK     0x80000000  /**< SG Enable */
+#define XDMAV3_SWCR_SGD_MASK     0x40000000  /**< SG Disable */
+#define XDMAV3_SWCR_DSGAR_MASK   0x20000000  /**< SG Disable auto-restart */
+#define XDMAV3_SWCR_PWB_MASK     0x00FFF000  /**< Pkt waitbound */
+#define XDMAV3_SWCR_PCT_MASK     0x00000FFF  /**< Pkt threshold count */
+
+/* Left shift values for selected masks */
+#define XDMAV3_SWCR_PCT_SHIFT    0
+#define XDMAV3_SWCR_PWB_SHIFT    12
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/****************************************************************************/
+/**
+*
+* Read the given IPIF register.
+*
+* @param    BaseAddress is the IPIF base address of the device
+* @param    RegOffset is the register offset to be read
+*
+* @return   The 32-bit value of the register
+*
+* @note
+* C-style signature:
+*    u32 XDmaV3_mReadReg(u32 BaseAddress, u32 RegOffset)
+*
+*****************************************************************************/
+#define XDmaV3_mReadReg(BaseAddress, RegOffset) \
+    XIo_In32((u32)(BaseAddress) + (u32)(RegOffset))
+
+
+/****************************************************************************/
+/**
+*
+* Write the given IPIF register.
+*
+* @param    BaseAddress is the IPIF base address of the device
+* @param    RegOffset is the register offset to be written
+* @param    Data is the 32-bit value to write to the register
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    void XDmaV3_mWriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+*****************************************************************************/
+#define XDmaV3_mWriteReg(BaseAddress, RegOffset, Data)  \
+    XIo_Out32((u32)(BaseAddress) + (u32)(RegOffset), (u32)(Data))
+
+
+/****************************************************************************/
+/**
+*
+* Read the given Buffer Descriptor word.
+*
+* @param    BaseAddress is the base address of the BD to read
+* @param    Offset is the word offset to be read
+*
+* @return   The 32-bit value of the field
+*
+* @note
+* C-style signature:
+*    u32 XDmaV3_mReadBd(u32 BaseAddress, u32 Offset)
+*
+*****************************************************************************/
+#define XDmaV3_mReadBd(BaseAddress, Offset)             \
+    (*(u32*)((u32)(BaseAddress) + (u32)(Offset)))
+
+
+/****************************************************************************/
+/**
+*
+* Write the given Buffer Descriptor word.
+*
+* @param    BaseAddress is the base address of the BD to write
+* @param    Offset is the word offset to be written
+* @param    Data is the 32-bit value to write to the field
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    void XDmaV3_mWriteReg(u32 BaseAddress, u32 Offset, u32 Data)
+*
+*****************************************************************************/
+#define XDmaV3_mWriteBd(BaseAddress, Offset, Data)              \
+    (*(u32*)((u32)(BaseAddress) + (u32)(Offset)) = (Data))
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xdmav3_selftest.c b/drivers/xilinx_common/xdmav3_selftest.c
new file mode 100644
index 0000000..626933e
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3_selftest.c
@@ -0,0 +1,79 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3_selftest.c
+*
+* This file implements DMA selftest related functions. For more
+* information on this driver, see xdmav3.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xdmav3.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+* Selftest is not implemented.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+*
+* @return
+* - XST_SUCCESS if the self test passes
+*
+******************************************************************************/
+int XDmaV3_SelfTest(XDmaV3 * InstancePtr)
+{
+	return (XST_SUCCESS);
+}
diff --git a/drivers/xilinx_common/xdmav3_sg.c b/drivers/xilinx_common/xdmav3_sg.c
new file mode 100644
index 0000000..94b1a18
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3_sg.c
@@ -0,0 +1,1261 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3_sg.c
+*
+* This file implements Scatter-Gather DMA (SGDMA) related functions. For more
+* information on this driver, see xdmav3.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+*       rmm  06/22/06 Fixed C++ compiler warnings
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include <linux/string.h>
+#include <asm/delay.h>
+
+#include "xdmav3.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/****************************************************************************
+ * These cache macros are used throughout this source code file to show
+ * users where cache operations should occur if BDs were to be placed in
+ * a cached memory region. Cacheing BD regions, however, is not common.
+ *
+ * The macros are implemented as NULL operations, but may be hooked into
+ * XENV macros in future revisions of this driver.
+ ****************************************************************************/
+#define XDMAV3_CACHE_FLUSH(BdPtr)
+#define XDMAV3_CACHE_INVALIDATE(BdPtr)
+
+/****************************************************************************
+ * Compute the virtual address of a descriptor from its physical address
+ *
+ * @param Ring is the ring BdPtr appears in
+ * @param BdPtr is the physical address of the BD
+ *
+ * @returns Virtual address of BdPtr
+ *
+ * @note Assume BdPtr is always a valid BD in the ring
+ ****************************************************************************/
+#define XDMAV3_PHYS_TO_VIRT(Ring, BdPtr) \
+    ((u32)BdPtr + (Ring->BaseAddr - Ring->PhysBaseAddr))
+
+/****************************************************************************
+ * Compute the physical address of a descriptor from its virtual address
+ *
+ * @param Ring is the ring BdPtr appears in
+ * @param BdPtr is the physical address of the BD
+ *
+ * @returns Physical address of BdPtr
+ *
+ * @note Assume BdPtr is always a valid BD in the ring
+ ****************************************************************************/
+#define XDMAV3_VIRT_TO_PHYS(Ring, BdPtr) \
+    ((u32)BdPtr - (Ring->BaseAddr - Ring->PhysBaseAddr))
+
+/****************************************************************************
+ * Clear or set the SGS bit of the DMACR register
+ ****************************************************************************/
+#define XDMAV3_HW_SGS_CLEAR                                             \
+    XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_DMACR_OFFSET,         \
+                     XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMACR_OFFSET) \
+                     & ~XDMAV3_DMACR_SGS_MASK)
+
+#define XDMAV3_HW_SGS_SET                                               \
+    XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_DMACR_OFFSET,         \
+                     XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMACR_OFFSET) \
+                     | XDMAV3_DMACR_SGS_MASK)
+
+/****************************************************************************
+ * Move the BdPtr argument ahead an arbitrary number of BDs wrapping around
+ * to the beginning of the ring if needed.
+ *
+ * We know if a wrapaound should occur if the new BdPtr is greater than
+ * the high address in the ring OR if the new BdPtr crosses over the
+ * 0xFFFFFFFF to 0 boundary. The latter test is a valid one since we do not
+ * allow a BD space to span this boundary.
+ *
+ * @param Ring is the ring BdPtr appears in
+ * @param BdPtr on input is the starting BD position and on output is the
+ *        final BD position
+ * @param NumBd is the number of BD spaces to increment
+ *
+ ****************************************************************************/
+#define XDMAV3_RING_SEEKAHEAD(Ring, BdPtr, NumBd)                       \
+    {                                                                   \
+        u32 Addr = (u32)BdPtr;                                  \
+                                                                        \
+        Addr += (Ring->Separation * NumBd);                             \
+        if ((Addr > Ring->HighAddr) || ((u32)BdPtr > Addr))         \
+        {                                                               \
+            Addr -= Ring->Length;                                       \
+        }                                                               \
+                                                                        \
+        BdPtr = (XDmaBdV3*)Addr;                                        \
+    }
+
+/****************************************************************************
+ * Move the BdPtr argument backwards an arbitrary number of BDs wrapping
+ * around to the end of the ring if needed.
+ *
+ * We know if a wrapaound should occur if the new BdPtr is less than
+ * the base address in the ring OR if the new BdPtr crosses over the
+ * 0xFFFFFFFF to 0 boundary. The latter test is a valid one since we do not
+ * allow a BD space to span this boundary.
+ *
+ * @param Ring is the ring BdPtr appears in
+ * @param BdPtr on input is the starting BD position and on output is the
+ *        final BD position
+ * @param NumBd is the number of BD spaces to increment
+ *
+ ****************************************************************************/
+#define XDMAV3_RING_SEEKBACK(Ring, BdPtr, NumBd)                        \
+    {                                                                   \
+        u32 Addr = (u32)BdPtr;                                  \
+                                                                        \
+        Addr -= (Ring->Separation * NumBd);                             \
+        if ((Addr < Ring->BaseAddr) || ((u32)BdPtr < Addr))         \
+        {                                                               \
+            Addr += Ring->Length;                                       \
+        }                                                               \
+                                                                        \
+        BdPtr = (XDmaBdV3*)Addr;                                        \
+    }
+
+
+/************************** Function Prototypes ******************************/
+
+static int IsSgDmaChannel(XDmaV3 * InstancePtr);
+
+
+/************************** Variable Definitions *****************************/
+
+/******************************************************************************/
+/**
+ * Start the SGDMA channel.
+ *
+ * @param InstancePtr is a pointer to the instance to be started.
+ *
+ * @return
+ * - XST_SUCCESS if channel was started.
+ * - XST_DMA_SG_NO_LIST if the channel has no initialized BD ring.
+ *
+ ******************************************************************************/
+int XDmaV3_SgStart(XDmaV3 * InstancePtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+	u32 Swcr;
+
+	/* BD list has yet to be created for this channel */
+	if (Ring->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Do nothing if already started */
+	if (Ring->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_SUCCESS);
+	}
+
+	/* Note as started */
+	Ring->RunState = XST_DMA_SG_IS_STARTED;
+
+	/* Restore BDA */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_BDA_OFFSET,
+			 Ring->BdaRestart);
+
+	/* If there are unprocessed BDs then we want to channel to begin processing
+	 * right away
+	 */
+	if ((XDmaV3_mReadBd(XDMAV3_PHYS_TO_VIRT(Ring, Ring->BdaRestart),
+			    XDMAV3_BD_DMASR_OFFSET) & XDMAV3_DMASR_DMADONE_MASK)
+	    == 0) {
+		/* DMACR.SGS = 0 */
+		XDMAV3_HW_SGS_CLEAR;
+	}
+
+	/* To start, clear SWCR.DSGAR, and set SWCR.SGE */
+	Swcr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	Swcr &= ~XDMAV3_SWCR_DSGAR_MASK;
+	Swcr |= XDMAV3_SWCR_SGE_MASK;
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET, Swcr);
+
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Stop the SGDMA or Simple SGDMA channel gracefully. Any DMA operation
+ * currently in progress is allowed to finish.
+ *
+ * An interrupt may be generated as the DMA engine finishes the packet in
+ * process. To prevent this (if desired) then disabled DMA interrupts prior to
+ * invoking this function.
+ *
+ * If after stopping the channel, new BDs are enqueued with XDmaV3_SgBdToHw(),
+ * then those BDs will not be processed until after XDmaV3_SgStart() is called.
+ *
+ * @param InstancePtr is a pointer to the instance to be stopped.
+ *
+ * @note This function will block until the HW indicates that DMA has stopped.
+ *
+ ******************************************************************************/
+void XDmaV3_SgStop(XDmaV3 * InstancePtr)
+{
+	volatile u32 Swcr;
+	u32 Dmasr;
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+	u32 Ier;
+
+	/* Save the contents of the interrupt enable register then disable
+	 * interrupts. This register will be restored at the end of the function
+	 */
+	Ier = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_IER_OFFSET);
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_IER_OFFSET, 0);
+
+	/* Stopping the HW is a three step process:
+	 *   1. Set SWCR.SGD=1
+	 *   2. Wait for SWCR.SGE=0
+	 *   3. Set SWCR.DSGAR=0 and SWCR.SGE=1
+	 *
+	 * Once we've successfully gone through this process, the HW is fully
+	 * stopped. To restart we must give the HW a new BDA.
+	 */
+	Swcr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+
+	/* If the channel is currently active, stop it by setting SWCR.SGD=1
+	 * and waiting for SWCR.SGE to toggle to 0
+	 */
+	if (Swcr & XDMAV3_SWCR_SGE_MASK) {
+		Swcr |= XDMAV3_SWCR_SGD_MASK;
+		XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET,
+				 Swcr);
+
+		while (Swcr & XDMAV3_SWCR_SGE_MASK) {
+			Swcr = XDmaV3_mReadReg(InstancePtr->RegBase,
+					       XDMAV3_SWCR_OFFSET);
+		}
+	}
+
+	/* Note as stopped */
+	Ring->RunState = XST_DMA_SG_IS_STOPPED;
+
+	/* Save the BDA to restore when channel is restarted */
+	Ring->BdaRestart =
+		(XDmaBdV3 *) XDmaV3_mReadReg(InstancePtr->RegBase,
+					     XDMAV3_BDA_OFFSET);
+
+	/* If this is a receive channel, then the BDA restore may require a more
+	 * complex treatment. If the channel stopped without processing a packet,
+	 * then DMASR.SGDONE will be clear. The BDA we've already read in this case
+	 * is really BDA->BDA so we need to backup one BDA to get the correct
+	 * restart point.
+	 */
+	Dmasr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if ((Dmasr & XDMAV3_DMASR_DMACNFG_MASK) ==
+	    XDMAV3_DMASR_DMACNFG_SGDMARX_MASK) {
+		if (!(Dmasr & XDMAV3_DMASR_SGDONE_MASK)) {
+			Ring->BdaRestart =
+				(XDmaBdV3 *) XDMAV3_PHYS_TO_VIRT(Ring,
+								 Ring->
+								 BdaRestart);
+			Ring->BdaRestart =
+				XDmaV3_mSgBdPrev(InstancePtr, Ring->BdaRestart);
+			Ring->BdaRestart =
+				(XDmaBdV3 *) XDMAV3_VIRT_TO_PHYS(Ring,
+								 Ring->
+								 BdaRestart);
+		}
+	}
+
+	Swcr |= XDMAV3_SWCR_DSGAR_MASK;
+	Swcr &= ~XDMAV3_SWCR_SGD_MASK;
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET, Swcr);
+
+	/* Restore interrupt enables. If an interrupt occurs due to this function
+	 * stopping the channel then it will happen right here
+	 */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_IER_OFFSET, Ier);
+}
+
+
+/******************************************************************************/
+/**
+ * Set the packet threshold for this SGDMA channel. This has the effect of
+ * delaying processor interrupts until the given number of packets (not BDs)
+ * have been processed.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param Threshold is the packet threshold to set. If 0 is specified, then
+ *        this feature is disabled. Maximum threshold is 2^12 - 1.
+ *
+ * @return
+ * - XST_SUCCESS if threshold set properly.
+ * - XST_NO_FEATURE if this function was called on a DMA channel that does not
+ *   have interrupt coalescing capabilities.
+ *
+ * @note This function should not be prempted by another XDmaV3 function.
+ *
+ ******************************************************************************/
+int XDmaV3_SgSetPktThreshold(XDmaV3 * InstancePtr, u16 Threshold)
+{
+	u32 Reg;
+
+	/* Is this a SGDMA channel */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (!IsSgDmaChannel(InstancePtr)) {
+		return (XST_NO_FEATURE);
+	}
+
+	/* Replace the pkt threshold field in the SWCR */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	Reg &= ~XDMAV3_SWCR_PCT_MASK;
+	Reg |= ((Threshold << XDMAV3_SWCR_PCT_SHIFT) & XDMAV3_SWCR_PCT_MASK);
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET, Reg);
+
+	/* Finished */
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Set the packet waitbound timer for this SGDMA channel. See xdmav3.h for more
+ * information on interrupt coalescing and the effects of the waitbound timer.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param TimerVal is the waitbound period to set. If 0 is specified, then
+ *        this feature is disabled. Maximum waitbound is 2^12 - 1. LSB is
+ *        1 millisecond (approx).
+ *
+ * @return
+ * - XST_SUCCESS if waitbound set properly.
+ * - XST_NO_FEATURE if this function was called on a DMA channel that does not
+ *   have interrupt coalescing capabilities.
+ *
+ * @note This function should not be prempted by another XDmaV3 function.
+ *
+ ******************************************************************************/
+int XDmaV3_SgSetPktWaitbound(XDmaV3 * InstancePtr, u16 TimerVal)
+{
+	u32 Reg;
+
+	/* Is this a SGDMA channel */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (!IsSgDmaChannel(InstancePtr)) {
+		return (XST_NO_FEATURE);
+	}
+
+	/* Replace the waitbound field in the SWCR */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	Reg &= ~XDMAV3_SWCR_PWB_MASK;
+	Reg |= ((TimerVal << XDMAV3_SWCR_PWB_SHIFT) & XDMAV3_SWCR_PWB_MASK);
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET, Reg);
+
+	/* Finished */
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Get the packet threshold for this channel that was set with
+ * XDmaV3_SgSetPktThreshold().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return Current packet threshold as reported by HW. If the channel does not
+ *         include interrupt coalescing, then the return value will always be 0.
+ ******************************************************************************/
+u16 XDmaV3_SgGetPktThreshold(XDmaV3 * InstancePtr)
+{
+	u32 Reg;
+
+	/* Is this a SGDMA channel */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (!IsSgDmaChannel(InstancePtr)) {
+		return (0);
+	}
+
+	/* Get the threshold */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	Reg &= XDMAV3_SWCR_PCT_MASK;
+	Reg >>= XDMAV3_SWCR_PCT_SHIFT;
+	return ((u16) Reg);
+}
+
+
+/******************************************************************************/
+/**
+ * Get the waitbound timer for this channel that was set with
+ * XDmaV3_SgSetPktWaitbound().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return Current waitbound timer as reported by HW. If the channel does not
+ *         include interrupt coalescing, then the return value will always be 0.
+ ******************************************************************************/
+u16 XDmaV3_SgGetPktWaitbound(XDmaV3 * InstancePtr)
+{
+	u32 Reg;
+
+	/* Is this a SGDMA channel */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (!IsSgDmaChannel(InstancePtr)) {
+		return (0);
+	}
+
+	/* Get the threshold */
+	Reg = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	Reg &= XDMAV3_SWCR_PWB_MASK;
+	Reg >>= XDMAV3_SWCR_PWB_SHIFT;
+	return ((u16) Reg);
+}
+
+
+/******************************************************************************/
+/**
+ * Using a memory segment allocated by the caller, create and setup the BD list
+ * for the given SGDMA channel.
+ *
+ * @param InstancePtr is the instance to be worked on.
+ * @param PhysAddr is the physical base address of user memory region.
+ * @param VirtAddr is the virtual base address of the user memory region. If
+ *        address translation is not being utilized, then VirtAddr should be
+ *        equivalent to PhysAddr.
+ * @param Alignment governs the byte alignment of individual BDs. This function
+ *        will enforce a minimum alignment of 4 bytes with no maximum as long as
+ *        it is specified as a power of 2.
+ * @param BdCount is the number of BDs to setup in the user memory region. It is
+ *        assumed the region is large enough to contain the BDs. Refer to the
+ *        "SGDMA List Creation" section  in xdmav3.h for more information on
+ *        list creation.
+ *
+ * @return
+ *
+ * - XST_SUCCESS if initialization was successful
+ * - XST_NO_FEATURE if the provided instance is a non SGDMA type of DMA
+ *   channel.
+ * - XST_INVALID_PARAM under any of the following conditions: 1) PhysAddr and/or
+ *   VirtAddr are not aligned to the given Alignment parameter; 2) Alignment
+ *   parameter does not meet minimum requirements or is not a power of 2 value;
+ *   3) BdCount is 0.
+ * - XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans
+ *   over address 0x00000000 in virtual address space.
+ *
+ * @note
+ *
+ * Some DMA HW requires 8 or more byte alignments of BDs. Make sure the correct
+ * value is passed into the Alignment parameter to meet individual DMA HW
+ * requirements.
+ *
+ ******************************************************************************/
+int XDmaV3_SgListCreate(XDmaV3 * InstancePtr, u32 PhysAddr, u32 VirtAddr,
+			u32 Alignment, unsigned BdCount)
+{
+	unsigned i;
+	u32 BdV;
+	u32 BdP;
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+
+	/* In case there is a failure prior to creating list, make sure the following
+	 * attributes are 0 to prevent calls to other SG functions from doing anything
+	 */
+	Ring->AllCnt = 0;
+	Ring->FreeCnt = 0;
+	Ring->HwCnt = 0;
+	Ring->PreCnt = 0;
+	Ring->PostCnt = 0;
+
+	/* Is this a SGDMA channel */
+	if (!IsSgDmaChannel(InstancePtr)) {
+		return (XST_NO_FEATURE);
+	}
+
+	/* Make sure Alignment parameter meets minimum requirements */
+	if (Alignment < XDMABDV3_MINIMUM_ALIGNMENT) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Make sure Alignment is a power of 2 */
+	if ((Alignment - 1) & Alignment) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Make sure PhysAddr and VirtAddr are on same Alignment */
+	if ((PhysAddr % Alignment) || (VirtAddr % Alignment)) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Is BdCount reasonable? */
+	if (BdCount == 0) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Parameters are sane. Stop the HW just to be safe */
+	XDmaV3_SgStop(InstancePtr);
+
+	/* Figure out how many bytes will be between the start of adjacent BDs */
+	Ring->Separation =
+		(sizeof(XDmaBdV3) + (Alignment - 1)) & ~(Alignment - 1);
+
+	/* Must make sure the ring doesn't span address 0x00000000. If it does,
+	 * then the next/prev BD traversal macros will fail.
+	 */
+	if (VirtAddr > (VirtAddr + (Ring->Separation * BdCount) - 1)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Initial ring setup:
+	 *  - Clear the entire space
+	 *  - Setup each BD's BDA field with the physical address of the next BD
+	 *  - Set each BD's DMASR.DMADONE bit
+	 */
+	memset((void *) VirtAddr, 0, (Ring->Separation * BdCount));
+
+	BdV = VirtAddr;
+	BdP = PhysAddr + Ring->Separation;
+	for (i = 1; i < BdCount; i++) {
+		XDmaV3_mWriteBd(BdV, XDMAV3_BD_BDA_OFFSET, BdP);
+		XDmaV3_mWriteBd(BdV, XDMAV3_BD_DMASR_OFFSET,
+				XDMAV3_DMASR_DMADONE_MASK);
+		XDMAV3_CACHE_FLUSH(BdV);
+		BdV += Ring->Separation;
+		BdP += Ring->Separation;
+	}
+
+	/* At the end of the ring, link the last BD back to the top */
+	XDmaV3_mWriteBd(BdV, XDMAV3_BD_BDA_OFFSET, PhysAddr);
+
+	/* Setup and initialize pointers and counters */
+	InstancePtr->BdRing.RunState = XST_DMA_SG_IS_STOPPED;
+	Ring->BaseAddr = VirtAddr;
+	Ring->PhysBaseAddr = PhysAddr;
+	Ring->HighAddr = BdV;
+	Ring->Length = Ring->HighAddr - Ring->BaseAddr + Ring->Separation;
+	Ring->AllCnt = BdCount;
+	Ring->FreeCnt = BdCount;
+	Ring->FreeHead = (XDmaBdV3 *) VirtAddr;
+	Ring->PreHead = (XDmaBdV3 *) VirtAddr;
+	Ring->HwHead = (XDmaBdV3 *) VirtAddr;
+	Ring->HwTail = (XDmaBdV3 *) VirtAddr;
+	Ring->PostHead = (XDmaBdV3 *) VirtAddr;
+	Ring->BdaRestart = (XDmaBdV3 *) PhysAddr;
+
+	/* Make sure the DMACR.SGS is 1 so that no DMA operations proceed until
+	 * the start function is called.
+	 */
+	XDMAV3_HW_SGS_SET;
+
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Clone the given BD into every BD in the list. Except for XDMAV3_BD_BDA_OFFSET,
+ * every field of the source BD is replicated in every BD of the list.
+ *
+ * This function can be called only when all BDs are in the free group such as
+ * they are immediately after initialization with XDmaV3_SgListCreate(). This
+ * prevents modification of BDs while they are in use by HW or the user.
+ *
+ * @param InstancePtr is the instance to be worked on.
+ * @param SrcBdPtr is the source BD template to be cloned into the list. This BD
+ *        will be modified.
+ *
+ * @return
+ *   - XST_SUCCESS if the list was modified.
+ *   - XST_DMA_SG_NO_LIST if a list has not been created.
+ *   - XST_DMA_SG_LIST_ERROR if some of the BDs in this channel are under HW
+ *     or user control.
+ *   - XST_DEVICE_IS_STARTED if the DMA channel has not been stopped.
+ *
+ ******************************************************************************/
+int XDmaV3_SgListClone(XDmaV3 * InstancePtr, XDmaBdV3 * SrcBdPtr)
+{
+	unsigned i;
+	u32 CurBd;
+	u32 Save;
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+
+	/* Can't do this function if there isn't a ring */
+	if (Ring->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Can't do this function with the channel running */
+	if (Ring->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Can't do this function with some of the BDs in use */
+	if (Ring->FreeCnt != Ring->AllCnt) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Modify the template by setting DMASR.DMADONE */
+	Save = XDmaV3_mReadBd(SrcBdPtr, XDMAV3_BD_DMASR_OFFSET);
+	Save |= XDMAV3_DMASR_DMADONE_MASK;
+	XDmaV3_mWriteBd(SrcBdPtr, XDMAV3_BD_DMASR_OFFSET, Save);
+
+	/* Starting from the top of the ring, save BD.Next, overwrite the entire BD
+	 * with the template, then restore BD.Next
+	 */
+	for (i = 0, CurBd = Ring->BaseAddr;
+	     i < Ring->AllCnt; i++, CurBd += Ring->Separation) {
+		Save = XDmaV3_mReadBd(CurBd, XDMAV3_BD_BDA_OFFSET);
+		memcpy((void *) CurBd, SrcBdPtr, sizeof(XDmaBdV3));
+		XDmaV3_mWriteBd(CurBd, XDMAV3_BD_BDA_OFFSET, Save);
+		XDMAV3_CACHE_FLUSH(CurBd);
+	}
+
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Reserve locations in the BD list. The set of returned BDs may be modified in
+ * preparation for future DMA transaction(s). Once the BDs are ready to be
+ * submitted to HW, the user must call XDmaV3_SgBdToHw() in the same order which
+ * they were allocated here. Example:
+ *
+ * <pre>
+ *        NumBd = 2;
+ *        Status = XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd, &MyBdSet);
+ *
+ *        if (Status != XST_SUCCESS)
+ *        {
+ *            // Not enough BDs available for the request
+ *        }
+ *
+ *        CurBd = MyBdSet;
+ *        for (i=0; i<NumBd; i++)
+ *        {
+ *            // Prepare CurBd.....
+ *
+ *            // Onto next BD
+ *            CurBd = XDmaV3_mSgBdNext(MyDmaInstPtr, CurBd);
+ *        }
+ *
+ *        // Give list to HW
+ *        Status = XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd, MyBdSet);
+ * </pre>
+ *
+ * A more advanced use of this function may allocate multiple sets of BDs.
+ * They must be allocated and given to HW in the correct sequence:
+ * <pre>
+ *        // Legal
+ *        XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd1, MySet1);
+ *
+ *        // Legal
+ *        XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd2, &MySet2);
+ *        XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd1, MySet1);
+ *        XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd2, MySet2);
+ *
+ *        // Not legal
+ *        XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdAlloc(MyDmaInstPtr, NumBd2, &MySet2);
+ *        XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd2, MySet2);
+ *        XDmaV3_SgBdToHw(MyDmaInstPtr, NumBd1, MySet1);
+ * </pre>
+ *
+ * Use the API defined in xdmabdv3.h to modify individual BDs. Traversal of the
+ * BD set can be done using XDmaV3_mSgBdNext() and XDmaV3_mSgBdPrev().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param NumBd is the number of BDs to allocate
+ * @param BdSetPtr is an output parameter, it points to the first BD available
+ *        for modification.
+ *
+ * @return
+ *   - XST_SUCCESS if the requested number of BDs was returned in the BdSetPtr
+ *     parameter.
+ *   - XST_FAILURE if there were not enough free BDs to satisfy the request.
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ * @note Do not modify more BDs than the number requested with the NumBd
+ *       parameter. Doing so will lead to data corruption and system
+ *       instability.
+ *
+ ******************************************************************************/
+int XDmaV3_SgBdAlloc(XDmaV3 * InstancePtr, unsigned NumBd, XDmaBdV3 ** BdSetPtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+
+	/* Enough free BDs available for the request? */
+	if (Ring->FreeCnt < NumBd) {
+		return (XST_FAILURE);
+	}
+
+	/* Set the return argument and move FreeHead forward */
+	*BdSetPtr = Ring->FreeHead;
+	XDMAV3_RING_SEEKAHEAD(Ring, Ring->FreeHead, NumBd);
+	Ring->FreeCnt -= NumBd;
+	Ring->PreCnt += NumBd;
+	return (XST_SUCCESS);
+}
+
+/******************************************************************************/
+/**
+ * Fully or partially undo an XDmaV3_SgBdAlloc() operation. Use this function
+ * if all the BDs allocated by XDmaV3_SgBdAlloc() could not be transferred to
+ * HW with XDmaV3_SgBdToHw().
+ *
+ * This function helps out in situations when an unrelated error occurs after
+ * BDs have been allocated but before they have been given to HW. An example of
+ * this type of error would be an OS running out of resources.
+ *
+ * This function is not the same as XDmaV3_SgBdFree(). The Free function returns
+ * BDs to the free list after they have been processed by HW, while UnAlloc
+ * returns them before being processed by HW.
+ *
+ * There are two scenarios where this function can be used. Full UnAlloc or
+ * Partial UnAlloc. A Full UnAlloc means all the BDs Alloc'd will be returned:
+ *
+ * <pre>
+ *    Status = XDmaV3_SgBdAlloc(Inst, 10, &BdPtr);
+ *        .
+ *        .
+ *    if (Error)
+ *    {
+ *        Status = XDmaV3_SgBdUnAlloc(Inst, 10, &BdPtr);
+ *    }
+ * </pre>
+ *
+ * A partial UnAlloc means some of the BDs Alloc'd will be returned:
+ *
+ * <pre>
+ *    Status = XDmaV3_SgBdAlloc(Inst, 10, &BdPtr);
+ *    BdsLeft = 10;
+ *    CurBdPtr = BdPtr;
+ *
+ *    while (BdsLeft)
+ *    {
+ *       if (Error)
+ *       {
+ *          Status = XDmaV3_SgBdUnAlloc(Inst, BdsLeft, CurBdPtr);
+ *       }
+ *
+ *       CurBdPtr = XDmaV3_SgBdNext(Inst, CurBdPtr);
+ *       BdsLeft--;
+ *    }
+ * </pre>
+ *
+ * A partial UnAlloc must include the last BD in the list that was Alloc'd.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param NumBd is the number of BDs to allocate
+ * @param BdSetPtr is an output parameter, it points to the first BD available
+ *        for modification.
+ *
+ * @return
+ *   - XST_SUCCESS if the BDs were unallocated.
+ *   - XST_FAILURE if NumBd parameter was greater that the number of BDs in the
+ *     preprocessing state.
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ ******************************************************************************/
+int XDmaV3_SgBdUnAlloc(XDmaV3 * InstancePtr, unsigned NumBd,
+		       XDmaBdV3 * BdSetPtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+
+	/* Enough BDs in the free state for the request? */
+	if (Ring->PreCnt < NumBd) {
+		return (XST_FAILURE);
+	}
+
+	/* Set the return argument and move FreeHead backward */
+	XDMAV3_RING_SEEKBACK(Ring, Ring->FreeHead, NumBd);
+	Ring->FreeCnt += NumBd;
+	Ring->PreCnt -= NumBd;
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Enqueue a set of BDs to HW that were previously allocated by
+ * XDmaV3_SgBdAlloc(). Once this function returns, the argument BD set goes
+ * under HW control. Any changes made to these BDs after this point will corrupt
+ * the BD list leading to data corruption and system instability.
+ *
+ * The set will be rejected if the last BD of the set does not mark the end of
+ * a packet (see XDmaBdV3_mSetLast()).
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param NumBd is the number of BDs in the set.
+ * @param BdSetPtr is the first BD of the set to commit to HW.
+ *
+ * @return
+ *   - XST_SUCCESS if the set of BDs was accepted and enqueued to HW.
+ *   - XST_FAILURE if the set of BDs was rejected because the last BD of the set
+ *     did not have its "last" bit set.
+ *   - XST_DMA_SG_LIST_ERROR if this function was called out of sequence with
+ *     XDmaV3_SgBdAlloc().
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ ******************************************************************************/
+int XDmaV3_SgBdToHw(XDmaV3 * InstancePtr, unsigned NumBd, XDmaBdV3 * BdSetPtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+	XDmaBdV3 *LastBdPtr;
+	unsigned i;
+	u32 Dmacr;
+	u32 Swcr;
+
+	/* Make sure we are in sync with XDmaV3_SgBdAlloc() */
+	if ((Ring->PreCnt < NumBd) || (Ring->PreHead != BdSetPtr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* For all BDs in this set (except the last one)
+	 *   - Clear DMASR except for DMASR.DMABSY
+	 *   - Clear DMACR.SGS
+	 *
+	 * For the last BD in this set
+	 *   - Clear DMASR except for DMASR.DMABSY
+	 *   - Set DMACR.SGS (marks the end of the new active list)
+	 */
+	LastBdPtr = BdSetPtr;
+	for (i = 1; i < NumBd; i++) {
+		XDmaV3_mWriteBd(LastBdPtr, XDMAV3_BD_DMASR_OFFSET,
+				XDMAV3_DMASR_DMABSY_MASK);
+
+		Dmacr = XDmaV3_mReadBd(LastBdPtr, XDMAV3_BD_DMACR_OFFSET);
+		XDmaV3_mWriteBd(LastBdPtr, XDMAV3_BD_DMACR_OFFSET,	/* DMACR.SGS = 0 */
+				Dmacr & ~XDMAV3_DMACR_SGS_MASK);
+		XDMAV3_CACHE_FLUSH(LastBdPtr);
+
+		LastBdPtr = XDmaV3_mSgBdNext(InstancePtr, LastBdPtr);
+	}
+
+	/* Last BD */
+	XDmaV3_mWriteBd(LastBdPtr, XDMAV3_BD_DMASR_OFFSET,
+			XDMAV3_DMASR_DMABSY_MASK);
+
+	Dmacr = XDmaV3_mReadBd(LastBdPtr, XDMAV3_BD_DMACR_OFFSET);
+	XDmaV3_mWriteBd(LastBdPtr, XDMAV3_BD_DMACR_OFFSET,	/* DMACR.SGS = 1 */
+			Dmacr | XDMAV3_DMACR_SGS_MASK);
+	XDMAV3_CACHE_FLUSH(LastBdPtr);
+
+	/* The last BD should have DMACR.LAST set */
+	if (!(Dmacr & XDMAV3_DMACR_LAST_MASK)) {
+		return (XST_FAILURE);
+	}
+
+	/* This set has completed pre-processing, adjust ring pointers & counters */
+	XDMAV3_RING_SEEKAHEAD(Ring, Ring->PreHead, NumBd);
+	Ring->PreCnt -= NumBd;
+
+	/* If it is running, tell the DMA engine to pause */
+	Swcr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET);
+	if (Ring->RunState == XST_DMA_SG_IS_STARTED) {
+		Swcr |= XDMAV3_SWCR_SGD_MASK;
+		XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET,
+				 Swcr);
+	}
+
+	/* Transfer control of the BDs to the DMA engine. There are two cases to
+	 * consider:
+	 *
+	 * 1) No currently active list.
+	 *    In this case, just resume the engine.
+	 *
+	 * 2) Active list.
+	 *    In this case, the last BD in the current list should have DMACR.SGS
+	 *    cleared so the engine will never stop there. The new stopping
+	 *    point is at the end of the extended list. Once the SGS bits are
+	 *    changed, resume the engine.
+	 */
+	if (Ring->HwCnt != 0) {
+		/* Handle case 2 */
+		Dmacr = XDmaV3_mReadBd(Ring->HwTail, XDMAV3_BD_DMACR_OFFSET);
+		Dmacr &= ~XDMAV3_DMACR_SGS_MASK;
+		XDmaV3_mWriteBd(Ring->HwTail, XDMAV3_BD_DMACR_OFFSET, Dmacr);
+		XDMAV3_CACHE_FLUSH(Ring->HwTail);
+	}
+
+	/* Adjust Hw pointers and counters. XDMAV3_RING_SEEKAHEAD could be used to
+	 * advance HwTail, but it will always evaluate to LastBdPtr
+	 */
+	Ring->HwTail = LastBdPtr;
+	Ring->HwCnt += NumBd;
+
+	/* If it was enabled, tell the engine to resume */
+	if (Ring->RunState == XST_DMA_SG_IS_STARTED) {
+		Swcr &= ~XDMAV3_SWCR_SGD_MASK;
+		Swcr |= XDMAV3_SWCR_SGE_MASK;
+		XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_SWCR_OFFSET,
+				 Swcr);
+	}
+
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Returns a set of BD(s) that have been processed by HW. The returned BDs may
+ * be examined to determine the outcome of the DMA transaction(s). Once the BDs
+ * have been examined, the user must call XDmaV3_SgBdFree() in the same order
+ * which they were retrieved here. Example:
+ *
+ * <pre>
+ *        MaxBd = 0xFFFFFFFF;   // Ensure we get all that are ready
+ *
+ *        NumBd = XDmaV3_SgBdFromHw(MyDmaInstPtr, MaxBd, &MyBdSet);
+ *
+ *        if (NumBd == 0)
+ *        {
+ *           // HW has nothing ready for us yet
+ *        }
+ *
+ *        CurBd = MyBdSet;
+ *        for (i=0; i<NumBd; i++)
+ *        {
+ *           // Examine CurBd for post processing.....
+ *
+ *           // Onto next BD
+ *           CurBd = XDmaV3_mSgBdNext(MyDmaInstPtr, CurBd);
+ *           }
+ *
+ *           XDmaV3_SgBdFree(MyDmaInstPtr, NumBd, MyBdSet); // Return the list
+ *        }
+ * </pre>
+ *
+ * A more advanced use of this function may allocate multiple sets of BDs.
+ * They must be retrieved from HW and freed in the correct sequence:
+ * <pre>
+ *        // Legal
+ *        XDmaV3_SgBdFromHw(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdFree(MyDmaInstPtr, NumBd1, MySet1);
+ *
+ *        // Legal
+ *        XDmaV3_SgBdFromHw(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdFromHw(MyDmaInstPtr, NumBd2, &MySet2);
+ *        XDmaV3_SgBdFree(MyDmaInstPtr, NumBd1, MySet1);
+ *        XDmaV3_SgBdFree(MyDmaInstPtr, NumBd2, MySet2);
+ *
+ *        // Not legal
+ *        XDmaV3_SgBdFromHw(MyDmaInstPtr, NumBd1, &MySet1);
+ *        XDmaV3_SgBdFromHw(MyDmaInstPtr, NumBd2, &MySet2);
+ *        XDmaV3_SgBdFree(MyDmaInstPtr, NumBd2, MySet2);
+ *        XDmaV3_SgBdFree(MyDmaInstPtr, NumBd1, MySet1);
+ * </pre>
+ *
+ * If HW has only partially completed a packet spanning multiple BDs, then none
+ * of the BDs for that packet will be included in the results.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param BdLimit is the maximum number of BDs to return in the set.
+ * @param BdSetPtr is an output parameter, it points to the first BD available
+ *        for examination.
+ *
+ * @return
+ *   The number of BDs processed by HW. A value of 0 indicates that no data
+ *   is available. No more than BdLimit BDs will be returned.
+ *
+ * @note Treat BDs returned by this function as read-only.
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ ******************************************************************************/
+unsigned XDmaV3_SgBdFromHw(XDmaV3 * InstancePtr, unsigned BdLimit,
+			   XDmaBdV3 ** BdSetPtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+	XDmaBdV3 *CurBd;
+	unsigned BdCount;
+	unsigned BdPartialCount;
+	u32 Dmasr;
+
+	CurBd = Ring->HwHead;
+	BdCount = 0;
+	BdPartialCount = 0;
+
+	/* If no BDs in work group, then there's nothing to search */
+	if (Ring->HwCnt == 0) {
+		*BdSetPtr = NULL;
+		return (0);
+	}
+
+	/* Starting at HwHead, keep moving forward in the list until:
+	 *  - A BD is encountered with its DMASR.DMABSY bit set which means HW has
+	 *    not completed processing of that BD.
+	 *  - Ring->HwTail is reached
+	 *  - The number of requested BDs has been processed
+	 */
+	while (BdCount < BdLimit) {
+		/* Read the status */
+		XDMAV3_CACHE_INVALIDATE(CurBd);
+		Dmasr = XDmaV3_mReadBd(CurBd, XDMAV3_BD_DMASR_OFFSET);
+
+		/* If the HW still hasn't processed this BD then we are done */
+		if (Dmasr & XDMAV3_DMASR_DMABSY_MASK) {
+			break;
+		}
+
+		BdCount++;
+
+		/* HW has processed this BD so check the "last" bit. If it is clear,
+		 * then there are more BDs for the current packet. Keep a count of
+		 * these partial packet BDs.
+		 */
+		if (Dmasr & XDMAV3_DMASR_LAST_MASK) {
+			BdPartialCount = 0;
+		}
+		else {
+			BdPartialCount++;
+		}
+
+		/* Reached the end of the work group */
+		if (CurBd == Ring->HwTail) {
+			break;
+		}
+
+		/* Move on to next BD in work group */
+		CurBd = XDmaV3_mSgBdNext(InstancePtr, CurBd);
+	}
+
+	/* Subtract off any partial packet BDs found */
+	BdCount -= BdPartialCount;
+
+	/* If BdCount is non-zero then BDs were found to return. Set return
+	 * parameters, update pointers and counters, return success
+	 */
+	if (BdCount) {
+		*BdSetPtr = Ring->HwHead;
+		Ring->HwCnt -= BdCount;
+		Ring->PostCnt += BdCount;
+		XDMAV3_RING_SEEKAHEAD(Ring, Ring->HwHead, BdCount);
+		return (BdCount);
+	}
+	else {
+		*BdSetPtr = NULL;
+		return (0);
+	}
+}
+
+
+/******************************************************************************/
+/**
+ * Frees a set of BDs that had been previously retrieved with XDmaV3_SgBdFromHw().
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ * @param NumBd is the number of BDs to free.
+ * @param BdSetPtr is the head of a list of BDs returned by XDmaV3_SgBdFromHw().
+ *
+ * @return
+ *   - XST_SUCCESS if the set of BDs was freed.
+ *   - XST_DMA_SG_LIST_ERROR if this function was called out of sequence with
+ *     XDmaV3_SgBdFromHw().
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ ******************************************************************************/
+int XDmaV3_SgBdFree(XDmaV3 * InstancePtr, unsigned NumBd, XDmaBdV3 * BdSetPtr)
+{
+	XDmaV3_BdRing *Ring = &InstancePtr->BdRing;
+
+	/* Make sure we are in sync with XDmaV3_SgBdFromHw() */
+	if ((Ring->PostCnt < NumBd) || (Ring->PostHead != BdSetPtr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Update pointers and counters */
+	Ring->FreeCnt += NumBd;
+	Ring->PostCnt -= NumBd;
+	XDMAV3_RING_SEEKAHEAD(Ring, Ring->PostHead, NumBd);
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************/
+/**
+ * Check the internal data structures of the BD ring for the provided channel.
+ * The following checks are made:
+ *
+ *   - Is the BD ring linked correctly in physical address space.
+ *   - Do the internal pointers point to BDs in the ring.
+ *   - Do the internal counters add up.
+ *
+ * The channel should be stopped prior to calling this function.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return
+ *   - XST_SUCCESS if the set of BDs was freed.
+ *   - XST_DMA_SG_NO_LIST if the list has not been created.
+ *   - XST_IS_STARTED if the channel is not stopped.
+ *   - XST_DMA_SG_LIST_ERROR if a problem is found with the internal data
+ *     structures. If this value is returned, the channel should be reset to
+ *     avoid data corruption or system instability.
+ *
+ * @note This function should not be preempted by another XDmaV3 function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ ******************************************************************************/
+int XDmaV3_SgCheck(XDmaV3 * InstancePtr)
+{
+	XDmaV3_BdRing *RingPtr = &InstancePtr->BdRing;
+	u32 AddrV, AddrP;
+	unsigned i;
+
+	/* Is the list created */
+	if (RingPtr->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Can't check if channel is running */
+	if (RingPtr->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_IS_STARTED);
+	}
+
+	/* RunState doesn't make sense */
+	else if (RingPtr->RunState != XST_DMA_SG_IS_STOPPED) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify internal pointers point to correct memory space */
+	AddrV = (u32) RingPtr->FreeHead;
+	if ((AddrV < RingPtr->BaseAddr) || (AddrV > RingPtr->HighAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->PreHead;
+	if ((AddrV < RingPtr->BaseAddr) || (AddrV > RingPtr->HighAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->HwHead;
+	if ((AddrV < RingPtr->BaseAddr) || (AddrV > RingPtr->HighAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->HwTail;
+	if ((AddrV < RingPtr->BaseAddr) || (AddrV > RingPtr->HighAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->PostHead;
+	if ((AddrV < RingPtr->BaseAddr) || (AddrV > RingPtr->HighAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify internal counters add up */
+	if ((RingPtr->HwCnt + RingPtr->PreCnt + RingPtr->FreeCnt +
+	     RingPtr->PostCnt) != RingPtr->AllCnt) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify BDs are linked correctly */
+	AddrV = RingPtr->BaseAddr;
+	AddrP = RingPtr->PhysBaseAddr + RingPtr->Separation;
+	for (i = 1; i < RingPtr->AllCnt; i++) {
+		/* Check BDA for this BD. It should point to next physical addr */
+		if (XDmaV3_mReadBd(AddrV, XDMAV3_BD_BDA_OFFSET) != AddrP) {
+			return (XST_DMA_SG_LIST_ERROR);
+		}
+
+		/* Move on to next BD */
+		AddrV += RingPtr->Separation;
+		AddrP += RingPtr->Separation;
+	}
+
+	/* Last BD should point back to the beginning of ring */
+	if (XDmaV3_mReadBd(AddrV, XDMAV3_BD_BDA_OFFSET) !=
+	    RingPtr->PhysBaseAddr) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* No problems found */
+	return (XST_SUCCESS);
+}
+
+
+/******************************************************************************
+ * Verify given channel is of the SGDMA variety.
+ *
+ * @param InstancePtr is a pointer to the instance to be worked on.
+ *
+ * @return
+ *   - 1 if channel is of type SGDMA
+ *   - 0 if channel is not of type SGDMA
+ ******************************************************************************/
+static int IsSgDmaChannel(XDmaV3 * InstancePtr)
+{
+	u32 Dmasr;
+
+	Dmasr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (Dmasr & (XDMAV3_DMASR_DMACNFG_SGDMARX_MASK |
+		     XDMAV3_DMASR_DMACNFG_SGDMATX_MASK |
+		     XDMAV3_DMASR_DMACNFG_SSGDMA_MASK)) {
+		return (1);
+	}
+	else {
+		return (0);
+	}
+}
diff --git a/drivers/xilinx_common/xdmav3_simple.c b/drivers/xilinx_common/xdmav3_simple.c
new file mode 100644
index 0000000..96166e6
--- /dev/null
+++ b/drivers/xilinx_common/xdmav3_simple.c
@@ -0,0 +1,124 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2006 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xdmav3_simple.c
+*
+* This file implements Simple DMA related functions. For more
+* information on this driver, see xdmav3.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 3.00a rmm  03/11/06 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xdmav3.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+* Initiate a simple DMA transfer. The BD argument sets the parameters of the
+* transfer. Since the BD is also used for SG DMA transfers, some fields of the
+* BD will be ignored. The following BD macros will have no effect on the
+* transfer:
+*
+* - XDmaBdV3_mSetLast()
+* - XDmaBdV3_mClearLast()
+* - XDmaBdV3_mSetBdPage()
+*
+* To determine when the transfer has completed, the user can poll the device
+* with XDmaV3_mGetStatus() and test the XDMAV3_DMASR_DMABSY_MASK bit, or wait for
+* an interrupt. When the DMA operation has completed, the outcome of the
+* transfer can be retrieved by calling XDmaV3_mGetStatus() and testing for DMA
+* bus errors bits.
+*
+* @param InstancePtr is a pointer to the instance to be worked on.
+* @param BdPtr sets the parameters of the transfer.
+*
+* @return
+* - XST_SUCCESS if the transfer was initated
+* - XST_DEVICE_BUSY if a transfer is already in progress
+*
+******************************************************************************/
+int XDmaV3_SimpleTransfer(XDmaV3 * InstancePtr, XDmaBdV3 * BdPtr)
+{
+	u32 Dmasr;
+
+	/* Is the channel busy */
+	Dmasr = XDmaV3_mReadReg(InstancePtr->RegBase, XDMAV3_DMASR_OFFSET);
+	if (Dmasr & (XDMAV3_DMASR_DMABSY_MASK | XDMAV3_DMASR_SGBSY_MASK)) {
+		return (XST_DEVICE_BUSY);
+	}
+
+	/* Copy BdPtr fields into the appropriate HW registers */
+
+	/* DMACR: SGS bit is set always. This is done in case the transfer
+	 * occurs on a SGDMA channel and will prevent the HW from fetching the
+	 * next BD.
+	 */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_DMACR_OFFSET,
+			 XDmaV3_mReadBd(BdPtr, XDMAV3_BD_DMACR_OFFSET)
+			 | XDMAV3_DMACR_SGS_MASK);
+
+	/* MSBA */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_MSBA_OFFSET,
+			 XDmaV3_mReadBd(BdPtr, XDMAV3_BD_MSBA_OFFSET));
+
+	/* LSBA */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_LSBA_OFFSET,
+			 XDmaV3_mReadBd(BdPtr, XDMAV3_BD_LSBA_OFFSET));
+
+	/* LENGTH: Writing this register starts HW */
+	XDmaV3_mWriteReg(InstancePtr->RegBase, XDMAV3_LENGTH_OFFSET,
+			 XDmaV3_mReadBd(BdPtr, XDMAV3_BD_LENGTH_OFFSET));
+
+	return (XST_SUCCESS);
+}
diff --git a/drivers/xilinx_common/xenv.h b/drivers/xilinx_common/xenv.h
new file mode 100644
index 0000000..45a59e9
--- /dev/null
+++ b/drivers/xilinx_common/xenv.h
@@ -0,0 +1,251 @@
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2005-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xenv_linux.h
+*
+* Defines common services specified by xenv.h.
+*
+* @note
+* 	This file is not intended to be included directly by driver code.
+* 	Instead, the generic xenv.h file is intended to be included by driver
+* 	code.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a wgr  02/28/07 Added cache handling macros.
+* 1.00a wgr  02/27/07 Simplified code. Deprecated old-style macro names.
+* 1.00a xd   11/03/04 Improved support for doxygen.
+* 1.00a ch   10/24/02 First release
+* 1.10a wgr  03/22/07 Converted to new coding style.
+* </pre>
+*
+*
+******************************************************************************/
+
+#ifndef XENV_LINUX_H
+#define XENV_LINUX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+
+#include <asm/cache.h>
+#include <asm/cacheflush.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+
+/******************************************************************************
+ *
+ * MEMCPY / MEMSET related macros.
+ *
+ * Those macros are defined to catch legacy code in Xilinx drivers. The
+ * XENV_MEM_COPY and XENV_MEM_FILL macros were used in early Xilinx driver
+ * code. They are being replaced by memcpy() and memset() function calls. These
+ * macros are defined to catch any remaining occurences of those macros.
+ *
+ ******************************************************************************/
+
+/*****************************************************************************/
+/**
+ *
+ * Copies a non-overlapping block of memory.
+ *
+ * @param	DestPtr
+ *		Destination address to copy data to.
+ *
+ * @param	SrcPtr
+ * 		Source address to copy data from.
+ *
+ * @param	Bytes
+ * 		Number of bytes to copy.
+ *
+ * @return	None.
+ *
+ *****************************************************************************/
+
+#define XENV_MEM_COPY(DestPtr, SrcPtr, Bytes) \
+		memcpy(DestPtr, SrcPtr, Bytes)
+/*		do_not_use_XENV_MEM_COPY_use_memcpy_instead */
+
+
+/*****************************************************************************/
+/**
+ *
+ * Fills an area of memory with constant data.
+ *
+ * @param	DestPtr
+ *		Destination address to copy data to.
+ *
+ * @param	Data
+ * 		Value to set.
+ *
+ * @param	Bytes
+ * 		Number of bytes to copy.
+ *
+ * @return	None.
+ *
+ *****************************************************************************/
+
+#define XENV_MEM_FILL(DestPtr, Data, Bytes) \
+		memset(DestPtr, Data, Bytes)
+/*		do_not_use_XENV_MEM_FILL_use_memset_instead */
+
+
+/******************************************************************************
+ *
+ * TIME related macros
+ *
+ ******************************************************************************/
+/**
+ * A structure that contains a time stamp used by other time stamp macros
+ * defined below. This structure is processor dependent.
+ */
+typedef int XENV_TIME_STAMP;
+
+/*****************************************************************************/
+/**
+ *
+ * Time is derived from the 64 bit PPC timebase register
+ *
+ * @param   StampPtr is the storage for the retrieved time stamp.
+ *
+ * @return  None.
+ *
+ * @note
+ *
+ * Signature: void XENV_TIME_STAMP_GET(XTIME_STAMP *StampPtr)
+ * <br><br>
+ * This macro must be implemented by the user.
+ *
+ *****************************************************************************/
+#define XENV_TIME_STAMP_GET(StampPtr)
+
+/*****************************************************************************/
+/**
+ *
+ * This macro is not yet implemented and always returns 0.
+ *
+ * @param   Stamp1Ptr is the first sampled time stamp.
+ * @param   Stamp2Ptr is the second sampled time stamp.
+ *
+ * @return  0
+ *
+ * @note
+ *
+ * This macro must be implemented by the user.
+ *
+ *****************************************************************************/
+#define XENV_TIME_STAMP_DELTA_US(Stamp1Ptr, Stamp2Ptr)     (0)
+
+/*****************************************************************************/
+/**
+ *
+ * This macro is not yet implemented and always returns 0.
+ *
+ * @param   Stamp1Ptr is the first sampled time stamp.
+ * @param   Stamp2Ptr is the second sampled time stamp.
+ *
+ * @return  0
+ *
+ * @note
+ *
+ * This macro must be implemented by the user
+ *
+ *****************************************************************************/
+#define XENV_TIME_STAMP_DELTA_MS(Stamp1Ptr, Stamp2Ptr)     (0)
+
+/*****************************************************************************/
+/**
+ *
+ * Delay the specified number of microseconds.
+ *
+ * @param	delay
+ * 		Number of microseconds to delay.
+ *
+ * @return	None.
+ *
+ * @note	XENV_USLEEP is deprecated. Use udelay() instead.
+ *
+ *****************************************************************************/
+
+#define XENV_USLEEP(delay)	udelay(delay)
+/*		do_not_use_XENV_MEM_COPY_use_memcpy_instead */
+
+
+/******************************************************************************
+ *
+ * CACHE handling macros / mappings
+ *
+ * The implementation of the cache handling functions can be found in
+ * arch/microblaze.
+ *
+ * These #defines are simple mappings to the Linux API.
+ *
+ * The underlying Linux implementation will take care of taking the right
+ * actions depending on the configuration of the MicroBlaze processor in the
+ * system.
+ *
+ ******************************************************************************/
+
+#define XCACHE_ENABLE_DCACHE()		__enable_dcache()
+#define XCACHE_DISABLE_DCACHE()		__disable_dcache()
+#define XCACHE_ENABLE_ICACHE()		__enable_icache()
+#define XCACHE_DISABLE_ICACHE()		__disable_icache()
+
+#define XCACHE_INVALIDATE_DCACHE_RANGE(Addr, Len) \
+        invalidate_dcache_range((unsigned long)(Addr), ((unsigned long)(Addr)+(Len)))
+#define XCACHE_FLUSH_DCACHE_RANGE(Addr, Len)      \
+        flush_dcache_range((unsigned long)(Addr), ((unsigned long)(Addr)+(Len)))
+
+#define XCACHE_INVALIDATE_ICACHE_RANGE(Addr, Len) "XCACHE_INVALIDATE_ICACHE_RANGE unsupported"
+#define XCACHE_FLUSH_ICACHE_RANGE(Addr, Len)      flush_icache_range(Addr, Len)
+
+#define XCACHE_ENABLE_CACHE()	\
+		{ XCACHE_ENABLE_DCACHE(); XCACHE_ENABLE_ICACHE(); }
+
+#define XCACHE_DISABLE_CACHE()	\
+		{ XCACHE_DISABLE_DCACHE(); XCACHE_DISABLE_ICACHE(); }
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif            /* end of protection macro */
+
diff --git a/drivers/xilinx_common/xil_assert.c b/drivers/xilinx_common/xil_assert.c
new file mode 100644
index 0000000..9e38cf1
--- /dev/null
+++ b/drivers/xilinx_common/xil_assert.c
@@ -0,0 +1,148 @@
+/******************************************************************************
+*
+*
+* (c) Copyright 2009 Xilinx, Inc. All rights reserved. 
+*     This program is free software; you can redistribute it and/or modify 
+*     it under the terms of the GNU General Public License as published by 
+*     the Free Software Foundation; either version 2 of the License, or (at 
+*     your option) any later version. 
+*
+*     You should have received a copy of the GNU General Public License 
+*     along with this program; if not, write to the Free Software 
+*     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
+*     MA  02110-1301  USA
+*
+* This file contains confidential and proprietary information of Xilinx, Inc.
+* and is protected under U.S. and international copyright and other
+* intellectual property laws.
+*
+* DISCLAIMER
+* This disclaimer is not a license and does not grant any rights to the
+* materials distributed herewith. Except as otherwise provided in a valid
+* license issued to you by Xilinx, and to the maximum extent permitted by
+* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
+* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
+* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
+* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
+* and (2) Xilinx shall not be liable (whether in contract or tort, including
+* negligence, or under any other theory of liability) for any loss or damage
+* of any kind or nature related to, arising under or in connection with these
+* materials, including for any direct, or any indirect, special, incidental,
+* or consequential loss or damage (including loss of data, profits, goodwill,
+* or any type of loss or damage suffered as a result of any action brought by
+* a third party) even if such damage or loss was reasonably foreseeable or
+* Xilinx had been advised of the possibility of the same.
+*
+* CRITICAL APPLICATIONS
+* Xilinx products are not designed or intended to be fail-safe, or for use in
+* any application requiring fail-safe performance, such as life-support or
+* safety devices or systems, Class III medical devices, nuclear facilities,
+* applications related to the deployment of airbags, or any other applications
+* that could lead to death, personal injury, or severe property or
+* environmental damage (individually and collectively, "Critical
+* Applications"). Customer assumes the sole risk and liability of any use of
+* Xilinx products in Critical Applications, subject only to applicable laws
+* and regulations governing limitations on product liability.
+*
+* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
+* AT ALL TIMES.
+*
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_assert.c
+*
+* This file contains basic assert related functions for Xilinx software IP.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 Initial release
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xil_types.h"
+#include "xil_assert.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Variable Definitions *****************************/
+
+/**
+ * This variable allows testing to be done easier with asserts. An assert
+ * sets this variable such that a driver can evaluate this variable
+ * to determine if an assert occurred.
+ */
+unsigned int Xil_AssertStatus;
+
+/**
+ * This variable allows the assert functionality to be changed for testing
+ * such that it does not wait infinitely. Use the debugger to disable the
+ * waiting during testing of asserts.
+ */
+int Xil_AssertWait = TRUE;
+
+/* The callback function to be invoked when an assert is taken */
+static Xil_AssertCallback Xil_AssertCallbackRoutine = NULL;
+
+/************************** Function Prototypes ******************************/
+
+/*****************************************************************************/
+/**
+*
+* Implement assert. Currently, it calls a user-defined callback function
+* if one has been set.  Then, it potentially enters an infinite loop depending
+* on the value of the Xil_AssertWait variable.
+*
+* @param    file is the name of the filename of the source
+* @param    line is the linenumber within File
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void Xil_Assert(char *File, int Line)
+{
+	/* if the callback has been set then invoke it */
+	if (Xil_AssertCallbackRoutine != 0) {
+		(*Xil_AssertCallbackRoutine)(File, Line);
+	}
+
+	/* if specified, wait indefinitely such that the assert will show up
+	 * in testing
+	 */
+	while (Xil_AssertWait) {
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* Set up a callback function to be invoked when an assert occurs. If there
+* was already a callback installed, then it is replaced.
+*
+* @param    routine is the callback to be invoked when an assert is taken
+*
+* @return   None.
+*
+* @note     This function has no effect if NDEBUG is set
+*
+******************************************************************************/
+void Xil_AssertSetCallback(Xil_AssertCallback Routine)
+{
+	Xil_AssertCallbackRoutine = Routine;
+}
+
+
diff --git a/drivers/xilinx_common/xil_assert.h b/drivers/xilinx_common/xil_assert.h
new file mode 100644
index 0000000..3759498
--- /dev/null
+++ b/drivers/xilinx_common/xil_assert.h
@@ -0,0 +1,204 @@
+/******************************************************************************
+*
+* (c) Copyright 2009 Xilinx, Inc. All rights reserved. 
+*     This program is free software; you can redistribute it and/or modify 
+*     it under the terms of the GNU General Public License as published by 
+*     the Free Software Foundation; either version 2 of the License, or (at 
+*     your option) any later version. 
+*
+*     You should have received a copy of the GNU General Public License 
+*     along with this program; if not, write to the Free Software 
+*     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
+*     MA  02110-1301  USA
+*
+* This file contains confidential and proprietary information of Xilinx, Inc.
+* and is protected under U.S. and international copyright and other
+* intellectual property laws.
+*
+* DISCLAIMER
+* This disclaimer is not a license and does not grant any rights to the
+* materials distributed herewith. Except as otherwise provided in a valid
+* license issued to you by Xilinx, and to the maximum extent permitted by
+* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
+* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
+* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
+* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
+* and (2) Xilinx shall not be liable (whether in contract or tort, including
+* negligence, or under any other theory of liability) for any loss or damage
+* of any kind or nature related to, arising under or in connection with these
+* materials, including for any direct, or any indirect, special, incidental,
+* or consequential loss or damage (including loss of data, profits, goodwill,
+* or any type of loss or damage suffered as a result of any action brought by
+* a third party) even if such damage or loss was reasonably foreseeable or
+* Xilinx had been advised of the possibility of the same.
+*
+* CRITICAL APPLICATIONS
+* Xilinx products are not designed or intended to be fail-safe, or for use in
+* any application requiring fail-safe performance, such as life-support or
+* safety devices or systems, Class III medical devices, nuclear facilities,
+* applications related to the deployment of airbags, or any other applications
+* that could lead to death, personal injury, or severe property or
+* environmental damage (individually and collectively, "Critical
+* Applications"). Customer assumes the sole risk and liability of any use of
+* Xilinx products in Critical Applications, subject only to applicable laws
+* and regulations governing limitations on product liability.
+*
+* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
+* AT ALL TIMES.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_assert.h
+*
+* This file contains assert related functions.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_ASSERT_H	/* prevent circular inclusions */
+#define XIL_ASSERT_H	/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+
+
+/************************** Constant Definitions *****************************/
+
+#define XIL_ASSERT_NONE     0
+#define XIL_ASSERT_OCCURRED 1
+
+extern unsigned int Xil_AssertStatus;
+extern void Xil_Assert(char *, int);
+
+
+/**
+ * This data type defines a callback to be invoked when an
+ * assert occurs. The callback is invoked only when asserts are enabled
+ */
+typedef void (*Xil_AssertCallback) (char *File, int Line);
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+#ifndef NDEBUG
+
+/*****************************************************************************/
+/**
+* This assert macro is to be used for functions that do not return anything
+* (void). This in conjunction with the Xil_AssertWait boolean can be used to
+* accomodate tests so that asserts which fail allow execution to continue.
+*
+* @param    expression is the expression to evaluate. If it evaluates to
+*           false, the assert occurs.
+*
+* @return   Returns void unless the Xil_AssertWait variable is true, in which
+*           case no return is made and an infinite loop is entered.
+*
+* @note     None.
+*
+******************************************************************************/
+#define Xil_AssertVoid(Expression)                \
+{                                                  \
+    if (Expression) {                              \
+        Xil_AssertStatus = XIL_ASSERT_NONE;       \
+    } else {                                       \
+        Xil_Assert(__FILE__, __LINE__);            \
+        Xil_AssertStatus = XIL_ASSERT_OCCURRED;   \
+        return;                                    \
+    }                                              \
+}
+
+/*****************************************************************************/
+/**
+* This assert macro is to be used for functions that do return a value. This in
+* conjunction with the Xil_AssertWait boolean can be used to accomodate tests
+* so that asserts which fail allow execution to continue.
+*
+* @param    expression is the expression to evaluate. If it evaluates to false,
+*           the assert occurs.
+*
+* @return   Returns 0 unless the Xil_AssertWait variable is true, in which
+* 	    case no return is made and an infinite loop is entered.
+*
+* @note     None.
+*
+******************************************************************************/
+#define Xil_AssertNonvoid(Expression)             \
+{                                                  \
+    if (Expression) {                              \
+        Xil_AssertStatus = XIL_ASSERT_NONE;       \
+    } else {                                       \
+        Xil_Assert(__FILE__, __LINE__);            \
+        Xil_AssertStatus = XIL_ASSERT_OCCURRED;   \
+        return 0;                                  \
+    }                                              \
+}
+
+/*****************************************************************************/
+/**
+* Always assert. This assert macro is to be used for functions that do not
+* return anything (void). Use for instances where an assert should always
+* occur.
+*
+* @return Returns void unless the Xil_AssertWait variable is true, in which
+*	  case no return is made and an infinite loop is entered.
+*
+* @note   None.
+*
+******************************************************************************/
+#define Xil_AssertVoidAlways()                   \
+{                                                  \
+   Xil_Assert(__FILE__, __LINE__);                 \
+   Xil_AssertStatus = XIL_ASSERT_OCCURRED;        \
+   return;                                         \
+}
+
+/*****************************************************************************/
+/**
+* Always assert. This assert macro is to be used for functions that do return
+* a value. Use for instances where an assert should always occur.
+*
+* @return Returns void unless the Xil_AssertWait variable is true, in which
+*	  case no return is made and an infinite loop is entered.
+*
+* @note   None.
+*
+******************************************************************************/
+#define Xil_AssertNonvoidAlways()                \
+{                                                  \
+   Xil_Assert(__FILE__, __LINE__);                 \
+   Xil_AssertStatus = XIL_ASSERT_OCCURRED;        \
+   return 0;                                       \
+}
+
+
+#else
+
+#define Xil_AssertVoid(Expression)
+#define Xil_AssertVoidAlways()
+#define Xil_AssertNonvoid(Expression)
+#define Xil_AssertNonvoidAlways()
+
+#endif
+
+/************************** Function Prototypes ******************************/
+
+void Xil_AssertSetCallback(Xil_AssertCallback Routine);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* end of protection macro */
diff --git a/drivers/xilinx_common/xil_io.h b/drivers/xilinx_common/xil_io.h
new file mode 100644
index 0000000..fb2d7dd
--- /dev/null
+++ b/drivers/xilinx_common/xil_io.h
@@ -0,0 +1,121 @@
+/******************************************************************************
+*
+* (c) Copyright 2009 Xilinx, Inc. All rights reserved.
+*     This program is free software; you can redistribute it and/or modify
+*     it under the terms of the GNU General Public License as published by
+*     the Free Software Foundation; either version 2 of the License, or (at
+*     your option) any later version.
+*
+*     You should have received a copy of the GNU General Public License
+*     along with this program; if not, write to the Free Software
+*     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+*     MA  02110-1301  USA
+*
+* This file contains confidential and proprietary information of Xilinx, Inc.
+* and is protected under U.S. and international copyright and other
+* intellectual property laws.
+*
+* DISCLAIMER
+* This disclaimer is not a license and does not grant any rights to the
+* materials distributed herewith. Except as otherwise provided in a valid
+* license issued to you by Xilinx, and to the maximum extent permitted by
+* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
+* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
+* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
+* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
+* and (2) Xilinx shall not be liable (whether in contract or tort, including
+* negligence, or under any other theory of liability) for any loss or damage
+* of any kind or nature related to, arising under or in connection with these
+* materials, including for any direct, or any indirect, special, incidental,
+* or consequential loss or damage (including loss of data, profits, goodwill,
+* or any type of loss or damage suffered as a result of any action brought by
+* a third party) even if such damage or loss was reasonably foreseeable or
+* Xilinx had been advised of the possibility of the same.
+*
+* CRITICAL APPLICATIONS
+* Xilinx products are not designed or intended to be fail-safe, or for use in
+* any application requiring fail-safe performance, such as life-support or
+* safety devices or systems, Class III medical devices, nuclear facilities,
+* applications related to the deployment of airbags, or any other applications
+* that could lead to death, personal injury, or severe property or
+* environmental damage (individually and collectively, "Critical
+* Applications"). Customer assumes the sole risk and liability of any use of
+* Xilinx products in Critical Applications, subject only to applicable laws
+* and regulations governing limitations on product liability.
+*
+* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
+* AT ALL TIMES.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_io.h
+*
+* This file contains IO functions for Xilinx OCP in terms of Linux primitives.
+*
+******************************************************************************/
+#ifndef XIL_IO_H
+#define XIL_IO_H
+
+#include "xil_types.h"
+#include <asm/io.h>
+
+extern inline u8
+Xil_In8(u32 InAddress)
+{
+	return (u8) in_8((volatile unsigned char *) InAddress);
+}
+extern inline u16
+Xil_In16(u32 InAddress)
+{
+	return (u16) in_be16((volatile unsigned short *) InAddress);
+}
+extern inline u32
+Xil_In32(u32 InAddress)
+{
+	return (u32) in_be32((volatile unsigned *) InAddress);
+}
+extern inline void
+Xil_Out8(u32 OutAddress, u8 Value)
+{
+	out_8((volatile unsigned char *) OutAddress, Value);
+}
+extern inline void
+Xil_Out16(u32 OutAddress, u16 Value)
+{
+	out_be16((volatile unsigned short *) OutAddress, Value);
+}
+extern inline void
+Xil_Out32(u32 OutAddress, u32 Value)
+{
+	out_be32((volatile unsigned *) OutAddress, Value);
+}
+extern inline u16
+Xil_In16LE(u32 Addr)
+{
+	u16 Value;
+
+	__asm__ volatile ("eieio; lhbrx %0,0,%1":"=r" (Value):"b" (Addr));
+	return Value;
+}
+extern inline u32
+Xil_In32LE(u32 Addr)
+{
+	u32 Value;
+
+	__asm__ volatile ("eieio; lwbrx %0,0,%1":"=r" (Value):"b" (Addr));
+	return Value;
+}
+extern inline void
+Xil_Out16LE(u32 Addr, u16 Value)
+{
+	__asm__ volatile ("sthbrx %0,0,%1; eieio"::"r" (Value), "b"(Addr));
+}
+extern inline void
+Xil_Out32LE(u32 Addr, u32 Value)
+{
+	__asm__ volatile ("stwbrx %0,0,%1; eieio"::"r" (Value), "b"(Addr));
+}
+
+#endif /* XIL_IO_H */
diff --git a/drivers/xilinx_common/xil_types.h b/drivers/xilinx_common/xil_types.h
new file mode 100644
index 0000000..7e7ab2b
--- /dev/null
+++ b/drivers/xilinx_common/xil_types.h
@@ -0,0 +1,128 @@
+/******************************************************************************
+*
+* (c) Copyright 2009 Xilinx, Inc. All rights reserved. 
+*     This program is free software; you can redistribute it and/or modify 
+*     it under the terms of the GNU General Public License as published by 
+*     the Free Software Foundation; either version 2 of the License, or (at 
+*     your option) any later version. 
+*
+*     You should have received a copy of the GNU General Public License 
+*     along with this program; if not, write to the Free Software 
+*     Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, 
+*     MA  02110-1301  USA
+*
+* This file contains confidential and proprietary information of Xilinx, Inc.
+* and is protected under U.S. and international copyright and other
+* intellectual property laws.
+*
+* DISCLAIMER
+* This disclaimer is not a license and does not grant any rights to the
+* materials distributed herewith. Except as otherwise provided in a valid
+* license issued to you by Xilinx, and to the maximum extent permitted by
+* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
+* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
+* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
+* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
+* and (2) Xilinx shall not be liable (whether in contract or tort, including
+* negligence, or under any other theory of liability) for any loss or damage
+* of any kind or nature related to, arising under or in connection with these
+* materials, including for any direct, or any indirect, special, incidental,
+* or consequential loss or damage (including loss of data, profits, goodwill,
+* or any type of loss or damage suffered as a result of any action brought by
+* a third party) even if such damage or loss was reasonably foreseeable or
+* Xilinx had been advised of the possibility of the same.
+*
+* CRITICAL APPLICATIONS
+* Xilinx products are not designed or intended to be fail-safe, or for use in
+* any application requiring fail-safe performance, such as life-support or
+* safety devices or systems, Class III medical devices, nuclear facilities,
+* applications related to the deployment of airbags, or any other applications
+* that could lead to death, personal injury, or severe property or
+* environmental damage (individually and collectively, "Critical
+* Applications"). Customer assumes the sole risk and liability of any use of
+* Xilinx products in Critical Applications, subject only to applicable laws
+* and regulations governing limitations on product liability.
+*
+* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
+* AT ALL TIMES.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xil_types.h
+*
+* This file contains basic types for Xilinx software IP.
+
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a hbm  07/14/09 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIL_TYPES_H	/* prevent circular inclusions */
+#define XIL_TYPES_H	/* by using protection macros */
+
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#  define TRUE		1
+#endif
+
+#ifndef FALSE
+#  define FALSE		0
+#endif
+
+#ifndef NULL
+#define NULL		0
+#endif
+
+#define XIL_COMPONENT_IS_READY     0x11111111  /**< component has been initialized */
+#define XIL_COMPONENT_IS_STARTED   0x22222222  /**< component has been started */
+
+/** @name New types
+ * New simple types.
+ * @{
+ */
+#ifndef __KERNEL__
+#ifndef XBASIC_TYPES_H
+/**
+ * guarded against xbasic_types.h.
+ */
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned long u32;
+#endif
+/**
+ * xbasic_types.h does not typedef u64
+ */
+typedef unsigned long long u64;
+#else
+#include <linux/types.h>
+#endif
+
+
+/*@}*/
+
+
+/************************** Constant Definitions *****************************/
+
+#ifndef TRUE
+#define TRUE		1
+#endif
+
+#ifndef FALSE
+#define FALSE		0
+#endif
+
+#ifndef NULL
+#define NULL		0
+#endif
+
+#endif	/* end of protection macro */
diff --git a/drivers/xilinx_common/xilinx_syms.c b/drivers/xilinx_common/xilinx_syms.c
new file mode 100644
index 0000000..192d702
--- /dev/null
+++ b/drivers/xilinx_common/xilinx_syms.c
@@ -0,0 +1,74 @@
+/*
+ * xilinx_syms.c
+ *
+ * This file EXPORT_SYMBOL_GPL's all of the Xilinx entry points.
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * 2002 (c) MontaVista, Software, Inc.  This file is licensed under the terms
+ * of the GNU General Public License version 2.  This program is licensed
+ * "as is" without any warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+
+#include "xbasic_types.h"
+EXPORT_SYMBOL_GPL(XAssert);
+EXPORT_SYMBOL_GPL(XAssertSetCallback);
+EXPORT_SYMBOL_GPL(XAssertStatus);
+extern u32 XWaitInAssert;
+EXPORT_SYMBOL_GPL(XWaitInAssert);
+
+#include "xdma_channel.h"
+EXPORT_SYMBOL_GPL(XDmaChannel_CommitPuts);
+EXPORT_SYMBOL_GPL(XDmaChannel_CreateSgList);
+EXPORT_SYMBOL_GPL(XDmaChannel_DecrementPktCount);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetControl);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetDescriptor);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetIntrEnable);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetIntrStatus);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetPktCount);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetPktThreshold);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetPktWaitBound);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetStatus);
+EXPORT_SYMBOL_GPL(XDmaChannel_GetVersion);
+EXPORT_SYMBOL_GPL(XDmaChannel_Initialize);
+EXPORT_SYMBOL_GPL(XDmaChannel_IsReady);
+EXPORT_SYMBOL_GPL(XDmaChannel_IsSgListEmpty);
+EXPORT_SYMBOL_GPL(XDmaChannel_PutDescriptor);
+EXPORT_SYMBOL_GPL(XDmaChannel_Reset);
+EXPORT_SYMBOL_GPL(XDmaChannel_SelfTest);
+EXPORT_SYMBOL_GPL(XDmaChannel_SetControl);
+EXPORT_SYMBOL_GPL(XDmaChannel_SetIntrEnable);
+EXPORT_SYMBOL_GPL(XDmaChannel_SetIntrStatus);
+EXPORT_SYMBOL_GPL(XDmaChannel_SetPktThreshold);
+EXPORT_SYMBOL_GPL(XDmaChannel_SetPktWaitBound);
+EXPORT_SYMBOL_GPL(XDmaChannel_SgStart);
+EXPORT_SYMBOL_GPL(XDmaChannel_SgStop);
+EXPORT_SYMBOL_GPL(XDmaChannel_Transfer);
+
+#include "xipif_v1_23_b.h"
+//EXPORT_SYMBOL_GPL(XIpIfV123b_SelfTest);
+
+#include "xpacket_fifo_v2_00_a.h"
+EXPORT_SYMBOL_GPL(XPacketFifoV200a_Initialize);
+EXPORT_SYMBOL_GPL(XPacketFifoV200a_Read);
+EXPORT_SYMBOL_GPL(XPacketFifoV200a_SelfTest);
+EXPORT_SYMBOL_GPL(XPacketFifoV200a_Write);
+
+#include "xio.h"
+EXPORT_SYMBOL_GPL(XIo_Out8);
+EXPORT_SYMBOL_GPL(XIo_In8);
+EXPORT_SYMBOL_GPL(XIo_Out16);
+EXPORT_SYMBOL_GPL(XIo_In16);
+EXPORT_SYMBOL_GPL(XIo_Out32);
+EXPORT_SYMBOL_GPL(XIo_In32);
+
+#include "xversion.h"
+EXPORT_SYMBOL_GPL(XVersion_Copy);
+EXPORT_SYMBOL_GPL(XVersion_FromString);
+EXPORT_SYMBOL_GPL(XVersion_IsEqual);
+EXPORT_SYMBOL_GPL(XVersion_Pack);
+EXPORT_SYMBOL_GPL(XVersion_ToString);
+EXPORT_SYMBOL_GPL(XVersion_UnPack);
diff --git a/drivers/xilinx_common/xio.c b/drivers/xilinx_common/xio.c
new file mode 100644
index 0000000..49a755d
--- /dev/null
+++ b/drivers/xilinx_common/xio.c
@@ -0,0 +1,519 @@
+/* $Id: xio.c,v 1.5 2007/07/24 22:01:35 xduan Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xio.c
+*
+* Contains I/O functions for memory-mapped or non-memory-mapped I/O
+* architectures.  These functions encapsulate PowerPC architecture-specific
+* I/O requirements.
+*
+* @note
+*
+* This file contains architecture-dependent code.
+*
+* The order of the SYNCHRONIZE_IO and the read or write operation is
+* important. For the Read operation, all I/O needs to complete prior
+* to the desired read to insure valid data from the address. The PPC
+* is a weakly ordered I/O model and reads can and will occur prior
+* to writes and the SYNCHRONIZE_IO ensures that any writes occur prior
+* to the read. For the Write operation the SYNCHRONIZE_IO occurs
+* after the desired write to ensure that the address is updated with
+* the new value prior to any subsequent read.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- --------------------------------------------------------
+* 1.00a ecm  10/18/05 initial release
+*                     needs to be updated to replace eieio with mbar when
+*                     compilers support this mnemonic.
+*
+* 1.00a ecm  01/24/07 update for new coding standard.
+* 1.10a xd   07/24/07 Corrected the format in asm functions in __DCC__ mode.
+* </pre>
+******************************************************************************/
+
+
+/***************************** Include Files *********************************/
+#include "xio.h"
+#include "xbasic_types.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+/*****************************************************************************/
+/**
+*
+* Performs a 16-bit endian converion.
+*
+* @param    Source contains the value to be converted.
+* @param    DestPtr contains a pointer to the location to put the
+*           converted value.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void OutSwap16(u16 Source, u16 *DestPtr)
+{
+    *DestPtr = (u16) (((Source & 0xFF00) >> 8) | ((Source & 0x00FF) << 8));
+}
+
+u16 InSwap16(u16 *DestPtr)
+{
+    u16 Source = *DestPtr;
+   return (u16) (((Source & 0xFF00) >> 8) | ((Source & 0x00FF) << 8));
+}
+/*****************************************************************************/
+/**
+*
+* Performs a 32-bit endian converion.
+*
+* @param    Source contains the value to be converted.
+* @param    DestPtr contains a pointer to the location to put the
+*           converted value.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void OutSwap32(u32 Source, u32 *DestPtr)
+{
+
+    /* get each of the half words from the 32 bit word */
+
+    u16 LoWord = (u16) (Source & 0x0000FFFF);
+    u16 HiWord = (u16) ((Source & 0xFFFF0000) >> 16);
+
+    /* byte swap each of the 16 bit half words */
+
+    LoWord = (((LoWord & 0xFF00) >> 8) | ((LoWord & 0x00FF) << 8));
+    HiWord = (((HiWord & 0xFF00) >> 8) | ((HiWord & 0x00FF) << 8));
+
+    /* swap the half words before returning the value */
+
+    *DestPtr = (u32) ((LoWord << 16) | HiWord);
+}
+
+u32 InSwap32(u32 *DestPtr)
+{
+   /* get each of the half words from the 32 bit word */
+    u32 Source = *DestPtr;
+
+    u16 LoWord = (u16) (Source & 0x0000FFFF);
+    u16 HiWord = (u16) ((Source & 0xFFFF0000) >> 16);
+
+    /* byte swap each of the 16 bit half words */
+
+    LoWord = (((LoWord & 0xFF00) >> 8) | ((LoWord & 0x00FF) << 8));
+    HiWord = (((HiWord & 0xFF00) >> 8) | ((HiWord & 0x00FF) << 8));
+
+    /* swap the half words before returning the value */
+
+    return (u32) ((LoWord << 16) | HiWord);
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an input operation for an 8-bit memory location by reading from the
+* specified address and returning the value read from that address.
+*
+* @param    InAddress contains the address to perform the input operation at.
+*
+* @return
+*
+* The value read from the specified input address.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+    u8 XIo_In8(XIo_Address InAddress)
+{
+    /* read the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#if defined CONFIG_PPC
+
+    u8 IoContents;
+    __asm__ volatile ("eieio; lbz %0,0(%1)":"=r" (IoContents):"b"
+              (InAddress));
+    return IoContents;
+
+#else
+
+    SYNCHRONIZE_IO;
+    return *(u8 *) InAddress;
+
+#endif
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an input operation for a 16-bit memory location by reading from the
+* specified address and returning the value read from that address.
+*
+* @param    InAddress contains the address to perform the input operation at.
+*
+* @return
+*
+* The value read from the specified input address.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u16 XIo_In16(XIo_Address InAddress)
+{
+    /* read the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#if defined CONFIG_PPC
+
+    u16 IoContents;
+    __asm__ volatile ("eieio; lhz %0,0(%1)":"=r" (IoContents):"b"
+              (InAddress));
+    return IoContents;
+
+#else
+
+    SYNCHRONIZE_IO;
+    return *(u16 *) InAddress;
+
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an input operation for a 32-bit memory location by reading from the
+* specified address and returning the value read from that address.
+*
+* @param    InAddress contains the address to perform the input operation at.
+*
+* @return
+*
+* The value read from the specified input address.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XIo_In32(XIo_Address InAddress)
+{
+    /* read the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#ifdef CONFIG_PPC
+
+    u32 IoContents;
+    __asm__ volatile ("eieio; lwz %0,0(%1)":"=r" (IoContents):"b"
+              (InAddress));
+    return IoContents;
+
+#else
+
+    SYNCHRONIZE_IO;
+    return *(u32 *) InAddress;
+
+#endif
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an input operation for a 16-bit memory location by reading from the
+* specified address and returning the byte-swapped value read from that
+* address.
+*
+* @param    InAddress contains the address to perform the input operation at.
+*
+* @return
+*
+* The byte-swapped value read from the specified input address.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u16 XIo_InSwap16(XIo_Address InAddress)
+{
+    /* read the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+#ifdef CONFIG_PPC
+    u16 IoContents;
+
+    __asm__ volatile ("eieio; lhbrx %0,0,%1":"=r" (IoContents):"b"
+              (InAddress));
+    return IoContents;
+#else
+    return InSwap16(InAddress);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an input operation for a 32-bit memory location by reading from the
+* specified address and returning the byte-swapped value read from that
+* address.
+*
+* @param    InAddress contains the address to perform the input operation at.
+*
+* @return
+*
+* The byte-swapped value read from the specified input address.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XIo_InSwap32(XIo_Address InAddress)
+{
+    /* read the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+#ifdef CONFIG_PPC
+    u32 IoContents;
+
+    __asm__ volatile ("eieio; lwbrx %0,0,%1":"=r" (IoContents):"b"
+              (InAddress));
+    return IoContents;
+#else
+    return InSwap32(InAddress);
+#endif
+
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Performs an output operation for an 8-bit memory location by writing the
+* specified value to the the specified address.
+*
+* @param    OutAddress contains the address to perform the output operation at.
+* @param    Value contains the value to be output at the specified address.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XIo_Out8(XIo_Address OutAddress, u8 Value)
+{
+    /* write the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#ifdef CONFIG_PPC
+
+    __asm__ volatile ("stb %0,0(%1); eieio"::"r" (Value), "b"(OutAddress));
+
+#else
+
+    *(volatile u8 *) OutAddress = Value;
+    SYNCHRONIZE_IO;
+
+#endif
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an output operation for a 16-bit memory location by writing the
+* specified value to the the specified address.
+*
+* @param    OutAddress contains the address to perform the output operation at.
+* @param    Value contains the value to be output at the specified address.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XIo_Out16(XIo_Address OutAddress, u16 Value)
+{
+    /* write the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#ifdef CONFIG_PPC
+
+    __asm__ volatile ("sth %0,0(%1); eieio"::"r" (Value), "b"(OutAddress));
+
+#else
+
+    *(volatile u16 *) OutAddress = Value;
+    SYNCHRONIZE_IO;
+
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an output operation for a 32-bit memory location by writing the
+* specified value to the the specified address.
+*
+* @param    OutAddress contains the address to perform the output operation at.
+* @param    Value contains the value to be output at the specified address.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XIo_Out32(XIo_Address OutAddress, u32 Value)
+{
+    /* write the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+
+#ifdef CONFIG_PPC
+
+    __asm__ volatile ("stw %0,0(%1); eieio"::"r" (Value), "b"(OutAddress));
+
+#else
+
+    *(volatile u32 *) OutAddress = Value;
+    SYNCHRONIZE_IO;
+
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an output operation for a 16-bit memory location by writing the
+* specified value to the the specified address. The value is byte-swapped
+* before being written.
+*
+* @param    OutAddress contains the address to perform the output operation at.
+* @param    Value contains the value to be output at the specified address.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XIo_OutSwap16(XIo_Address OutAddress, u16 Value)
+{
+    /* write the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+#ifdef CONFIG_PPC
+    __asm__ volatile ("sthbrx %0,0,%1; eieio"::"r" (Value),
+              "b"(OutAddress));
+#else
+    OutSwap16(OutAddress, Value);
+#endif
+}
+
+/*****************************************************************************/
+/**
+*
+* Performs an output operation for a 32-bit memory location by writing the
+* specified value to the the specified address. The value is byte-swapped
+* before being written.
+*
+* @param    OutAddress contains the address to perform the output operation at.
+* @param    Value contains the value to be output at the specified address.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XIo_OutSwap32(XIo_Address OutAddress, u32 Value)
+{
+    /* write the contents of the I/O location and then synchronize the I/O
+     * such that the I/O operation completes before proceeding on
+     */
+#ifdef CONFIG_PPC
+    __asm__ volatile ("stwbrx %0,0,%1; eieio"::"r" (Value),
+              "b"(OutAddress));
+#else
+    OutSwap32(OutAddress, Value);
+#endif
+}
diff --git a/drivers/xilinx_common/xio.h b/drivers/xilinx_common/xio.h
new file mode 100644
index 0000000..466b0b0
--- /dev/null
+++ b/drivers/xilinx_common/xio.h
@@ -0,0 +1,209 @@
+/* $Id: xio.h,v 1.4 2007/07/24 22:01:35 xduan Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xio.h
+*
+* This file contains the interface for the XIo component, which encapsulates
+* the Input/Output functions for the PowerPC architecture.
+* This header file needs to be updated to replace eieio with mbar when
+* compilers support the mbar mnemonic.
+*
+* @note
+*
+* This file contains architecture-dependent items (memory mapped or non memory
+* mapped I/O).
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- --------------------------------------------------------
+* 1.00a ecm  10/18/05 initial release
+*                     needs to be updated to replace eieio with mbar when
+*                     compilers support this mnemonic.
+*
+* 1.00a ecm  01/24/07 update for new coding standard.
+* 1.10a xd   07/24/07 Corrected the format in asm functions in __DCC__ mode.
+* </pre>
+******************************************************************************/
+
+#ifndef XIO_H           /* prevent circular inclusions */
+#define XIO_H           /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * Typedef for an I/O address.  Typically correlates to the width of the
+ * address bus.
+ */
+typedef u32 XIo_Address;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/* The following macro is specific to the GNU compiler and PowerPC family. It
+ * performs an EIEIO instruction such that I/O operations are synced correctly.
+ * This macro is not necessarily portable across compilers since it uses
+ * inline assembly.
+ */
+#ifdef CONFIG_PPC
+#  define SYNCHRONIZE_IO __asm__ volatile ("eieio") /* should be 'mbar' ultimately */
+#else
+#  define SYNCHRONIZE_IO
+#endif
+
+/* The following macros allow the software to be transportable across
+ * processors which use big or little endian memory models.
+ *
+ * Defined first are processor-specific endian conversion macros specific to
+ * the GNU compiler and the PowerPC family, as well as a no-op endian conversion
+ * macro. These macros are not to be used directly by software. Instead, the
+ * XIo_To/FromLittleEndianXX and XIo_To/FromBigEndianXX macros below are to be
+ * used to allow the endian conversion to only be performed when necessary
+ */
+
+#define XIo_EndianNoop(Source, DestPtr)    (*DestPtr = Source)
+
+#ifdef CONFIG_PPC
+
+#define XIo_EndianSwap16(Source, DestPtr)  __asm__ __volatile__(\
+                                           "sthbrx %0,0,%1\n"\
+                                           : : "r" (Source), "r" (DestPtr)\
+                                           )
+
+#define XIo_EndianSwap32(Source, DestPtr)  __asm__ __volatile__(\
+                                           "stwbrx %0,0,%1\n"\
+                                           : : "r" (Source), "r" (DestPtr)\
+                                           )
+#else
+
+#define XIo_EndianSwap16(Source, DestPtr) \
+{\
+   u16 src = (Source); \
+   u16 *destptr = (DestPtr); \
+   *destptr = src >> 8; \
+   *destptr |= (src << 8); \
+}
+
+#define XIo_EndianSwap32(Source, DestPtr) \
+{\
+   u32 src = (Source); \
+   u32 *destptr = (DestPtr); \
+   *destptr = src >> 24; \
+   *destptr |= ((src >> 8)  & 0x0000FF00); \
+   *destptr |= ((src << 8)  & 0x00FF0000); \
+   *destptr |= ((src << 24) & 0xFF000000); \
+}
+
+#endif
+
+// #ifdef XLITTLE_ENDIAN
+// /* little-endian processor */
+
+// #define XIo_ToLittleEndian16                XIo_EndianNoop
+// #define XIo_ToLittleEndian32                XIo_EndianNoop
+// #define XIo_FromLittleEndian16              XIo_EndianNoop
+// #define XIo_FromLittleEndian32              XIo_EndianNoop
+
+// #define XIo_ToBigEndian16(Source, DestPtr)  XIo_EndianSwap16(Source, DestPtr)
+// #define XIo_ToBigEndian32(Source, DestPtr)  XIo_EndianSwap32(Source, DestPtr)
+// #define XIo_FromBigEndian16                 XIo_ToBigEndian16
+// #define XIo_FromBigEndian32                 XIo_ToBigEndian32
+
+// #else
+/* big-endian processor */ // ppc or microblaze
+
+#define XIo_ToLittleEndian16(Source, DestPtr) XIo_EndianSwap16(Source, DestPtr)
+#define XIo_ToLittleEndian32(Source, DestPtr) XIo_EndianSwap32(Source, DestPtr)
+#define XIo_FromLittleEndian16                XIo_ToLittleEndian16
+#define XIo_FromLittleEndian32                XIo_ToLittleEndian32
+
+#define XIo_ToBigEndian16                     XIo_EndianNoop
+#define XIo_ToBigEndian32                     XIo_EndianNoop
+#define XIo_FromBigEndian16                   XIo_EndianNoop
+#define XIo_FromBigEndian32                   XIo_EndianNoop
+
+// #endif
+
+
+/************************** Function Prototypes ******************************/
+
+/* The following macros allow optimized I/O operations for memory mapped I/O
+ * Note that the SYNCHRONIZE_IO may be moved by the compiler during
+ * optimization.
+ */
+
+u8 XIo_In8(XIo_Address InAddress);
+u16 XIo_In16(XIo_Address InAddress);
+u32 XIo_In32(XIo_Address InAddress);
+
+void XIo_Out8(XIo_Address OutAddress, u8 Value);
+void XIo_Out16(XIo_Address OutAddress, u16 Value);
+void XIo_Out32(XIo_Address OutAddress, u32 Value);
+
+
+/*
+#define XIo_In8(InputPtr)  (*(volatile u8  *)(InputPtr)); SYNCHRONIZE_IO;
+#define XIo_In16(InputPtr) (*(volatile u16 *)(InputPtr)); SYNCHRONIZE_IO;
+#define XIo_In32(InputPtr) (*(volatile u32 *)(InputPtr)); SYNCHRONIZE_IO;
+
+#define XIo_Out8(OutputPtr, Value)  \
+    { (*(volatile u8  *)(OutputPtr) = Value); SYNCHRONIZE_IO; }
+#define XIo_Out16(OutputPtr, Value) \
+    { (*(volatile u16 *)(OutputPtr) = Value); SYNCHRONIZE_IO; }
+#define XIo_Out32(OutputPtr, Value) \
+    { (*(volatile u32 *)(OutputPtr) = Value); SYNCHRONIZE_IO; }
+ */
+
+/* The following functions handle IO addresses where data must be swapped
+ * They cannot be implemented as macros
+ */
+u16 XIo_InSwap16(XIo_Address InAddress);
+u32 XIo_InSwap32(XIo_Address InAddress);
+void XIo_OutSwap16(XIo_Address OutAddress, u16 Value);
+void XIo_OutSwap32(XIo_Address OutAddress, u32 Value);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xio_dcr.c b/drivers/xilinx_common/xio_dcr.c
new file mode 100644
index 0000000..ffafb89
--- /dev/null
+++ b/drivers/xilinx_common/xio_dcr.c
@@ -0,0 +1,520 @@
+/* $Id: xio_dcr.c,v 1.9 2007/01/24 17:00:16 meinelte Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xio_dcr.c
+*
+* The implementation of the XDcrIo interface. See xio_dcr.h for more
+* information about the component.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a ecm  11/09/06 Modified from the PPC405 version to use the indirect
+*                     addressing that is available in the PPC440 block in V5.
+*                     Removed the jump table structure in xio_dcr.c also.
+*                     Added functionality from the SEG driver to allow for
+*                     one file pair.
+* 1.00a ecm  01/02/07 Incorporated changes from testing with multiple DCR
+*                     masters, discovered and fixed several concurrency
+*                     issues.
+* 1.00a ecm  01/24/07 update for new coding standard.
+* </pre>
+*
+* @internal
+*
+* The C functions which subsequently call into either the assembly code or into
+* the provided table of functions are required since the registers assigned to
+* the calling and return from functions are strictly defined in the ABI and that
+* definition is used in the low-level functions directly. The use of macros is
+* not recommended since the temporary registers in the ABI are defined but there
+* is no way to force the compiler to use a specific register in a block of code.
+*
+*****************************************************************************/
+
+/***************************** Include Files ********************************/
+
+#include <asm/dcr.h>
+#include <asm/reg.h>
+
+#include "xstatus.h"
+#include "xbasic_types.h"
+#include "xio.h"
+#include "xio_dcr.h"
+
+/************************** Constant Definitions ****************************/
+
+/*
+ * base address defines for each of the four possible DCR base
+ * addresses a processor can have
+ */
+#define XDCR_0_BASEADDR 0x000
+#define XDCR_1_BASEADDR 0x100
+#define XDCR_2_BASEADDR 0x200
+#define XDCR_3_BASEADDR 0x300
+
+
+#define MAX_DCR_REGISTERS           4096
+#define MAX_DCR_REGISTER            MAX_DCR_REGISTERS - 1
+#define MIN_DCR_REGISTER            0
+
+/**************************** Type Definitions ******************************/
+
+
+/***************** Macros (Inline Functions) Definitions ********************/
+
+/************************** Variable Definitions ****************************/
+
+
+
+/************************** Function Prototypes *****************************/
+
+/*****************************************************************************/
+/**
+*
+* Outputs value provided to specified register defined in the header file.
+*
+* @param    DcrRegister is the intended destination DCR register
+* @param    Data is the value to be placed into the specified DCR register
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+****************************************************************************/
+void XIo_DcrOut(u32 DcrRegister, u32 Data)
+{
+    /*
+     * Assert validates the register number
+     */
+    XASSERT_VOID(DcrRegister < MAX_DCR_REGISTERS);
+
+    /*
+     * pass the call on to the proper function
+     */
+    XIo_mDcrIndirectAddrWriteReg(XDCR_0_BASEADDR, DcrRegister, Data);
+}
+
+/*****************************************************************************/
+/**
+*
+* Reads value from specified register.
+*
+* @param    DcrRegister is the intended source DCR register
+*
+* @return
+*
+* Contents of the specified DCR register.
+*
+* @note
+*
+* None.
+*
+****************************************************************************/
+u32 XIo_DcrIn(u32 DcrRegister)
+{
+    /*
+     * Assert validates the register number
+     */
+    XASSERT_NONVOID(DcrRegister < MAX_DCR_REGISTERS);
+
+    /*
+     * pass the call on to the proper function
+     */
+    return (XIo_mDcrIndirectAddrReadReg(XDCR_0_BASEADDR, DcrRegister));
+}
+
+/*****************************************************************************/
+/**
+*
+* Reads the value of the specified register using the indirect access method.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended destination DCR register
+*
+* @return
+*
+* Contents of the specified DCR register.
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+u32 XIo_DcrReadReg(u32 DcrBase, u32 DcrRegister)
+{
+    switch (DcrBase) {
+    case 0x000:
+        return XIo_mDcrIndirectAddrReadReg(XDCR_0_BASEADDR,
+                           DcrRegister);
+    case 0x100:
+        return XIo_mDcrIndirectAddrReadReg(XDCR_1_BASEADDR,
+                           DcrRegister);
+    case 0x200:
+        return XIo_mDcrIndirectAddrReadReg(XDCR_2_BASEADDR,
+                           DcrRegister);
+    case 0x300:
+        return XIo_mDcrIndirectAddrReadReg(XDCR_3_BASEADDR,
+                           DcrRegister);
+    default:
+        return XIo_mDcrIndirectAddrReadReg(XDCR_0_BASEADDR,
+                           DcrRegister);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Writes the value to the specified register using the indirect access method.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended destination DCR register
+* @param    Data is the value to be placed into the specified DCR register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+void XIo_DcrWriteReg(u32 DcrBase, u32 DcrRegister, u32 Data)
+{
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrIndirectAddrWriteReg(XDCR_0_BASEADDR, DcrRegister,
+                         Data);
+        return;
+    case 0x100:
+        XIo_mDcrIndirectAddrWriteReg(XDCR_1_BASEADDR, DcrRegister,
+                         Data);
+        return;
+    case 0x200:
+        XIo_mDcrIndirectAddrWriteReg(XDCR_2_BASEADDR, DcrRegister,
+                         Data);
+        return;
+    case 0x300:
+        XIo_mDcrIndirectAddrWriteReg(XDCR_3_BASEADDR, DcrRegister,
+                         Data);
+        return;
+    default:
+        XIo_mDcrIndirectAddrWriteReg(XDCR_0_BASEADDR, DcrRegister,
+                         Data);
+        return;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Explicitly acquires and release DCR lock--Auto-Lock is disabled.
+* Reads the value of the specified register using the indirect access method.
+* This function is provided because the most common usecase is to enable
+* Auto-Lock. Checking for Auto-Lock in every indirect access would defeat the
+* purpose of having Auto-Lock.
+* Auto-Lock can only be enable/disabled in hardware.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended destination DCR register
+*
+* @return
+*
+* Contents of the specified DCR register.
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+u32 XIo_DcrLockAndReadReg(u32 DcrBase, u32 DcrRegister)
+{
+    unsigned int rVal;
+
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        rVal = XIo_mDcrIndirectAddrReadReg(XDCR_0_BASEADDR,
+                           DcrRegister);
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+    case 0x100:
+        XIo_mDcrLock(XDCR_1_BASEADDR);
+        rVal = XIo_mDcrIndirectAddrReadReg(XDCR_1_BASEADDR,
+                           DcrRegister);
+        XIo_mDcrUnlock(XDCR_1_BASEADDR);
+    case 0x200:
+        XIo_mDcrLock(XDCR_2_BASEADDR);
+        rVal = XIo_mDcrIndirectAddrReadReg(XDCR_2_BASEADDR,
+                           DcrRegister);
+        XIo_mDcrUnlock(XDCR_2_BASEADDR);
+    case 0x300:
+        XIo_mDcrLock(XDCR_3_BASEADDR);
+        rVal = XIo_mDcrIndirectAddrReadReg(XDCR_3_BASEADDR,
+                           DcrRegister);
+        XIo_mDcrUnlock(XDCR_3_BASEADDR);
+    default:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        rVal = XIo_mDcrIndirectAddrReadReg(XDCR_0_BASEADDR,
+                           DcrRegister);
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+    }
+    return rVal;
+}
+
+/*****************************************************************************/
+/**
+*
+* Explicitly acquires and release DCR lock--Auto-Lock is disabled.
+* Writes the value to the specified register using the indirect access method.
+* This function is provided because the most common usecase is to enable
+* Auto-Lock. Checking for Auto-Lock in every indirect access would defeat the
+* purpose of having Auto-Lock.
+* Auto-Lock can only be enable/disabled in hardware.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended destination DCR register
+* @param    Data is the value to be placed into the specified DCR register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+void XIo_DcrLockAndWriteReg(u32 DcrBase, u32 DcrRegister, u32 Data)
+{
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        XIo_mDcrIndirectAddrWriteReg(XDCR_0_BASEADDR, DcrRegister,
+                         Data);
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+        return;
+    case 0x100:
+        XIo_mDcrLock(XDCR_1_BASEADDR);
+        XIo_mDcrIndirectAddrWriteReg(XDCR_1_BASEADDR, DcrRegister,
+                         Data);
+        XIo_mDcrUnlock(XDCR_1_BASEADDR);
+        return;
+    case 0x200:
+        XIo_mDcrLock(XDCR_2_BASEADDR);
+        XIo_mDcrIndirectAddrWriteReg(XDCR_2_BASEADDR, DcrRegister,
+                         Data);
+        XIo_mDcrUnlock(XDCR_2_BASEADDR);
+        return;
+    case 0x300:
+        XIo_mDcrLock(XDCR_3_BASEADDR);
+        XIo_mDcrIndirectAddrWriteReg(XDCR_3_BASEADDR, DcrRegister,
+                         Data);
+        XIo_mDcrUnlock(XDCR_3_BASEADDR);
+        return;
+    default:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        XIo_mDcrIndirectAddrWriteReg(XDCR_0_BASEADDR, DcrRegister,
+                         Data);
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+        return;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Read APU UDI DCR via indirect addressing.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the desired APU UDI register
+*
+* @return
+*
+* Contents of the specified APU register.
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+u32 XIo_DcrReadAPUUDIReg(u32 DcrBase, short UDInum)
+{
+    switch (DcrBase) {
+    case 0x000:
+        return XIo_mDcrIndirectAddrReadAPUUDIReg(XDCR_0_BASEADDR,
+                             UDInum);
+    case 0x100:
+        return XIo_mDcrIndirectAddrReadAPUUDIReg(XDCR_1_BASEADDR,
+                             UDInum);
+    case 0x200:
+        return XIo_mDcrIndirectAddrReadAPUUDIReg(XDCR_2_BASEADDR,
+                             UDInum);
+    case 0x300:
+        return XIo_mDcrIndirectAddrReadAPUUDIReg(XDCR_3_BASEADDR,
+                             UDInum);
+    default:
+        return XIo_mDcrIndirectAddrReadAPUUDIReg(XDCR_0_BASEADDR,
+                             UDInum);
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Writes the value to the APU UDI DCR using the indirect access method.
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the intended destination APU register
+* @param    Data is the value to be placed into the specified APU register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* Uses the indirect addressing method available in V5 with PPC440.
+*
+****************************************************************************/
+void XIo_DcrWriteAPUUDIReg(u32 DcrBase, short UDInum, u32 Data)
+{
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrIndirectAddrWriteAPUUDIReg(XDCR_0_BASEADDR, UDInum,
+                           Data);
+        return;
+    case 0x100:
+        XIo_mDcrIndirectAddrWriteAPUUDIReg(XDCR_1_BASEADDR, UDInum,
+                           Data);
+        return;
+    case 0x200:
+        XIo_mDcrIndirectAddrWriteAPUUDIReg(XDCR_2_BASEADDR, UDInum,
+                           Data);
+        return;
+    case 0x300:
+        XIo_mDcrIndirectAddrWriteAPUUDIReg(XDCR_3_BASEADDR, UDInum,
+                           Data);
+        return;
+    default:
+        XIo_mDcrIndirectAddrWriteAPUUDIReg(XDCR_0_BASEADDR, UDInum,
+                           Data);
+        return;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Locks DCR bus via the Global Status/Control register.
+*
+* @param    DcrBase is the base of the block of DCR registers
+*
+* @return
+*
+* None
+*
+* @note
+*
+* Care must be taken to not write a '1' to either timeout bit because
+* it will be cleared. The internal PPC440 can clear both timeout bits but an
+* external DCR master can only clear the external DCR master's timeout bit.
+*
+* Only available in V5 with PPC440.
+*
+****************************************************************************/
+void XIo_DcrLock(u32 DcrBase)
+{
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        return;
+    case 0x100:
+        XIo_mDcrLock(XDCR_1_BASEADDR);
+        return;
+    case 0x200:
+        XIo_mDcrLock(XDCR_2_BASEADDR);
+        return;
+    case 0x300:
+        XIo_mDcrLock(XDCR_3_BASEADDR);
+        return;
+    default:
+        XIo_mDcrLock(XDCR_0_BASEADDR);
+        return;
+    }
+}
+
+/*****************************************************************************/
+/**
+*
+* Unlocks DCR bus via the Global Status/Control register.
+*
+* @param    DcrBase is the base of the block of DCR registers
+*
+* @return
+*
+* None
+*
+* @note
+*
+* Care must be taken to not write a '1' to either timeout bit because
+* it will be cleared. The internal PPC440 can clear both timeout bits but an
+* external DCR master can only clear the external DCR master's timeout bit.
+*
+* Only available in V5 with PPC440.
+*
+****************************************************************************/
+void XIo_DcrUnlock(u32 DcrBase)
+{
+    switch (DcrBase) {
+    case 0x000:
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+        return;
+    case 0x100:
+        XIo_mDcrUnlock(XDCR_1_BASEADDR);
+        return;
+    case 0x200:
+        XIo_mDcrUnlock(XDCR_2_BASEADDR);
+        return;
+    case 0x300:
+        XIo_mDcrUnlock(XDCR_3_BASEADDR);
+        return;
+    default:
+        XIo_mDcrUnlock(XDCR_0_BASEADDR);
+        return;
+    }
+}
diff --git a/drivers/xilinx_common/xio_dcr.h b/drivers/xilinx_common/xio_dcr.h
new file mode 100644
index 0000000..817a54d
--- /dev/null
+++ b/drivers/xilinx_common/xio_dcr.h
@@ -0,0 +1,701 @@
+/* $Id: xio_dcr.h,v 1.8 2007/01/24 17:00:16 meinelte Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xio_dcr.h
+*
+* The DCR I/O access functions.
+*
+* @note
+*
+* These access functions are specific to the PPC440 CPU. Changes might be
+* necessary for other members of the IBM PPC Family.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.00a ecm  10/18/05 First release
+*                     Need to verify opcodes for mt/mfdcr remain the same.
+* 1.00a ecm  11/09/06 Modified from the PPC405 version to use the indirect
+*                     addressing that is available in the PPC440 block in V5.
+*                     Removed the jump table structure in xio_dcr.c also.
+*                     Added functionality from the SEG driver to allow for
+*                     one file pair.
+* 1.00a ecm  01/02/07 Incorporated changes from testing with multiple DCR
+*                     masters, discovered and fixed several concurrency
+*                     issues.
+* 1.00a ecm  01/24/07 update for new coding standard.
+* </pre>
+*
+* @internal
+*
+* This code WILL NOT FUNCTION on the PPC405 based architectures, V2P and V4.
+*
+******************************************************************************/
+
+#ifndef XDCRIO_H        /* prevent circular inclusions */
+#define XDCRIO_H        /* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+#include "xbasic_types.h"
+
+/************************** Constant Definitions *****************************/
+/*
+ *   256 internal DCR registers
+ *   Base address: 2 most signifcant bits of 10-bit addr taken from
+ *                 the C_DCRBASEADDR parameter of the processor block.
+ *   Offset: 8 least significant bits
+ */
+/* register base addresses */
+
+#define XDCR_APU_BASE   0x04
+#define XDCR_MIB_BASE   0x10
+#define XDCR_XB_BASE    0x20
+#define XDCR_PLBS0_BASE 0x34
+#define XDCR_PLBS1_BASE 0x44
+#define XDCR_PLBM_BASE  0x54
+#define XDCR_DMA0_BASE  0x80
+#define XDCR_DMA1_BASE  0x98
+#define XDCR_DMA2_BASE  0xB0
+#define XDCR_DMA3_BASE  0xC8
+
+/* register offsets */
+/* global registers 0x00-0x02 */
+
+#define XDCR_IDA_ADDR     0x00
+#define XDCR_IDA_ACC      0x01
+#define XDCR_CTRLCFGSTAT  0x02
+
+/* Auxiliary Processor Unit Controller (APU) 0x04-0x05 */
+
+#define XDCR_APU_UDI  (XDCR_APU_BASE+0x00)
+#define XDCR_APU_CTRL (XDCR_APU_BASE+0x01)
+
+/* Memory Interface Bridge (MIB) 0x10-0x13 */
+
+#define XDCR_MIB_CTRL (XDCR_MIB_BASE+0x00)
+#define XDCR_MIB_RCON (XDCR_MIB_BASE+0x01)
+#define XDCR_MIB_BCON (XDCR_MIB_BASE+0x02)
+
+/* Crossbar (XB) 0x20-0x33 */
+
+#define XDCR_XB_IST      (XDCR_XB_BASE+0x00)
+#define XDCR_XB_IMASK    (XDCR_XB_BASE+0x01)
+#define XDCR_XB_ARBCFGX  (XDCR_XB_BASE+0x03)
+#define XDCR_XB_FIFOSTX  (XDCR_XB_BASE+0x04)
+#define XDCR_XB_SMSTX    (XDCR_XB_BASE+0x05)
+#define XDCR_XB_MISCX    (XDCR_XB_BASE+0x06)
+#define XDCR_XB_ARBCFGM  (XDCR_XB_BASE+0x08)
+#define XDCR_XB_FIFOSTM  (XDCR_XB_BASE+0x09)
+#define XDCR_XB_SMSTM    (XDCR_XB_BASE+0x0A)
+#define XDCR_XB_MISCM    (XDCR_XB_BASE+0x0B)
+#define XDCR_XB_TMPL0MAP (XDCR_XB_BASE+0x0D)
+#define XDCR_XB_TMPL1MAP (XDCR_XB_BASE+0x0E)
+#define XDCR_XB_TMPL2MAP (XDCR_XB_BASE+0x0F)
+#define XDCR_XB_TMPL3MAP (XDCR_XB_BASE+0x10)
+#define XDCR_XB_TMPLSEL  (XDCR_XB_BASE+0x11)
+
+/* PLB Slave DCR offsets only */
+
+#define XDCR_PLBS_CFG        0x00
+#define XDCR_PLBS_SEARU      0x02
+#define XDCR_PLBS_SEARL      0x03
+#define XDCR_PLBS_SESR       0x04
+#define XDCR_PLBS_MISCST     0x05
+#define XDCR_PLBS_PLBERRST   0x06
+#define XDCR_PLBS_SMST       0x07
+#define XDCR_PLBS_MISC       0x08
+#define XDCR_PLBS_CMDSNIFF   0x09
+#define XDCR_PLBS_CMDSNIFFA  0x0A
+#define XDCR_PLBS_TMPL0MAP   0x0C
+#define XDCR_PLBS_TMPL1MAP   0x0D
+#define XDCR_PLBS_TMPL2MAP   0x0E
+#define XDCR_PLBS_TMPL3MAP   0x0F
+
+/* PLB Slave 0 (PLBS0) 0x34-0x43 */
+
+#define XDCR_PLBS0_CFG       (XDCR_PLBS0_BASE+0x00)
+#define XDCR_PLBS0_CNT       (XDCR_PLBS0_BASE+0x01)
+#define XDCR_PLBS0_SEARU     (XDCR_PLBS0_BASE+0x02)
+#define XDCR_PLBS0_SEARL     (XDCR_PLBS0_BASE+0x03)
+#define XDCR_PLBS0_SESR      (XDCR_PLBS0_BASE+0x04)
+#define XDCR_PLBS0_MISCST    (XDCR_PLBS0_BASE+0x05)
+#define XDCR_PLBS0_PLBERRST  (XDCR_PLBS0_BASE+0x06)
+#define XDCR_PLBS0_SMST      (XDCR_PLBS0_BASE+0x07)
+#define XDCR_PLBS0_MISC      (XDCR_PLBS0_BASE+0x08)
+#define XDCR_PLBS0_CMDSNIFF  (XDCR_PLBS0_BASE+0x09)
+#define XDCR_PLBS0_CMDSNIFFA (XDCR_PLBS0_BASE+0x0A)
+#define XDCR_PLBS0_TMPL0MAP  (XDCR_PLBS0_BASE+0x0C)
+#define XDCR_PLBS0_TMPL1MAP  (XDCR_PLBS0_BASE+0x0D)
+#define XDCR_PLBS0_TMPL2MAP  (XDCR_PLBS0_BASE+0x0E)
+#define XDCR_PLBS0_TMPL3MAP  (XDCR_PLBS0_BASE+0x0F)
+
+/* PLB Slave 1 (PLBS1) 0x44-0x53 */
+
+#define XDCR_PLBS1_CFG       (XDCR_PLBS1_BASE+0x00)
+#define XDCR_PLBS1_CNT       (XDCR_PLBS1_BASE+0x01)
+#define XDCR_PLBS1_SEARU     (XDCR_PLBS1_BASE+0x02)
+#define XDCR_PLBS1_SEARL     (XDCR_PLBS1_BASE+0x03)
+#define XDCR_PLBS1_SESR      (XDCR_PLBS1_BASE+0x04)
+#define XDCR_PLBS1_MISCST    (XDCR_PLBS1_BASE+0x05)
+#define XDCR_PLBS1_PLBERRST  (XDCR_PLBS1_BASE+0x06)
+#define XDCR_PLBS1_SMST      (XDCR_PLBS1_BASE+0x07)
+#define XDCR_PLBS1_MISC      (XDCR_PLBS1_BASE+0x08)
+#define XDCR_PLBS1_CMDSNIFF  (XDCR_PLBS1_BASE+0x09)
+#define XDCR_PLBS1_CMDSNIFFA (XDCR_PLBS1_BASE+0x0A)
+#define XDCR_PLBS1_TMPL0MAP  (XDCR_PLBS1_BASE+0x0C)
+#define XDCR_PLBS1_TMPL1MAP  (XDCR_PLBS1_BASE+0x0D)
+#define XDCR_PLBS1_TMPL2MAP  (XDCR_PLBS1_BASE+0x0E)
+#define XDCR_PLBS1_TMPL3MAP  (XDCR_PLBS1_BASE+0x0F)
+
+/* PLB Master (PLBM) 0x54-0x5F */
+
+#define XDCR_PLBM_CFG       (XDCR_PLBM_BASE+0x00)
+#define XDCR_PLBM_CNT       (XDCR_PLBM_BASE+0x01)
+#define XDCR_PLBM_FSEARU    (XDCR_PLBM_BASE+0x02)
+#define XDCR_PLBM_FSEARL    (XDCR_PLBM_BASE+0x03)
+#define XDCR_PLBM_FSESR     (XDCR_PLBM_BASE+0x04)
+#define XDCR_PLBM_MISCST    (XDCR_PLBM_BASE+0x05)
+#define XDCR_PLBM_PLBERRST  (XDCR_PLBM_BASE+0x06)
+#define XDCR_PLBM_SMST      (XDCR_PLBM_BASE+0x07)
+#define XDCR_PLBM_MISC      (XDCR_PLBM_BASE+0x08)
+#define XDCR_PLBM_CMDSNIFF  (XDCR_PLBM_BASE+0x09)
+#define XDCR_PLBM_CMDSNIFFA (XDCR_PLBM_BASE+0x0A)
+
+/* DMA Controller DCR offsets only */
+#define XDCR_DMA_TXNXTDESCPTR   0x00
+#define XDCR_DMA_TXCURBUFADDR   0x01
+#define XDCR_DMA_TXCURBUFLEN    0x02
+#define XDCR_DMA_TXCURDESCPTR   0x03
+#define XDCR_DMA_TXTAILDESCPTR  0x04
+#define XDCR_DMA_TXCHANNELCTRL  0x05
+#define XDCR_DMA_TXIRQ          0x06
+#define XDCR_DMA_TXSTATUS       0x07
+#define XDCR_DMA_RXNXTDESCPTR   0x08
+#define XDCR_DMA_RXCURBUFADDR   0x09
+#define XDCR_DMA_RXCURBUFLEN    0x0A
+#define XDCR_DMA_RXCURDESCPTR   0x0B
+#define XDCR_DMA_RXTAILDESCPTR  0x0C
+#define XDCR_DMA_RXCHANNELCTRL  0x0D
+#define XDCR_DMA_RXIRQ          0x0E
+#define XDCR_DMA_RXSTATUS       0x0F
+#define XDCR_DMA_CTRL           0x10
+
+/* DMA Controller 0 (DMA0) 0x80-0x90 */
+
+#define XDCR_DMA0_TXNXTDESCPTR  (XDCR_DMA0_BASE+0x00)
+#define XDCR_DMA0_TXCURBUFADDR  (XDCR_DMA0_BASE+0x01)
+#define XDCR_DMA0_TXCURBUFLEN   (XDCR_DMA0_BASE+0x02)
+#define XDCR_DMA0_TXCURDESCPTR  (XDCR_DMA0_BASE+0x03)
+#define XDCR_DMA0_TXTAILDESCPTR (XDCR_DMA0_BASE+0x04)
+#define XDCR_DMA0_TXCHANNELCTRL (XDCR_DMA0_BASE+0x05)
+#define XDCR_DMA0_TXIRQ         (XDCR_DMA0_BASE+0x06)
+#define XDCR_DMA0_TXSTATUS      (XDCR_DMA0_BASE+0x07)
+#define XDCR_DMA0_RXNXTDESCPTR  (XDCR_DMA0_BASE+0x08)
+#define XDCR_DMA0_RXCURBUFADDR  (XDCR_DMA0_BASE+0x09)
+#define XDCR_DMA0_RXCURBUFLEN   (XDCR_DMA0_BASE+0x0A)
+#define XDCR_DMA0_RXCURDESCPTR  (XDCR_DMA0_BASE+0x0B)
+#define XDCR_DMA0_RXTAILDESCPTR (XDCR_DMA0_BASE+0x0C)
+#define XDCR_DMA0_RXCHANNELCTRL (XDCR_DMA0_BASE+0x0D)
+#define XDCR_DMA0_RXIRQ         (XDCR_DMA0_BASE+0x0E)
+#define XDCR_DMA0_RXSTATUS      (XDCR_DMA0_BASE+0x0F)
+#define XDCR_DMA0_CTRL          (XDCR_DMA0_BASE+0x10)
+
+/* DMA Controller 1 (DMA1) 0x98-0xA8 */
+
+#define XDCR_DMA1_TXNXTDESCPTR  (XDCR_DMA1_BASE+0x00)
+#define XDCR_DMA1_TXCURBUFADDR  (XDCR_DMA1_BASE+0x01)
+#define XDCR_DMA1_TXCURBUFLEN   (XDCR_DMA1_BASE+0x02)
+#define XDCR_DMA1_TXCURDESCPTR  (XDCR_DMA1_BASE+0x03)
+#define XDCR_DMA1_TXTAILDESCPTR (XDCR_DMA1_BASE+0x04)
+#define XDCR_DMA1_TXCHANNELCTRL (XDCR_DMA1_BASE+0x05)
+#define XDCR_DMA1_TXIRQ         (XDCR_DMA1_BASE+0x06)
+#define XDCR_DMA1_TXSTATUS      (XDCR_DMA1_BASE+0x07)
+#define XDCR_DMA1_RXNXTDESCPTR  (XDCR_DMA1_BASE+0x08)
+#define XDCR_DMA1_RXCURBUFADDR  (XDCR_DMA1_BASE+0x09)
+#define XDCR_DMA1_RXCURBUFLEN   (XDCR_DMA1_BASE+0x0A)
+#define XDCR_DMA1_RXCURDESCPTR  (XDCR_DMA1_BASE+0x0B)
+#define XDCR_DMA1_RXTAILDESCPTR (XDCR_DMA1_BASE+0x0C)
+#define XDCR_DMA1_RXCHANNELCTRL (XDCR_DMA1_BASE+0x0D)
+#define XDCR_DMA1_RXIRQ         (XDCR_DMA1_BASE+0x0E)
+#define XDCR_DMA1_RXSTATUS      (XDCR_DMA1_BASE+0x0F)
+#define XDCR_DMA1_CTRL          (XDCR_DMA1_BASE+0x10)
+
+/* DMA Controller 2 (DMA2) 0xB0-0xC0 */
+
+#define XDCR_DMA2_TXNXTDESCPTR  (XDCR_DMA2_BASE+0x00)
+#define XDCR_DMA2_TXCURBUFADDR  (XDCR_DMA2_BASE+0x01)
+#define XDCR_DMA2_TXCURBUFLEN   (XDCR_DMA2_BASE+0x02)
+#define XDCR_DMA2_TXCURDESCPTR  (XDCR_DMA2_BASE+0x03)
+#define XDCR_DMA2_TXTAILDESCPTR (XDCR_DMA2_BASE+0x04)
+#define XDCR_DMA2_TXCHANNELCTRL (XDCR_DMA2_BASE+0x05)
+#define XDCR_DMA2_TXIRQ         (XDCR_DMA2_BASE+0x06)
+#define XDCR_DMA2_TXSTATUS      (XDCR_DMA2_BASE+0x07)
+#define XDCR_DMA2_RXNXTDESCPTR  (XDCR_DMA2_BASE+0x08)
+#define XDCR_DMA2_RXCURBUFADDR  (XDCR_DMA2_BASE+0x09)
+#define XDCR_DMA2_RXCURBUFLEN   (XDCR_DMA2_BASE+0x0A)
+#define XDCR_DMA2_RXCURDESCPTR  (XDCR_DMA2_BASE+0x0B)
+#define XDCR_DMA2_RXTAILDESCPTR (XDCR_DMA2_BASE+0x0C)
+#define XDCR_DMA2_RXCHANNELCTRL (XDCR_DMA2_BASE+0x0D)
+#define XDCR_DMA2_RXIRQ         (XDCR_DMA2_BASE+0x0E)
+#define XDCR_DMA2_RXSTATUS      (XDCR_DMA2_BASE+0x0F)
+#define XDCR_DMA2_CTRL          (XDCR_DMA2_BASE+0x10)
+
+/* DMA Controller 3 (DMA3) 0xC8-0xD8 */
+
+#define XDCR_DMA3_TXNXTDESCPTR  (XDCR_DMA3_BASE+0x00)
+#define XDCR_DMA3_TXCURBUFADDR  (XDCR_DMA3_BASE+0x01)
+#define XDCR_DMA3_TXCURBUFLEN   (XDCR_DMA3_BASE+0x02)
+#define XDCR_DMA3_TXCURDESCPTR  (XDCR_DMA3_BASE+0x03)
+#define XDCR_DMA3_TXTAILDESCPTR (XDCR_DMA3_BASE+0x04)
+#define XDCR_DMA3_TXCHANNELCTRL (XDCR_DMA3_BASE+0x05)
+#define XDCR_DMA3_TXIRQ         (XDCR_DMA3_BASE+0x06)
+#define XDCR_DMA3_TXSTATUS      (XDCR_DMA3_BASE+0x07)
+#define XDCR_DMA3_RXNXTDESCPTR  (XDCR_DMA3_BASE+0x08)
+#define XDCR_DMA3_RXCURBUFADDR  (XDCR_DMA3_BASE+0x09)
+#define XDCR_DMA3_RXCURBUFLEN   (XDCR_DMA3_BASE+0x0A)
+#define XDCR_DMA3_RXCURDESCPTR  (XDCR_DMA3_BASE+0x0B)
+#define XDCR_DMA3_RXTAILDESCPTR (XDCR_DMA3_BASE+0x0C)
+#define XDCR_DMA3_RXCHANNELCTRL (XDCR_DMA3_BASE+0x0D)
+#define XDCR_DMA3_RXIRQ         (XDCR_DMA3_BASE+0x0E)
+#define XDCR_DMA3_RXSTATUS      (XDCR_DMA3_BASE+0x0F)
+#define XDCR_DMA3_CTRL          (XDCR_DMA3_BASE+0x10)
+
+
+/**
+ * <pre
+ * These are the bit defines for the Control, Configuration, and Status
+ * register (XDCR_CTRLCFGSTAT)
+ * @{
+ */
+#define XDCR_INT_MSTR_LOCK_MASK        0x80000000   /* Internal Master Bus Lock */
+#define XDCR_INT_MSTR_AUTO_LOCK_MASK   0x40000000   /* Internal Master Bus Auto Lock, RO */
+#define XDCR_EXT_MSTR_LOCK_MASK        0x20000000   /* External Master Bus Master Lock */
+#define XDCR_EXT_MSTR_AUTO_LOCK_MASK   0x10000000   /* External Master Bus Auto Lock, RO */
+#define XDCR_ENB_DCR_AUTO_LOCK_MASK    0x08000000   /* Enable Auto Bus Lock */
+#define XDCR_ENB_MSTR_ASYNC_MASK       0x04000000   /* External Master in Async Mode */
+#define XDCR_ENB_SLV_ASYNC_MASK        0x02000000   /* External Slave in Async Mode */
+#define XDCR_ENB_DCR_TIMEOUT_SUPP_MASK 0x01000000   /* Enable Timeout Support */
+#define XDCR_INT_MSTR_TIMEOUT_BIT      0x00000002   /* Internal Master Bus Timeout Occurred */
+#define XDCR_EXT_MSTR_TIMEOUT_BIT      0x00000001   /* External Master Bus Timeout Occurred */
+
+/*
+ * Mask to disable exceptions in PPC440 MSR
+ * Bit 14: Critical Interrupt Enable            0x00020000
+ * Bit 16: External Interrupt Enable            0x00008000
+ * Bit 20: Floating-point Exceptions Mode 0     0x00000800
+ * Bit 23: Floating-point Exceptions Mode 1     0x00000100
+ */
+#define XDCR_DISABLE_EXCEPTIONS 0xFFFD76FF
+#define XDCR_ALL_LOCK           (XDCR_INT_MSTR_LOCK_MASK | XDCR_EXT_MSTR_LOCK_MASK)
+#define XDCR_ALL_TIMEOUT        (XDCR_INT_MSTR_TIMEOUT_BIT | XDCR_EXT_MSTR_TIMEOUT_BIT)
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/******************************************************************************/
+/**
+* Reads the register at the specified DCR address.
+*
+*
+* @param    DcrRegister is the intended source DCR register
+*
+* @return
+*
+* Contents of the specified DCR register.
+*
+* @note
+*
+* C-style signature:
+*    void XIo_mDcrReadReg(u32 DcrRegister)
+*
+*******************************************************************************/
+#define XIo_mDcrReadReg(DcrRegister) ({ mfdcr((DcrRegister)); })
+
+/******************************************************************************/
+/**
+* Writes the register at specified DCR address.
+*
+*
+* @param    DcrRegister is the intended destination DCR register
+* @param    Data is the value to be placed into the specified DRC register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*    void XIo_mDcrWriteReg(u32 DcrRegister, u32 Data)
+*
+*******************************************************************************/
+#define XIo_mDcrWriteReg(DcrRegister, Data) ({ mtdcr((DcrRegister), (Data)); })
+
+/******************************************************************************/
+/**
+* Explicitly locks the DCR bus
+*
+* @param    DcrBase is the base of the block of DCR registers
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrLock(u32 DcrBase)
+*
+*   Sets either Lock bit. Since a master cannot edit another master's Lock bit,
+*   the macro can be simplified.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*
+*******************************************************************************/
+#define XIo_mDcrLock(DcrBase) \
+({ \
+ u32 temp;	\
+ temp = mfdcr((DcrBase) + XDCR_CTRLCFGSTAT);		\
+ temp = (temp | XDCR_ALL_LOCK) & ~XDCR_ALL_TIMEOUT;	\
+ mtdcr(((DcrBase) + XDCR_CTRLCFGSTAT), temp); \
+})
+
+/******************************************************************************/
+/**
+* Explicitly locks the DCR bus
+*
+* @param    DcrBase is the base of the block of DCR registers
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrUnlock(u32 DcrBase)
+*
+*   Unsets either Lock bit. Since a master cannot edit another master's Lock bit,
+*   the macro can be simplified.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*
+*******************************************************************************/
+#define XIo_mDcrUnlock(DcrBase) \
+({ \
+ u32 temp;						\
+ temp = mfdcr((DcrBase) + XDCR_CTRLCFGSTAT);		\
+ temp = temp & ~(XDCR_ALL_LOCK | XDCR_ALL_TIMEOUT);	\
+ mtdcr(((DcrBase) + XDCR_CTRLCFGSTAT), temp);		\
+})
+
+/******************************************************************************/
+/**
+* Reads the APU UDI register at the specified APU address.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the intended source APU register
+*
+* @return
+*
+* Contents of the specified APU register.
+*
+* @note
+*
+* C-style signature:
+*    u32 XIo_mDcrReadAPUUDIReg(u32 DcrRegister, u32 UDInum)
+*
+*   Since reading an APU UDI DCR requires a dummy write to the same DCR,
+*   the target UDI number is required. In order to make this operation atomic,
+*   interrupts are disabled before and enabled after the DCR accesses.
+*   Because an APU UDI access involves two DCR accesses, the DCR bus must be
+*   locked to ensure that another master doesn't access the APU UDI register
+*   at the same time.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*   Steps:
+*   - save old MSR
+*   - disable interrupts by writing mask to MSR
+*   - acquire lock; since the PPC440 supports timeout wait, it will wait until
+*     it successfully acquires the DCR bus lock
+*   - shift and mask the UDI number to its bit position of [22:25]
+*   - add the DCR base address to the UDI number and perform the read
+*   - release DCR bus lock
+*   - restore MSR
+*   - return value read
+*
+*******************************************************************************/
+#define XIo_mDcrReadAPUUDIReg(DcrBase, UDInum) \
+({ \
+ unsigned int rVal; \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_DcrLock((DcrBase)); \
+ mtdcr((DcrBase) | XDCR_APU_UDI, (((UDInum) << 6) & 0x000003c0) | 0x00000030); \
+ rVal = mfdcr((DcrBase) | XDCR_APU_UDI); \
+ XIo_DcrUnlock((DcrBase)); \
+ mtmsr(oldMSR); \
+ rVal; \
+})
+
+/******************************************************************************/
+/**
+* Writes the data to the APU UDI register at the specified APU address.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the intended source APU register
+* @param    Data is the value to be placed into the specified APU register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrWriteAPUUDIReg(u32 DcrRegister, u32 UDInum, u32 Data)
+*
+*   Since writing an APU UDI DCR requires a dummy write to the same DCR,
+*   the target UDI number is required. In order to make this operation atomic,
+*   interrupts are disabled before and enabled after the DCR accesses.
+*   Because an APU UDI access involves two DCR accesses, the DCR bus must be
+*   locked to ensure that another master doesn't access the APU UDI register
+*   at the same time.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*   Steps:
+*   - save old MSR
+*   - disable interrupts by writing mask to MSR
+*   - acquire lock, since the PPC440 supports timeout wait, it will wait until
+*     it successfully acquires the DCR bus lock
+*   - shift and mask the UDI number to its bit position of [22:25]
+*   - add DCR base address to UDI number offset and perform the write
+*   - release DCR bus lock
+*   - restore MSR
+*
+*******************************************************************************/
+#define XIo_mDcrWriteAPUUDIReg(DcrBase, UDInum, Data) \
+({ \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_DcrLock((DcrBase)); \
+ mtdcr((DcrBase) | XDCR_APU_UDI, (((UDInum) << 6) & 0x000003c0) | 0x00000030); \
+ mtdcr((DcrBase) | XDCR_APU_UDI, (Data)); \
+ XIo_DcrUnlock((DcrBase)); \
+ mtmsr(oldMSR); \
+})
+
+/******************************************************************************/
+/**
+* Reads the register at the specified DCR address using the indirect addressing
+* method.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended source DCR register
+*
+* @return
+*
+* Contents of the specified DCR register.
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrIndirectAddrReadReg(u32 DcrBase, u32 DcrRegister)
+*
+*   Assumes auto-buslocking feature is ON.
+*   In order to make this operation atomic, interrupts are disabled before
+*   and enabled after the DCR accesses.
+*
+*******************************************************************************/
+#define XIo_mDcrIndirectAddrReadReg(DcrBase, DcrRegister) \
+({ \
+ unsigned int rVal; \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ADDR, (DcrBase) | DcrRegister); \
+ rVal = XIo_mDcrReadReg((DcrBase) | XDCR_IDA_ACC); \
+ mtmsr(oldMSR); \
+ rVal; \
+})
+
+/******************************************************************************/
+/**
+* Writes the register at specified DCR address using the indirect addressing
+* method.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    DcrRegister is the intended destination DCR register
+* @param    Data is the value to be placed into the specified DRC register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrIndirectAddrWriteReg(u32 DcrBase, u32 DcrRegister,
+*                                  u32 Data)
+*
+*   Assumes auto-buslocking feature is ON.
+*   In order to make this operation atomic, interrupts are disabled before
+*   and enabled after the DCR accesses.
+*
+*******************************************************************************/
+#define XIo_mDcrIndirectAddrWriteReg(DcrBase, DcrRegister, Data) \
+({ \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ADDR, (DcrBase) | DcrRegister); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ACC, Data); \
+ mtmsr(oldMSR); \
+})
+
+/******************************************************************************/
+/**
+* Reads the APU UDI register at the specified DCR address using the indirect
+* addressing method.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the intended source DCR register
+*
+* @return
+*
+* Contents of the specified APU register.
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrIndirectAddrReadAPUUDIReg(u32 DcrBase, u32 UDInum)
+*
+*   An indirect APU UDI read requires three DCR accesses:
+*     1) Indirect address reg write
+*     2) Indirect access reg write to specify the UDI number
+*     3) Indirect access reg read of the actual data
+*   Since (2) unlocks the DCR bus, the DCR bus must be explicitly locked
+*   instead of relying on the auto-lock feature.
+*   In order to make this operation atomic, interrupts are disabled before
+*   and enabled after the DCR accesses.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*
+*******************************************************************************/
+#define XIo_mDcrIndirectAddrReadAPUUDIReg(DcrBase, UDInum) \
+({ \
+ unsigned int rVal; \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_DcrLock((DcrBase)); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ADDR, (DcrBase) | XDCR_APU_UDI); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ACC, ((UDInum << 6) & 0x000003c0) | 0x00000030); \
+ rVal = XIo_mDcrReadReg((DcrBase) | XDCR_IDA_ACC); \
+ XIo_DcrUnlock((DcrBase)); \
+ mtmsr(oldMSR); \
+ rVal; \
+})
+
+/******************************************************************************/
+/**
+* Writes the APU UDI register at specified DCR address using the indirect
+* addressing method.
+*
+*
+* @param    DcrBase is the base of the block of DCR registers
+* @param    UDInum is the intended source DCR register
+* @param    Data is the value to be placed into the specified DRC register
+*
+* @return
+*
+* None
+*
+* @note
+*
+* C-style signature:
+*   void XIo_mDcrIndirectAddrWriteReg(u32 DcrBase, u32 UDInum, u32 Data)
+*
+*   An indirect APU UDI write requires three DCR accesses:
+*     1) Indirect address reg write
+*     2) Indirect access reg write to specify the UDI number
+*     3) Indirect access reg write of the actual data
+*   Since (2) unlocks the DCR bus, the DCR bus must be explicitly locked
+*   instead of relying on the auto-lock feature.
+*   In order to make this operation atomic, interrupts are disabled before
+*   and enabled after the DCR accesses.
+*   Care must be taken to not write a '1' to either timeout bit because
+*   it will be cleared.
+*
+*******************************************************************************/
+#define XIo_mDcrIndirectAddrWriteAPUUDIReg(DcrBase, UDInum, Data) \
+({ \
+ unsigned int oldMSR = mfmsr(); \
+ mtmsr(oldMSR & XDCR_DISABLE_EXCEPTIONS); \
+ XIo_DcrLock((DcrBase)); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ADDR, (DcrBase) | XDCR_APU_UDI); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ACC, ((UDInum << 6) & 0x000003c0) | 0x00000030); \
+ XIo_mDcrWriteReg((DcrBase) | XDCR_IDA_ACC, Data);\
+ XIo_DcrUnlock((DcrBase)); \
+ mtmsr(oldMSR); \
+})
+
+/************************** Function Prototypes ******************************/
+void XIo_DcrOut(u32 DcrRegister, u32 Data);
+u32 XIo_DcrIn(u32 DcrRegister);
+
+u32 XIo_DcrReadReg(u32 DcrBase, u32 DcrRegister);
+void XIo_DcrWriteReg(u32 DcrBase, u32 DcrRegister, u32 Data);
+u32 XIo_DcrLockAndReadReg(u32 DcrBase, u32 DcrRegister);
+void XIo_DcrLockAndWriteReg(u32 DcrBase, u32 DcrRegister, u32 Data);
+
+void XIo_DcrWriteAPUUDIReg(u32 DcrBase, short UDInum, u32 Data);
+u32 XIo_DcrReadAPUUDIReg(u32 DcrBase, short UDInum);
+
+void XIo_DcrLock(u32 DcrBase);
+void XIo_DcrUnlock(u32 DcrBase);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xipif_v1_23_b.c b/drivers/xilinx_common/xipif_v1_23_b.c
new file mode 100644
index 0000000..9557d59
--- /dev/null
+++ b/drivers/xilinx_common/xipif_v1_23_b.c
@@ -0,0 +1,324 @@
+/* $Id: xipif_v1_23_b.c,v 1.3 2004/11/15 20:31:35 xduan Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2004 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xipif_v1_23_b.c
+*
+* This file contains the implementation of the XIpIf component. The
+* XIpIf component encapsulates the IPIF, which is the standard interface
+* that IP must adhere to when connecting to a bus.  The purpose of this
+* component is to encapsulate the IPIF processing such that maintainability
+* is increased.  This component does not provide a lot of abstraction from
+* from the details of the IPIF as it is considered a building block for
+* device drivers.  A device driver designer must be familiar with the
+* details of the IPIF hardware to use this component.
+*
+* The IPIF hardware provides a building block for all hardware devices such
+* that each device does not need to reimplement these building blocks. The
+* IPIF contains other building blocks, such as FIFOs and DMA channels, which
+* are also common to many devices.  These blocks are implemented as separate
+* hardware blocks and instantiated within the IPIF.  The primary hardware of
+* the IPIF which is implemented by this software component is the interrupt
+* architecture.  Since there are many blocks of a device which may generate
+* interrupts, all the interrupt processing is contained in the common part
+* of the device, the IPIF.  This interrupt processing is for the device level
+* only and does not include any processing for the interrupt controller.
+*
+* A device is a mechanism such as an Ethernet MAC.  The device is made
+* up of several parts which include an IPIF and the IP.  The IPIF contains most
+* of the device infrastructure which is common to all devices, such as
+* interrupt processing, DMA channels, and FIFOs.  The infrastructure may also
+* be referred to as IPIF internal blocks since they are part of the IPIF and
+* are separate blocks that can be selected based upon the needs of the device.
+* The IP of the device is the logic that is unique to the device and interfaces
+* to the IPIF of the device.
+*
+* In general, there are two levels of registers within the IPIF.  The first
+* level, referred to as the device level, contains registers which are for the
+* entire device.  The second level, referred to as the IP level, contains
+* registers which are specific to the IP of the device.  The two levels of
+* registers are designed to be hierarchical such that the device level is
+* is a more general register set above the more specific registers of the IP.
+* The IP level of registers provides functionality which is typically common
+* across all devices and allows IP designers to focus on the unique aspects
+* of the IP.
+*
+* The interrupt registers of the IPIF are parameterizable such that the only
+* the number of bits necessary for the device are implemented. The functions
+* of this component do not attempt to validate that the passed in arguments are
+* valid based upon the number of implemented bits.  This is necessary to
+* maintain the level of performance required for the common components.  Bits
+* of the registers are assigned starting at the least significant bit of the
+* registers.
+*
+* <b>Critical Sections</b>
+*
+* It is the responsibility of the device driver designer to use critical
+* sections as necessary when calling functions of the IPIF.  This component
+* does not use critical sections and it does access registers using
+* read-modify-write operations.  Calls to IPIF functions from a main thread
+* and from an interrupt context could produce unpredictable behavior such that
+* the caller must provide the appropriate critical sections.
+*
+* <b>Mutual Exclusion</b>
+*
+* The functions of the IPIF are not thread safe such that the caller of all
+* functions is responsible for ensuring mutual exclusion for an IPIF.  Mutual
+* exclusion across multiple IPIF components is not necessary.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 1.23b jhl  02/27/01 Repartioned to reduce size
+* 1.23b rpm  08/17/04 Doxygenated for inclusion in API documentation
+* 1.23b xd   10/27/04 Improve Doxygen format
+* </pre>
+*
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xipif_v1_23_b.h"
+#include "xio.h"
+
+/************************** Constant Definitions *****************************/
+
+/* the following constant is used to generate bit masks for register testing
+ * in the self test functions, it defines the starting bit mask that is to be
+ * shifted from the LSB to MSB in creating a register test mask
+ */
+#define XIIF_V123B_FIRST_BIT_MASK     1UL
+
+
+/* the following constant defines the maximum number of bits which may be
+ * used in the registers at the device and IP levels, this is based upon the
+ * number of bits available in the registers
+ */
+#define XIIF_V123B_MAX_REG_BIT_COUNT 32
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/************************** Function Prototypes ******************************/
+
+static int IpIntrSelfTest(u32 RegBaseAddress, u32 IpRegistersWidth);
+
+/*****************************************************************************/
+/**
+*
+* This function performs a self test on the specified IPIF component.  Many
+* of the registers in the IPIF are tested to ensure proper operation.  This
+* function is destructive because the IPIF is reset at the start of the test
+* and at the end of the test to ensure predictable results.  The IPIF reset
+* also resets the entire device that uses the IPIF.  This function exits with
+* all interrupts for the device disabled.
+*
+* @param RegBaseAddress is the base address of the device's IPIF registers
+*
+* @param IpRegistersWidth contains the number of bits in the IP interrupt
+*        registers of the device.  The hardware is parameterizable such that
+*        only the number of bits necessary to support a device are implemented.
+*        This value must be between 0 and 32 with 0 indicating there are no IP
+*        interrupt registers used.
+*
+* @return
+*
+* A value of XST_SUCCESS indicates the test was successful with no errors.
+* Any one of the following error values may also be returned.
+*                                       <br><br>
+*   - XST_IPIF_RESET_REGISTER_ERROR     The value of a register at reset was
+*                                       not valid
+*                                       <br><br>
+*   - XST_IPIF_IP_STATUS_ERROR          A write to the IP interrupt status
+*                                       register did not read back correctly
+*                                       <br><br>
+*   - XST_IPIF_IP_ACK_ERROR             One or more bits in the IP interrupt
+*                                       status register did not reset when acked
+*                                       <br><br>
+*   - XST_IPIF_IP_ENABLE_ERROR          The IP interrupt enable register
+*                                       did not read back correctly based upon
+*                                       what was written to it
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XIpIfV123b_SelfTest(u32 RegBaseAddress, u8 IpRegistersWidth)
+{
+	int Status;
+
+	/* assert to verify arguments are valid */
+
+	XASSERT_NONVOID(IpRegistersWidth <= XIIF_V123B_MAX_REG_BIT_COUNT);
+
+	/* reset the IPIF such that it's in a known state before the test
+	 * and interrupts are globally disabled
+	 */
+	XIIF_V123B_RESET(RegBaseAddress);
+
+	/* perform the self test on the IP interrupt registers, if
+	 * it is not successful exit with the status
+	 */
+	Status = IpIntrSelfTest(RegBaseAddress, IpRegistersWidth);
+	if (Status != XST_SUCCESS) {
+		return Status;
+	}
+
+	/* reset the IPIF such that it's in a known state before exiting test */
+
+	XIIF_V123B_RESET(RegBaseAddress);
+
+	/* reaching this point means there were no errors, return success */
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************
+*
+* Perform a self test on the IP interrupt registers of the IPIF. This
+* function modifies registers of the IPIF such that they are not guaranteed
+* to be in the same state when it returns.  Any bits in the IP interrupt
+* status register which are set are assumed to be set by default after a reset
+* and are not tested in the test.
+*
+* @param RegBaseAddress is the base address of the device's IPIF registers
+*
+* @param IpRegistersWidth contains the number of bits in the IP interrupt
+*        registers of the device.  The hardware is parameterizable such that
+*        only the number of bits necessary to support a device are implemented.
+*        This value must be between 0 and 32 with 0 indicating there are no IP
+*        interrupt registers used.
+*
+* @return
+*
+* A status indicating XST_SUCCESS if the test was successful.  Otherwise, one
+* of the following values is returned.
+*   - XST_IPIF_RESET_REGISTER_ERROR     The value of a register at reset was
+*                                       not valid
+*                                       <br><br>
+*   - XST_IPIF_IP_STATUS_ERROR          A write to the IP interrupt status
+*                                       register did not read back correctly
+*                                       <br><br>
+*   - XST_IPIF_IP_ACK_ERROR             One or more bits in the IP status
+*                                       register did not reset when acked
+*                                       <br><br>
+*   - XST_IPIF_IP_ENABLE_ERROR          The IP interrupt enable register
+*                                       did not read back correctly based upon
+*                                       what was written to it
+* @note
+*
+* None.
+*
+******************************************************************************/
+static int IpIntrSelfTest(u32 RegBaseAddress, u32 IpRegistersWidth)
+{
+	/* ensure that the IP interrupt enable register is  zero
+	 * as it should be at reset, the interrupt status is dependent upon the
+	 * IP such that it's reset value is not known
+	 */
+	if (XIIF_V123B_READ_IIER(RegBaseAddress) != 0) {
+		return XST_IPIF_RESET_REGISTER_ERROR;
+	}
+
+	/* if there are any used IP interrupts, then test all of the interrupt
+	 * bits in all testable registers
+	 */
+	if (IpRegistersWidth > 0) {
+		u32 BitCount;
+		u32 IpInterruptMask = XIIF_V123B_FIRST_BIT_MASK;
+		u32 Mask = XIIF_V123B_FIRST_BIT_MASK;	/* bits assigned MSB to LSB */
+		u32 InterruptStatus;
+
+		/* generate the register masks to be used for IP register tests, the
+		 * number of bits supported by the hardware is parameterizable such
+		 * that only that number of bits are implemented in the registers, the
+		 * bits are allocated starting at the MSB of the registers
+		 */
+		for (BitCount = 1; BitCount < IpRegistersWidth; BitCount++) {
+			Mask = Mask << 1;
+			IpInterruptMask |= Mask;
+		}
+
+		/* get the current IP interrupt status register contents, any bits
+		 * already set must default to 1 at reset in the device and these
+		 * bits can't be tested in the following test, remove these bits from
+		 * the mask that was generated for the test
+		 */
+		InterruptStatus = XIIF_V123B_READ_IISR(RegBaseAddress);
+		IpInterruptMask &= ~InterruptStatus;
+
+		/* set the bits in the device status register and verify them by reading
+		 * the register again, all bits of the register are latched
+		 */
+		XIIF_V123B_WRITE_IISR(RegBaseAddress, IpInterruptMask);
+		InterruptStatus = XIIF_V123B_READ_IISR(RegBaseAddress);
+		if ((InterruptStatus & IpInterruptMask) != IpInterruptMask)
+		{
+			return XST_IPIF_IP_STATUS_ERROR;
+		}
+
+		/* test to ensure that the bits set in the IP interrupt status register
+		 * can be cleared by acknowledging them in the IP interrupt status
+		 * register then read it again and verify it was cleared
+		 */
+		XIIF_V123B_WRITE_IISR(RegBaseAddress, IpInterruptMask);
+		InterruptStatus = XIIF_V123B_READ_IISR(RegBaseAddress);
+		if ((InterruptStatus & IpInterruptMask) != 0) {
+			return XST_IPIF_IP_ACK_ERROR;
+		}
+
+		/* set the IP interrupt enable set register and then read the IP
+		 * interrupt enable register and verify the interrupts were enabled
+		 */
+		XIIF_V123B_WRITE_IIER(RegBaseAddress, IpInterruptMask);
+		if (XIIF_V123B_READ_IIER(RegBaseAddress) != IpInterruptMask) {
+			return XST_IPIF_IP_ENABLE_ERROR;
+		}
+
+		/* clear the IP interrupt enable register and then read the
+		 * IP interrupt enable register and verify the interrupts were disabled
+		 */
+		XIIF_V123B_WRITE_IIER(RegBaseAddress, 0);
+		if (XIIF_V123B_READ_IIER(RegBaseAddress) != 0) {
+			return XST_IPIF_IP_ENABLE_ERROR;
+		}
+	}
+	return XST_SUCCESS;
+}
diff --git a/drivers/xilinx_common/xipif_v1_23_b.h b/drivers/xilinx_common/xipif_v1_23_b.h
new file mode 100644
index 0000000..f8c8595
--- /dev/null
+++ b/drivers/xilinx_common/xipif_v1_23_b.h
@@ -0,0 +1,665 @@
+/* $Id: xipif_v1_23_b.h,v 1.5 2005/09/26 16:04:52 trujillo Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2004 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xipif_v1_23_b.h
+*
+* The XIpIf component encapsulates the IPIF, which is the standard interface
+* that IP must adhere to when connecting to a bus.  The purpose of this
+* component is to encapsulate the IPIF processing such that maintainability
+* is increased.  This component does not provide a lot of abstraction from
+* from the details of the IPIF as it is considered a building block for
+* device drivers.  A device driver designer must be familiar with the
+* details of the IPIF hardware to use this component.
+*
+* The IPIF hardware provides a building block for all hardware devices such
+* that each device does not need to reimplement these building blocks. The
+* IPIF contains other building blocks, such as FIFOs and DMA channels, which
+* are also common to many devices.  These blocks are implemented as separate
+* hardware blocks and instantiated within the IPIF.  The primary hardware of
+* the IPIF which is implemented by this software component is the interrupt
+* architecture.  Since there are many blocks of a device which may generate
+* interrupts, all the interrupt processing is contained in the common part
+* of the device, the IPIF.  This interrupt processing is for the device level
+* only and does not include any processing for the interrupt controller.
+*
+* A device is a mechanism such as an Ethernet MAC.  The device is made
+* up of several parts which include an IPIF and the IP.  The IPIF contains most
+* of the device infrastructure which is common to all devices, such as
+* interrupt processing, DMA channels, and FIFOs.  The infrastructure may also
+* be referred to as IPIF internal blocks since they are part of the IPIF and
+* are separate blocks that can be selected based upon the needs of the device.
+* The IP of the device is the logic that is unique to the device and interfaces
+* to the IPIF of the device.
+*
+* In general, there are two levels of registers within the IPIF.  The first
+* level, referred to as the device level, contains registers which are for the
+* entire device.  The second level, referred to as the IP level, contains
+* registers which are specific to the IP of the device.  The two levels of
+* registers are designed to be hierarchical such that the device level is
+* is a more general register set above the more specific registers of the IP.
+* The IP level of registers provides functionality which is typically common
+* across all devices and allows IP designers to focus on the unique aspects
+* of the IP.
+*
+* <b>Critical Sections</b>
+*
+* It is the responsibility of the device driver designer to use critical
+* sections as necessary when calling functions of the IPIF.  This component
+* does not use critical sections and it does access registers using
+* read-modify-write operations.  Calls to IPIF functions from a main thread
+* and from an interrupt context could produce unpredictable behavior such that
+* the caller must provide the appropriate critical sections.
+*
+* <b>Mutual Exclusion</b>
+*
+* The functions of the IPIF are not thread safe such that the caller of all
+* functions is responsible for ensuring mutual exclusion for an IPIF.  Mutual
+* exclusion across multiple IPIF components is not necessary.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- ---------------------------------------------------------
+* 1.23b jhl  02/27/01 Repartioned to minimize size
+* 1.23b rpm  07/16/04 Changed ifdef for circular inclusion to be more qualified
+* 1.23b rpm  08/17/04 Doxygenated for inclusion of API documentation
+* 1.23b xd   10/27/04 Improve Doxygen format
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XIPIF_V123B_H		/* prevent circular inclusions */
+#define XIPIF_V123B_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/***************************** Include Files *********************************/
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xversion.h"
+
+/************************** Constant Definitions *****************************/
+
+/** @name Register Offsets
+ *
+ * The following constants define the register offsets for the registers of the
+ * IPIF, there are some holes in the memory map for reserved addresses to allow
+ * other registers to be added and still match the memory map of the interrupt
+ * controller registers
+ * @{
+ */
+#define XIIF_V123B_DISR_OFFSET     0UL	/**< device interrupt status register */
+#define XIIF_V123B_DIPR_OFFSET     4UL	/**< device interrupt pending register */
+#define XIIF_V123B_DIER_OFFSET     8UL	/**< device interrupt enable register */
+#define XIIF_V123B_DIIR_OFFSET     24UL	/**< device interrupt ID register */
+#define XIIF_V123B_DGIER_OFFSET    28UL	/**< device global interrupt enable register */
+#define XIIF_V123B_IISR_OFFSET     32UL	/**< IP interrupt status register */
+#define XIIF_V123B_IIER_OFFSET     40UL	/**< IP interrupt enable register */
+#define XIIF_V123B_RESETR_OFFSET   64UL	/**< reset register */
+/* @} */
+
+/**
+ * The value used for the reset register to reset the IPIF
+ */
+#define XIIF_V123B_RESET_MASK             0xAUL
+
+/**
+ * The following constant is used for the device global interrupt enable
+ * register, to enable all interrupts for the device, this is the only bit
+ * in the register
+ */
+#define XIIF_V123B_GINTR_ENABLE_MASK      0x80000000UL
+
+/**
+ * The mask to identify each internal IPIF error condition in the device
+ * registers of the IPIF. Interrupts are assigned in the register from LSB
+ * to the MSB
+ */
+#define XIIF_V123B_ERROR_MASK             1UL	  /**< LSB of the register */
+
+/** @name Interrupt IDs
+ *
+ * The interrupt IDs which identify each internal IPIF condition, this value
+ * must correlate with the mask constant for the error
+ * @{
+ */
+#define XIIF_V123B_ERROR_INTERRUPT_ID     0    /**< interrupt bit #, (LSB = 0) */
+#define XIIF_V123B_NO_INTERRUPT_ID        128  /**< no interrupts are pending */
+/* @} */
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/*****************************************************************************/
+/**
+*
+* Reset the IPIF component and hardware.  This is a destructive operation that
+* could cause the loss of data since resetting the IPIF of a device also
+* resets the device using the IPIF and any blocks, such as FIFOs or DMA
+* channels, within the IPIF.  All registers of the IPIF will contain their
+* reset value when this function returns.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return   None
+*
+* @note     None
+*
+******************************************************************************/
+#define XIIF_V123B_RESET(RegBaseAddress) \
+    XIo_Out32(RegBaseAddress + XIIF_V123B_RESETR_OFFSET, XIIF_V123B_RESET_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the device interrupt status register to the value.
+* This register indicates the status of interrupt sources for a device
+* which contains the IPIF.  The status is independent of whether interrupts
+* are enabled and could be used for polling a device at a higher level rather
+* than a more detailed level.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* device which contains the IPIF.  With the exception of some internal IPIF
+* conditions, the contents of this register are not latched but indicate
+* the live status of the interrupt sources within the device.  Writing any of
+* the non-latched bits of the register will have no effect on the register.
+*
+* For the latched bits of this register only, setting a bit which is zero
+* within this register causes an interrupt to generated.  The device global
+* interrupt enable register and the device interrupt enable register must be set
+* appropriately to allow an interrupt to be passed out of the device. The
+* interrupt is cleared by writing to this register with the bits to be
+* cleared set to a one and all others to zero.  This register implements a
+* toggle on write functionality meaning any bits which are set in the value
+* written cause the bits in the register to change to the opposite state.
+*
+* This function writes the specified value to the register such that
+* some bits may be set and others cleared.  It is the caller's responsibility
+* to get the value of the register prior to setting the value to prevent a
+* destructive behavior.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @param Status contains the value to be written to the interrupt status
+*        register of the device.  The only bits which can be written are
+*        the latched bits which contain the internal IPIF conditions.  The
+*        following values may be used to set the status register or clear an
+*        interrupt condition.
+*        - XIIF_V123B_ERROR_MASK     Indicates a device error in the IPIF
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+#define XIIF_V123B_WRITE_DISR(RegBaseAddress, Status) \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_DISR_OFFSET, (Status))
+
+/*****************************************************************************/
+/**
+*
+* This macro gets the device interrupt status register contents.
+* This register indicates the status of interrupt sources for a device
+* which contains the IPIF.  The status is independent of whether interrupts
+* are enabled and could be used for polling a device at a higher level.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* device which contains the IPIF.  With the exception of some internal IPIF
+* conditions, the contents of this register are not latched but indicate
+* the live status of the interrupt sources within the device.
+*
+* For only the latched bits of this register, the interrupt may be cleared by
+* writing to these bits in the status register.
+*
+* @param    RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* A status which contains the value read from the interrupt status register of
+* the device. The bit definitions are specific to the device with
+* the exception of the latched internal IPIF condition bits. The following
+* values may be used to detect internal IPIF conditions in the status.
+* <br><br>
+* - XIIF_V123B_ERROR_MASK     Indicates a device error in the IPIF
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_READ_DISR(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_DISR_OFFSET)
+
+/*****************************************************************************/
+/**
+*
+* This function sets the device interrupt enable register contents.
+* This register controls which interrupt sources of the device are allowed to
+* generate an interrupt.  The device global interrupt enable register must also
+* be set appropriately for an interrupt to be passed out of the device.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* device which contains the IPIF.  Setting a bit in this register enables that
+* interrupt source to generate an interrupt.  Clearing a bit in this register
+* disables interrupt generation for that interrupt source.
+*
+* This function writes only the specified value to the register such that
+* some interrupts source may be enabled and others disabled.  It is the
+* caller's responsibility to get the value of the interrupt enable register
+* prior to setting the value to prevent an destructive behavior.
+*
+* An interrupt source may not be enabled to generate an interrupt, but can
+* still be polled in the interrupt status register.
+*
+* @param    RegBaseAddress contains the base address of the IPIF registers.
+*
+* @param
+*
+* Enable contains the value to be written to the interrupt enable register
+* of the device.  The bit definitions are specific to the device with
+* the exception of the internal IPIF conditions. The following
+* values may be used to enable the internal IPIF conditions interrupts.
+*   - XIIF_V123B_ERROR_MASK     Indicates a device error in the IPIF
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* Signature: u32 XIIF_V123B_WRITE_DIER(u32 RegBaseAddress,
+*                                          u32 Enable)
+*
+******************************************************************************/
+#define XIIF_V123B_WRITE_DIER(RegBaseAddress, Enable) \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_DIER_OFFSET, (Enable))
+
+/*****************************************************************************/
+/**
+*
+* This function gets the device interrupt enable register contents.
+* This register controls which interrupt sources of the device
+* are allowed to generate an interrupt.  The device global interrupt enable
+* register and the device interrupt enable register must also be set
+* appropriately for an interrupt to be passed out of the device.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* device which contains the IPIF.  Setting a bit in this register enables that
+* interrupt source to generate an interrupt if the global enable is set
+* appropriately.  Clearing a bit in this register disables interrupt generation
+* for that interrupt source regardless of the global interrupt enable.
+*
+* @param    RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* The value read from the interrupt enable register of the device.  The bit
+* definitions are specific to the device with the exception of the internal
+* IPIF conditions. The following values may be used to determine from the
+* value if the internal IPIF conditions interrupts are enabled.
+* <br><br>
+* - XIIF_V123B_ERROR_MASK     Indicates a device error in the IPIF
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_READ_DIER(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_DIER_OFFSET)
+
+/*****************************************************************************/
+/**
+*
+* This function gets the device interrupt pending register contents.
+* This register indicates the pending interrupt sources, those that are waiting
+* to be serviced by the software, for a device which contains the IPIF.
+* An interrupt must be enabled in the interrupt enable register of the IPIF to
+* be pending.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* the device which contains the IPIF.  With the exception of some internal IPIF
+* conditions, the contents of this register are not latched since the condition
+* is latched in the IP interrupt status register, by an internal block of the
+* IPIF such as a FIFO or DMA channel, or by the IP of the device.  This register
+* is read only and is not latched, but it is necessary to acknowledge (clear)
+* the interrupt condition by performing the appropriate processing for the IP
+* or block within the IPIF.
+*
+* This register can be thought of as the contents of the interrupt status
+* register ANDed with the contents of the interrupt enable register.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* The value read from the interrupt pending register of the device.  The bit
+* definitions are specific to the device with the exception of the latched
+* internal IPIF condition bits. The following values may be used to detect
+* internal IPIF conditions in the value.
+* <br><br>
+* - XIIF_V123B_ERROR_MASK     Indicates a device error in the IPIF
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_READ_DIPR(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_DIPR_OFFSET)
+
+/*****************************************************************************/
+/**
+*
+* This macro gets the device interrupt ID for the highest priority interrupt
+* which is pending from the interrupt ID register. This function provides
+* priority resolution such that faster interrupt processing is possible.
+* Without priority resolution, it is necessary for the software to read the
+* interrupt pending register and then check each interrupt source to determine
+* if an interrupt is pending.  Priority resolution becomes more important as the
+* number of interrupt sources becomes larger.
+*
+* Interrupt priorities are based upon the bit position of the interrupt in the
+* interrupt pending register with bit 0 being the highest priority. The
+* interrupt ID is the priority of the interrupt, 0 - 31, with 0 being the
+* highest priority. The interrupt ID register is live rather than latched such
+* that multiple calls to this function may not yield the same results.  A
+* special value, outside of the interrupt priority range of 0 - 31, is
+* contained in the register which indicates that no interrupt is pending.  This
+* may be useful for allowing software to continue processing interrupts in a
+* loop until there are no longer any interrupts pending.
+*
+* The interrupt ID is designed to allow a function pointer table to be used
+* in the software such that the interrupt ID is used as an index into that
+* table.  The function pointer table could contain an instance pointer, such
+* as to DMA channel, and a function pointer to the function which handles
+* that interrupt.  This design requires the interrupt processing of the device
+* driver to be partitioned into smaller more granular pieces based upon
+* hardware used by the device, such as DMA channels and FIFOs.
+*
+* It is not mandatory that this function be used by the device driver software.
+* It may choose to read the pending register and resolve the pending interrupt
+* priorities on it's own.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* An interrupt ID, 0 - 31, which identifies the highest priority interrupt
+* which is pending.  A value of XIIF_NO_INTERRUPT_ID indicates that there is
+* no interrupt pending. The following values may be used to identify the
+* interrupt ID for the internal IPIF interrupts.
+* <br><br>
+* - XIIF_V123B_ERROR_INTERRUPT_ID     Indicates a device error in the IPIF
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_READ_DIIR(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_DIIR_OFFSET)
+
+/*****************************************************************************/
+/**
+*
+* This function disables all interrupts for the device by writing to the global
+* interrupt enable register.  This register provides the ability to disable
+* interrupts without any modifications to the interrupt enable register such
+* that it is minimal effort to restore the interrupts to the previous enabled
+* state.  The corresponding function, XIpIf_GlobalIntrEnable, is provided to
+* restore the interrupts to the previous enabled state.  This function is
+* designed to be used in critical sections of device drivers such that it is
+* not necessary to disable other device interrupts.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_GINTR_DISABLE(RegBaseAddress) \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_DGIER_OFFSET, 0)
+
+/*****************************************************************************/
+/**
+*
+* This function writes to the global interrupt enable register to enable
+* interrupts from the device.  This register provides the ability to enable
+* interrupts without any modifications to the interrupt enable register such
+* that it is minimal effort to restore the interrupts to the previous enabled
+* state.  This function does not enable individual interrupts as the interrupt
+* enable register must be set appropriately.  This function is designed to be
+* used in critical sections of device drivers such that it is not necessary to
+* disable other device interrupts.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_GINTR_ENABLE(RegBaseAddress)           \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_DGIER_OFFSET, \
+               XIIF_V123B_GINTR_ENABLE_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function determines if interrupts are enabled at the global level by
+* reading the global interrupt register. This register provides the ability to
+* disable interrupts without any modifications to the interrupt enable register
+* such that it is minimal effort to restore the interrupts to the previous
+* enabled state.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* TRUE if interrupts are enabled for the IPIF, FALSE otherwise.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_IS_GINTR_ENABLED(RegBaseAddress)             \
+    (XIo_In32((RegBaseAddress) + XIIF_V123B_DGIER_OFFSET) ==    \
+              XIIF_V123B_GINTR_ENABLE_MASK)
+
+/*****************************************************************************/
+/**
+*
+* This function sets the IP interrupt status register to the specified value.
+* This register indicates the status of interrupt sources for the IP of the
+* device.  The IP is defined as the part of the device that connects to the
+* IPIF.  The status is independent of whether interrupts are enabled such that
+* the status register may also be polled when interrupts are not enabled.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* IP.  All bits of this register are latched. Setting a bit which is zero
+* within this register causes an interrupt to be generated.  The device global
+* interrupt enable register and the device interrupt enable register must be set
+* appropriately to allow an interrupt to be passed out of the device. The
+* interrupt is cleared by writing to this register with the bits to be
+* cleared set to a one and all others to zero.  This register implements a
+* toggle on write functionality meaning any bits which are set in the value
+* written cause the bits in the register to change to the opposite state.
+*
+* This function writes only the specified value to the register such that
+* some status bits may be set and others cleared.  It is the caller's
+* responsibility to get the value of the register prior to setting the value
+* to prevent an destructive behavior.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @param Status contains the value to be written to the IP interrupt status
+*        register.  The bit definitions are specific to the device IP.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_WRITE_IISR(RegBaseAddress, Status) \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_IISR_OFFSET, (Status))
+
+/*****************************************************************************/
+/**
+*
+* This macro gets the contents of the IP interrupt status register.
+* This register indicates the status of interrupt sources for the IP of the
+* device.  The IP is defined as the part of the device that connects to the
+* IPIF. The status is independent of whether interrupts are enabled such
+* that the status register may also be polled when interrupts are not enabled.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* device.  All bits of this register are latched.  Writing a 1 to a bit within
+* this register causes an interrupt to be generated if enabled in the interrupt
+* enable register and the global interrupt enable is set.  Since the status is
+* latched, each status bit must be acknowledged in order for the bit in the
+* status register to be updated.  Each bit can be acknowledged by writing a
+* 0 to the bit in the status register.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* A status which contains the value read from the IP interrupt status register.
+* The bit definitions are specific to the device IP.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_READ_IISR(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_IISR_OFFSET)
+
+/*****************************************************************************/
+/**
+*
+* This macro sets the IP interrupt enable register contents.  This register
+* controls which interrupt sources of the IP are allowed to generate an
+* interrupt.  The global interrupt enable register and the device interrupt
+* enable register must also be set appropriately for an interrupt to be
+* passed out of the device containing the IPIF and the IP.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* IP.  Setting a bit in this register enables the interrupt source to generate
+* an interrupt.  Clearing a bit in this register disables interrupt generation
+* for that interrupt source.
+*
+* This function writes only the specified value to the register such that
+* some interrupt sources may be enabled and others disabled.  It is the
+* caller's responsibility to get the value of the interrupt enable register
+* prior to setting the value to prevent an destructive behavior.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @param Enable contains the value to be written to the IP interrupt enable
+*        register. The bit definitions are specific to the device IP.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+#define XIIF_V123B_WRITE_IIER(RegBaseAddress, Enable) \
+    XIo_Out32((RegBaseAddress) + XIIF_V123B_IIER_OFFSET, (Enable))
+
+/*****************************************************************************/
+/**
+*
+* This macro gets the IP interrupt enable register contents.  This register
+* controls which interrupt sources of the IP are allowed to generate an
+* interrupt.  The global interrupt enable register and the device interrupt
+* enable register must also be set appropriately for an interrupt to be
+* passed out of the device containing the IPIF and the IP.
+*
+* Each bit of the register correlates to a specific interrupt source within the
+* IP.  Setting a bit in this register enables the interrupt source to generate
+* an interrupt.  Clearing a bit in this register disables interrupt generation
+* for that interrupt source.
+*
+* @param RegBaseAddress contains the base address of the IPIF registers.
+*
+* @return
+*
+* The contents read from the IP interrupt enable register.  The bit definitions
+* are specific to the device IP.
+*
+* @note
+*
+* Signature: u32 XIIF_V123B_READ_IIER(u32 RegBaseAddress)
+*
+******************************************************************************/
+#define XIIF_V123B_READ_IIER(RegBaseAddress) \
+    XIo_In32((RegBaseAddress) + XIIF_V123B_IIER_OFFSET)
+
+/************************** Function Prototypes ******************************/
+
+/**
+ * Initialization Functions
+ */
+int XIpIfV123b_SelfTest(u32 RegBaseAddress, u8 IpRegistersWidth);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xlldma.c b/drivers/xilinx_common/xlldma.c
new file mode 100644
index 0000000..274e449
--- /dev/null
+++ b/drivers/xilinx_common/xlldma.c
@@ -0,0 +1,252 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xlldma.c
+*
+* This file implements initialization and control related functions. For more
+* information on this driver, see xlldma.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   12/21/06 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include <linux/string.h>
+
+#include "xlldma.h"
+#include "xenv.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+ * This function initializes a DMA engine.  This function must be called
+ * prior to using a DMA engine. Initialization of a engine includes setting
+ * up the register base address, setting up the instance data, and ensuring the
+ * hardware is in a quiescent state.
+ *
+ * @param  InstancePtr is a pointer to the DMA engine instance to be worked on.
+ * @param  BaseAddress is where the registers for this engine can be found.
+ *         If address translation is being used, then this parameter must
+ *         reflect the virtual base address.
+ * @return None.
+ *
+ *****************************************************************************/
+void XLlDma_Initialize(XLlDma * InstancePtr, u32 BaseAddress)
+{
+	/* Setup the instance */
+	memset(InstancePtr, 0, sizeof(XLlDma));
+	InstancePtr->RegBase = BaseAddress;
+
+	/* Initialize the ring structures */
+	InstancePtr->TxBdRing.RunState = XST_DMA_SG_IS_STOPPED;
+	InstancePtr->TxBdRing.ChanBase = BaseAddress + XLLDMA_TX_OFFSET;
+	InstancePtr->TxBdRing.IsRxChannel = 0;
+	InstancePtr->RxBdRing.RunState = XST_DMA_SG_IS_STOPPED;
+	InstancePtr->RxBdRing.ChanBase = BaseAddress + XLLDMA_RX_OFFSET;
+	InstancePtr->RxBdRing.IsRxChannel = 1;
+
+	/* Reset the device and return */
+	XLlDma_Reset(InstancePtr);
+}
+
+/*****************************************************************************/
+/**
+* Reset both TX and RX channels of a DMA engine.
+*
+* Any DMA transaction in progress aborts immediately. The DMA engine is in
+* stop state after the reset.
+*
+* @param  InstancePtr is a pointer to the DMA engine instance to be worked on.
+*
+* @return None.
+*
+* @note
+*         - If the hardware is not working properly, this function will enter
+*           infinite loop and never return.
+*         - After the reset, the Normal mode is enabled, and the overflow error
+*           for both TX/RX channels are disabled.
+*         - After the reset, the DMA engine is no longer in pausing state, if
+*           the DMA engine is paused before the reset operation.
+*         - After the reset, the coalescing count value and the delay timeout
+*           value are both set to 1 for TX and RX channels.
+*         - After the reset, all interrupts are disabled.
+*
+******************************************************************************/
+void XLlDma_Reset(XLlDma * InstancePtr)
+{
+	u32 IrqStatus;
+	XLlDma_BdRing *TxRingPtr, *RxRingPtr;
+
+	TxRingPtr = &XLlDma_mGetTxRing(InstancePtr);
+	RxRingPtr = &XLlDma_mGetRxRing(InstancePtr);
+
+	/* Save the locations of current BDs both rings are working on
+	 * before the reset so later we can resume the rings smoothly.
+	 */
+	XLlDma_mBdRingSnapShotCurrBd(TxRingPtr);
+	XLlDma_mBdRingSnapShotCurrBd(RxRingPtr);
+
+	/* Start reset process then wait for completion */
+	XLlDma_mSetCr(InstancePtr, XLLDMA_DMACR_SW_RESET_MASK);
+
+	/* Loop until the reset is done */
+	while ((XLlDma_mGetCr(InstancePtr) & XLLDMA_DMACR_SW_RESET_MASK)) {
+	}
+
+	/* Disable all interrupts after issue software reset */
+	XLlDma_mBdRingIntDisable(TxRingPtr, XLLDMA_CR_IRQ_ALL_EN_MASK);
+	XLlDma_mBdRingIntDisable(RxRingPtr, XLLDMA_CR_IRQ_ALL_EN_MASK);
+
+	/* Clear Interrupt registers of both channels, as the software reset
+	 * does not clear any register values. Not doing so will cause
+	 * interrupts asserted after the software reset if there is any
+	 * interrupt left over before.
+	 */
+	IrqStatus = XLlDma_mBdRingGetIrq(TxRingPtr);
+	XLlDma_mBdRingAckIrq(TxRingPtr, IrqStatus);
+	IrqStatus = XLlDma_mBdRingGetIrq(RxRingPtr);
+	XLlDma_mBdRingAckIrq(RxRingPtr, IrqStatus);
+
+	/* Enable Normal mode, and disable overflow errors for both channels */
+	XLlDma_mSetCr(InstancePtr, XLLDMA_DMACR_TAIL_PTR_EN_MASK |
+		      XLLDMA_DMACR_RX_OVERFLOW_ERR_DIS_MASK |
+		      XLLDMA_DMACR_TX_OVERFLOW_ERR_DIS_MASK);
+
+	/* Set TX/RX Channel coalescing setting */
+	XLlDma_BdRingSetCoalesce(TxRingPtr, 1, 1);
+	XLlDma_BdRingSetCoalesce(RxRingPtr, 1, 1);
+
+	TxRingPtr->RunState = XST_DMA_SG_IS_STOPPED;
+	RxRingPtr->RunState = XST_DMA_SG_IS_STOPPED;
+}
+
+/*****************************************************************************/
+/**
+* Pause DMA transactions on both channels. The DMA enters the pausing state
+* immediately. So if a DMA transaction is in progress, it will be left
+* unfinished and will be continued once the DMA engine is resumed
+* (see XLlDma_Resume()).
+*
+* @param  InstancePtr is a pointer to the DMA engine instance to be worked on.
+*
+* @return None.
+*
+* @note
+*       - If the hardware is not working properly, this function will enter
+*         infinite loop and never return.
+*       - After the DMA is paused, DMA channels still could accept more BDs
+*         from software (see XLlDma_BdRingToHw()), but new BDs will not be
+*         processed until the DMA is resumed (see XLlDma_Resume()).
+*
+*****************************************************************************/
+void XLlDma_Pause(XLlDma * InstancePtr)
+{
+	u32 RegValue;
+	XLlDma_BdRing *TxRingPtr, *RxRingPtr;
+
+	TxRingPtr = &XLlDma_mGetTxRing(InstancePtr);
+	RxRingPtr = &XLlDma_mGetRxRing(InstancePtr);
+
+	/* Do nothing if both channels already stopped */
+	if ((TxRingPtr->RunState == XST_DMA_SG_IS_STOPPED) &&
+	    (RxRingPtr->RunState == XST_DMA_SG_IS_STOPPED)) {
+		return;
+	}
+
+	/* Enable pause bits for both TX/ RX channels */
+	RegValue = XLlDma_mGetCr(InstancePtr);
+	XLlDma_mSetCr(InstancePtr, RegValue | XLLDMA_DMACR_TX_PAUSE_MASK |
+		      XLLDMA_DMACR_RX_PAUSE_MASK);
+
+	/* Loop until Write Command Queue of RX channel is empty, which
+	 * indicates that all the write data associated with the pending
+	 * commands has been flushed.*/
+	while (!(XLlDma_mBdRingGetIrq(RxRingPtr) | XLLDMA_IRQ_WRQ_EMPTY_MASK));
+
+	TxRingPtr->RunState = XST_DMA_SG_IS_STOPPED;
+	RxRingPtr->RunState = XST_DMA_SG_IS_STOPPED;
+}
+
+/*****************************************************************************/
+/**
+* Resume DMA transactions on both channels. Any interrupted DMA transaction
+* caused by DMA pause operation (see XLlDma_Pause()) and all committed
+* transactions after DMA is paused will be continued upon the return of this
+* function.
+*
+* @param  InstancePtr is a pointer to the DMA engine instance to be worked on.
+*
+* @return None.
+*
+*****************************************************************************/
+void XLlDma_Resume(XLlDma * InstancePtr)
+{
+	u32 RegValue;
+	XLlDma_BdRing *TxRingPtr, *RxRingPtr;
+
+	TxRingPtr = &XLlDma_mGetTxRing(InstancePtr);
+	RxRingPtr = &XLlDma_mGetRxRing(InstancePtr);
+
+	/* Do nothing if both channels already started */
+	if ((TxRingPtr->RunState == XST_DMA_SG_IS_STARTED) &&
+	    (RxRingPtr->RunState == XST_DMA_SG_IS_STARTED)) {
+		return;
+	}
+
+	/* Clear pause bits for both TX/ RX channels */
+	RegValue = XLlDma_mGetCr(InstancePtr);
+	XLlDma_mSetCr(InstancePtr, RegValue & ~(XLLDMA_DMACR_TX_PAUSE_MASK |
+						XLLDMA_DMACR_RX_PAUSE_MASK));
+
+	TxRingPtr->RunState = XST_DMA_SG_IS_STARTED;
+	RxRingPtr->RunState = XST_DMA_SG_IS_STARTED;
+}
diff --git a/drivers/xilinx_common/xlldma.h b/drivers/xilinx_common/xlldma.h
new file mode 100644
index 0000000..ae6d70a
--- /dev/null
+++ b/drivers/xilinx_common/xlldma.h
@@ -0,0 +1,579 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xlldma.h
+*
+* The Xilinx Local-Link Scatter Gather DMA driver. This driver supports Soft
+* DMA (SDMA) engines. Each SDMA engine contains two separate DMA channels (TX
+* and RX).
+*
+* This component is designed to be used as a basic building block for
+* designing a device driver. It provides registers accesses such that all
+* DMA processing can be maintained easier, but the device driver designer
+* must still understand all the details of the DMA channel.
+*
+* For a full description of DMA features, please see the hardware spec. This
+* driver supports the following features:
+*
+*   - Scatter-Gather DMA (SGDMA)
+*   - Interrupts
+*   - Programmable interrupt coalescing for SGDMA
+*   - Capable of using 32 bit addressing for buffer. (Hardware spec states
+*     36 Bit bus addressing, which includes Msb 4-bits of DMA address
+*     configurable on each channel through the Channel Control Registers)
+*   - APIs to manage Buffer Descriptors (BD) movement to and from the SGDMA
+*     engine
+*   - Virtual memory support
+*
+* <b>Transactions</b>
+*
+* To describe a DMA transaction in its simplest form, you need source address,
+* destination address, and the number of bytes to transfer. When using a DMA
+* receive channel, the source address is within some piece of IP Hardware and
+* doesn't require the application explicitly set it. Likewise with a transmit
+* channel and the destination address. So this leaves a application buffer
+* address and the number bytes to transfer as the primary transaction
+* attributes. Other attributes include:
+*
+*   - If the transaction occurs on a bus wider than 32 bits, what are the
+*     highest order address bits.
+*   - Does this transaction represent the start of a packet, or end of a
+*     packet.
+*
+* The object used to describe a transaction is referred to as a Buffer
+* Descriptor (BD). The format of a BD closely matches that of the DMA hardware.
+* Many fields within the BD correspond directly with the same fields within the
+* hardware registers. See xlldmabd.h for a detailed description of and the API
+* for manipulation of these objects.
+*
+* <b>Scatter-Gather DMA</b>
+*
+* SGDMA allows the application to define a list of transactions in memory which
+* the hardware will process without further application intervention. During
+* this time, the application is free to continue adding more work to keep the
+* Hardware busy.
+*
+* Notification of completed transactions can be done either by polling the
+* hardware, or using interrupts that signal a transaction has completed or a
+* series of transactions have been completed.
+*
+* SGDMA processes whole packets. A packet is defined as a series of
+* data bytes that represent a message. SGDMA allows a packet of data to be
+* broken up into one or more transactions. For example, take an Ethernet IP
+* packet which consists of a 14 byte header followed by a 1 or more byte
+* payload. With SGDMA, the application may point a BD to the header and another
+* BD to the payload, then transfer them as a single message. This strategy can
+* make a TCP/IP stack more efficient by allowing it to keep packet headers and
+* data in different memory regions instead of assembling packets into
+* contiguous blocks of memory.
+*
+* <b>SGDMA Ring Management</b>
+*
+* The hardware expects BDs to be setup as a singly linked list. As a BD is
+* completed, the DMA engine will dereference BD.Next and load the next BD to
+* process. This driver uses a fixed buffer ring where all BDs are linked to the
+* next BD in adjacent memory. The last BD in the ring is linked to the first.
+*
+* Within the ring, the driver maintains four groups of BDs. Each group consists
+* of 0 or more adjacent BDs:
+*
+*   - Free: Those BDs that can be allocated by the application with
+*     XLlDma_BdRingAlloc(). These BDs are under driver control and may not be
+*     modified by the application
+*
+*   - Pre-process: Those BDs that have been allocated with
+*     XLlDma_BdRingAlloc(). These BDs are under application control. The
+*     application modifies these BDs in preparation for future DMA
+*     transactions.
+*
+*   - Hardware: Those BDs that have been enqueued to hardware with
+*     XLlDma_BdRingToHw(). These BDs are under hardware control and may be in a
+*     state of awaiting hardware processing, in process, or processed by
+*     hardware. It is considered an error for the application to change BDs
+*     while they are in this group. Doing so can cause data corruption and lead
+*     to system instability.
+*
+*   - Post-process: Those BDs that have been processed by hardware and have
+*     been extracted from the work group with XLlDma_BdRingFromHw(). These BDs
+*     are under application control. The application may access these BDs to
+*     determine the result of DMA transactions. When the application is
+*     finished, XLlDma_BdRingFree() should be called to place them back into
+*     the Free group.
+*
+*
+* Normally BDs are moved in the following way:
+* <pre>
+*
+*         XLlDma_BdRingAlloc()                   XLlDma_BdRingToHw()
+*   Free ------------------------> Pre-process ----------------------> Hardware
+*                                                                      |
+*    /|\                                                               |
+*     |   XLlDma_BdRingFree()                    XLlDma_BdRingFromHw() |
+*     +--------------------------- Post-process <----------------------+
+*
+* </pre>
+*
+* The only exception to the flow above is that after BDs are moved from Free
+* group to Pre-process group, the application decide for whatever reason these
+* BDs are not ready and could not be given to hardware. In this case these BDs
+* could be moved back to Free group using XLlDma_BdRingUnAlloc() function to
+* help keep the BD ring in great shape and recover the error. See comments of
+* the function for details
+*
+* <pre>
+*
+*         XLlDma_BdRingUnAlloc()
+*   Free <----------------------- Pre-process
+*
+* </pre>
+*
+* The API provides macros that allow BD list traversal. These macros should be
+* used with care as they do not understand where one group ends and another
+* begins.
+*
+* The driver does not cache or keep copies of any BD. When the application
+* modifies BDs returned by XLlDma_BdRingAlloc() or XLlDma_BdRingFromHw(), they
+* are modifying the same BD that hardware accesses.
+*
+* Certain pairs of list modification functions have usage restrictions. See
+* the function headers for XLlDma_BdRingAlloc() and XLlDma_BdRingFromHw() for
+* more information.
+*
+* <b>SGDMA Descriptor Ring Creation</b>
+*
+* During initialization, the function XLlDma_BdRingCreate() is used to setup
+* a application supplied memory block to contain all BDs for the DMA channel.
+* This function takes as an argument the number of BDs to place in the list. To
+* arrive at this number, the application is given two methods of calculating
+* it.
+*
+* The first method assumes the application has a block of memory and they just
+* want to fit as many BDs as possible into it. The application must calculate
+* the number of BDs that will fit with XLlDma_mBdRingCntCalc(), then supply
+* that number into the list creation function.
+*
+* The second method allows the application to just supply the number directly.
+* The driver assumes the memory block is large enough to contain them all. To
+* double-check, the application should invoke XLlDma_mBdRingMemCalc() to verify
+* the memory block size is adequate.
+*
+* Once the list has been created, it can be used right away to perform DMA
+* transactions. However, there are optional steps that can be done to increase
+* throughput and decrease application code complexity by the use of
+* XLlDma_BdRingClone().
+*
+* BDs have several application accessible attributes that affect how DMA
+* transactions are carried out. Some of these attributes will probably be
+* constant at run-time. The cloning function can be used to copy a template BD
+* to every BD in the ring relieving the application of having to setup
+* transactions from scratch every time a BD is submitted to hardware.
+*
+* Ideally, the only transaction parameters that need to be set by application
+* should be: buffer address, bytes to transfer, and whether the BD is the
+* Start and/or End of a packet.
+*
+* <b>Interrupt Coalescing</b>
+*
+* SGDMA provides control over the frequency of interrupts. On a high speed link
+* significant processor overhead may be used servicing interrupts. Interrupt
+* coalescing provides two mechanisms that help control interrupt frequency:
+*
+* - The packet threshold counter will hold off interrupting the CPU until a
+*   programmable number of packets have been processed by the engine.
+* - The packet waitbound timer is used to interrupt the CPU if after a
+*   programmable amount of time after processing the last packet, no new
+*   packets were processed.
+*
+* <b>Interrupt Service </b>
+*
+* This driver does not service interrupts. This is done typically by a
+* interrupt handler within a higher level driver/application that uses DMA.
+* This driver does provide an API to enable or disable specific interrupts.
+*
+* This interrupt handler provided by the higher level driver/application
+* !!!MUST!!! clear pending interrupts before handling the BDs processed by the
+* DMA. Otherwise the following corner case could raise some issue:
+*
+* - A packet is transmitted(/received) and asserts a TX(/RX) interrupt, and if
+*   this interrupt handler deals with the BDs finished by the DMA before clears
+*   the interrupt, another packet could get transmitted(/received) and assert
+*   the interrupt between when the BDs are taken care  and when the interrupt
+*   clearing operation begins, and the interrupt clearing operation will clear
+*   the interrupt raised by the second packet and will never process its
+*   according BDs until a new interrupt occurs.
+*
+* Changing the sequence to "Clear interrupts before handle BDs" solves this
+* issue:
+*
+* - If the interrupt raised by the second packet is before the interrupt
+*   clearing operation, the descriptors associated with the second packet must
+*   have been finished by hardware and ready for the handler to deal with,
+*   and those descriptors will processed with those BDs of the first packet
+*   during the handling of the interrupt asserted by the first packet.
+*
+* - if the interrupt of the second packet is asserted after the interrupt
+*   clearing operation but its BDs are finished before the handler starts to
+*   deal with BDs, the packet's buffer descriptors will be handled with
+*   those of the first packet during the handling of the interrupt asserted
+*   by the first packet.
+*
+* - Otherwise, the BDs of the second packet is not ready when the interrupt
+*   handler starts to deal with the BDs of the first packet. Those BDs will
+*   be handled next time the interrupt handled gets invoked as the interrupt
+*   of the second packet is not cleared in current pass and thereby will
+*   cause the handler to get invoked again
+*
+* Please note if the second case above occurs, the handler will find
+* NO buffer descriptor is finished by the hardware (i.e.,
+* XLlDma_BdRingFromHw() returns 0) during the handling of the interrupt
+* asserted by the second packet. This is valid and the application should NOT
+* consider this is a hardware error and have no need to reset the hardware.
+*
+* <b> Software Initialization </b>
+*
+* The application needs to do following steps in order for preparing DMA engine
+* to be ready to process DMA transactions:
+*
+* - DMA Initialization using XLlDma_Initialize() function. This step
+*   initializes a driver instance for the given DMA engine and resets the
+*   engine.
+* - BD Ring creation. A BD ring is needed per channel and can be built by
+*   calling XLlDma_BdRingCreate(). A parameter passed to this function is the
+*   number of BD fit in a given memory range, and XLlDma_mBdRingCntCalc() helps
+*   calculate the value.
+* - (Optional) BD setup using a template. Once a BD ring is created, the
+*   application could populate a template BD and then invoke
+*   XLlDma_BdRingClone() to set the same attributes on all BDs on the BD ring.
+*   This saves the application some effort to populate all fixed attributes of
+*   each BD before passing it to the hardware.
+* - (RX channel only) Prepare BDs with attached data buffers and give them to
+*   RX channel. First allocate BDs using XLlDma_BdRingAlloc(), then populate
+*   data buffer address, data buffer size and the control word fields of each
+*   allocated BD with valid values. Last call XLlDma_BdRingToHw() to give the
+*   BDs to the channel.
+* - Enable interrupts if interrupt mode is chosen. The application is
+*   responsible for setting up the interrupt system, which includes providing
+*   and connecting interrupt handlers and call back functions, before
+*   the interrupts are enabled.
+* - Start DMA channels: Call XLlDma_BdRingStart() to start a channel
+*
+* <b> How to start DMA transactions </b>
+*
+* RX channel is ready to start RX transactions once the initialization (see
+* Initialization section above) is finished. The DMA transactions are triggered
+* by the user IP (like Local Link TEMAC).
+*
+* Starting TX transactions needs some work. The application calls
+* XLlDma_BdRingAlloc() to allocate a BD list, then populates necessary
+* attributes of each allocated BD including data buffer address, data size,
+* and control word, and last passes those BDs to the TX channel
+* (see XLlDma_BdRingToHw()). The added BDs will be processed as soon as the
+* TX channel reaches them.
+*
+* For both channels, If the DMA engine is currently paused (see
+* XLlDma_Pause()), the newly added BDs will be accepted but not processed
+* until the DMA engine is resumed (see XLlDma_Resume()).
+*
+* <b> Software Post-Processing on completed DMA transactions </b>
+*
+* Some software post-processing is needed after DMA transactions are finished.
+*
+* if interrupt system are set up and enabled, DMA channels notify the software
+* the finishing of DMA transactions using interrupts,  Otherwise the
+* application could poll the channels (see XLlDma_BdRingFromHw()).
+*
+* - Once BDs are finished by a channel, the application first needs to fetch
+*   them from the channel (see XLlDma_BdRingFromHw()).
+* - On TX side, the application now could free the data buffers attached to
+*   those BDs as the data in the buffers has been transmitted.
+* - On RX side, the application now could use the received data in the buffers
+*   attached to those BDs
+* - For both channels, those BDs need to be freed back to the Free group (see
+*   XLlDma_BdRingFree()) so they are allocatable for future transactions.
+* - On RX side, it is the application's responsibility for having BDs ready
+*   to receive data at any time. Otherwise the RX channel will refuse to
+*   accept any data once it runs out of RX BDs. As we just freed those hardware
+*   completed BDs in the previous step, it is good timing to allocate them
+*   back (see XLlDma_BdRingAlloc()), prepare them, and feed them to the RX
+*   channel again (see XLlDma_BdRingToHw())
+*
+* <b> Examples </b>
+*
+* Two examples are provided with this driver to demonstrate the driver usage:
+* One for interrupt mode and one for polling mode.
+*
+* <b>Address Translation</b>
+*
+* When the BD list is setup with XLlDma_BdRingCreate(), a physical and
+* virtual address is supplied for the segment of memory containing the
+* descriptors. The driver will handle any translations internally. Subsequent
+* access of descriptors by the application is done in terms of their virtual
+* address.
+*
+* Any application data buffer address attached to a BD must be physical
+* address. The application is responsible for calculating the physical address
+* before assigns it to the buffer address field in the BD.
+*
+* <b>Cache Coherency</b>
+*
+* This driver expects all application buffers attached to BDs to be in cache
+* coherent memory. Buffers for transmit MUST be flushed from the cache before
+* passing the associated BD to this driver. Buffers for receive MUST be
+* invalidated before passing the associated BD to this driver.
+*
+* <b>Alignment</b>
+*
+* For BDs:
+*
+* Minimum alignment is defined by the constant XLLDMA_BD_MINIMUM_ALIGNMENT.
+* This is the smallest alignment allowed by both hardware and software for them
+* to properly work. Other than XLLDMA_BD_MINIMUM_ALIGNMENT, multiples of the
+* constant are the only valid alignments for BDs.
+*
+* If the descriptor ring is to be placed in cached memory, alignment also MUST
+* be at least the processor's cache-line size. If this requirement is not met
+* then system instability will result. This is also true if the length of a BD
+* is longer than one cache-line, in which case multiple cache-lines are needed
+* to accommodate each BD.
+*
+* Aside from the initial creation of the descriptor ring (see
+* XLlDma_BdRingCreate()), there are no other run-time checks for proper
+* alignment.
+*
+* For application data buffers:
+*
+* Application data buffers may reside on any alignment.
+*
+* <b>Reset After Stopping</b>
+*
+* This driver is designed to allow for stop-reset-start cycles of the DMA
+* hardware while keeping the BD list intact. When restarted after a reset, this
+* driver will point the DMA engine to where it left off after stopping it.
+*
+* <b>Limitations</b>
+*
+* This driver only supports Normal mode (i.e., Tail Descriptor Pointer mode).
+* In this mode write of a Tail Descriptor Pointer register (which is done in
+* XLlDma_BdRingStart() and XLlDma_BdRingToHw()) starts DMA transactions.
+*
+* Legacy mode is NOT supported by this driver.
+*
+* This driver does not have any mechanism for mutual exclusion. It is up to the
+* application to provide this protection.
+*
+* <b>Hardware Defaults & Exclusive Use</b>
+*
+* During initialization, this driver will override the following hardware
+* default settings. If desired, the application may change these settings back
+* to their hardware defaults:
+*
+*   - Normal mode (Tail Descriptor Pointer mode) will be enabled.
+*   - Interrupt coalescing timer and counter overflow errors will be disabled
+*     (XLLDMA_DMACR_RX_OVERFLOW_ERR_DIS_MASK and TX_OVERFLOW_ERR_DIS_MASK will
+*     be set to 1). These two items control interrupt "overflow" behavior.
+*     When enabled, the hardware may signal an error if interrupts are not
+*     processed fast enough even though packets were correctly processed. This
+*     error is triggered when certain internal counters overflow. The driver
+*     disables this feature so no such error will be reported.
+*
+* The driver requires exclusive use of the following hardware features. If any
+* are changed by the application then the driver will not operate properly:
+*
+*   - XLLDMA_DMACR_TAIL_PTR_ENABLE_MASK. The driver controls this bit
+*     in the DMACR register.
+*   - XLLDMA_BD_STSCTRL_COMPLETED_MASK. The driver controls this bit in each BD
+*   - XLLDMA_NDESC_OFFSET. The driver controls this register
+*   - XLLDMA_DMACR_SW_RESET_MASK. The driver controls this bit in the DMACR
+*     register
+*
+* <b>BUS Interface</b>
+*
+* The constant CONFIG_XILINX_LLDMA_USE_DCR (see xlldma_hw.h) is used
+* to inform the driver the type of the BUS the DMA device is on. If
+* the DMA device is on DCR BUS, CONFIG_XILINX_LLDMA_USE_DCR must be
+* defined as a compiler option used in the Makefile BEFORE this driver
+* is compiled; Otherwise, the constant must NOT be defined.
+*
+* <b>User-IP Specific Definition</b>
+*
+* This driver relies on two User-IP (like Local-Link TEMAC) specific constants
+* (see xlldma_userip.h) to work properly:
+*
+*   - XLLDMA_USR_APPWORD_OFFSET defines a user word the User-IP always updates
+*     in the RX Buffer Descriptors (BD) during <b>ALL</b> Receive transactions.
+*     This driver uses XLLDMA_BD_USR4_OFFSET as the default value of this
+*     constant.
+*
+*   - XLLDMA_USR_APPWORD_INITVALUE defines the value the DMA driver uses to
+*     populate the XLLDMA_USR_APPWORD_OFFSET field in any RX BD before giving
+*     the BD to the RX channel for receive transaction. It must be ensured
+*     that the User-IP will always populates a different value into the
+*     XLLDMA_USR_APPWORD_OFFSET field during any receive transaction. Failing
+*     to do so will cause the DMA driver to work improperly. This driver uses
+*     0xFFFFFFFF as the default value of this constant.
+*
+* If the User-IP uses different setting, the correct setting must be defined as
+* compiler options used in the Makefile BEFORE this driver is compiled. In
+* either case the default definition of the constants in this driver will be
+* discarded.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   12/21/06 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XLLDMA_H		/* prevent circular inclusions */
+#define XLLDMA_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xlldma_bd.h"
+#include "xlldma_bdring.h"
+#include "xlldma_userip.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+#define XLLDMA_NO_CHANGE            0xFFFF	/* Used as API argument */
+#define XLLDMA_ALL_BDS              0xFFFFFFFF	/* Used as API argument */
+
+/**************************** Type Definitions *******************************/
+
+
+/**
+ * The XLlDma driver instance data. An instance must be allocated for each DMA
+ * engine in use. Each DMA engine includes a TX channel and a RX channel.
+ */
+typedef struct XLlDma {
+	u32 RegBase;		/**< Virtual base address of DMA engine */
+	XLlDma_BdRing TxBdRing;	/**< BD container management for TX channel */
+	XLlDma_BdRing RxBdRing;	/**< BD container management for RX channel */
+
+} XLlDma;
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/****************************************************************************/
+/**
+* Retrieve the TX ring object. This object can be used in the various Ring
+* API functions.
+*
+* @param  InstancePtr is the DMA engine to operate on.
+*
+* @return TxBdRing object
+*
+* @note
+* C-style signature:
+*    XLlDma_BdRing XLlDma_mGetTxRing(XLlDma* InstancePtr)
+*
+*****************************************************************************/
+#define XLlDma_mGetTxRing(InstancePtr) ((InstancePtr)->TxBdRing)
+
+
+/****************************************************************************/
+/**
+* Retrieve the RX ring object. This object can be used in the various Ring
+* API functions.
+*
+* @param  InstancePtr is the DMA engine to operate on.
+*
+* @return RxBdRing object
+*
+* @note
+* C-style signature:
+*    XLlDma_BdRing XLlDma_mGetRxRing(XLlDma* InstancePtr)
+*
+*****************************************************************************/
+#define XLlDma_mGetRxRing(InstancePtr) ((InstancePtr)->RxBdRing)
+
+
+/****************************************************************************/
+/**
+* Retrieve the contents of the DMA engine control register
+* (XLLDMA_DMACR_OFFSET).
+*
+* @param  InstancePtr is the DMA engine instance to operate on.
+*
+* @return Current contents of the DMA engine control register.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mGetCr(XLlDma* InstancePtr)
+*
+*****************************************************************************/
+#define XLlDma_mGetCr(InstancePtr)                                      \
+	XLlDma_mReadReg((InstancePtr)->RegBase, XLLDMA_DMACR_OFFSET)
+
+
+/****************************************************************************/
+/**
+* Set the contents of the DMA engine control register (XLLDMA_DMACR_OFFSET).
+* This control register affects both DMA channels.
+*
+* @param  InstancePtr is the DMA engine instance to operate on.
+* @param  Data is the data to write to the DMA engine control register.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mSetCr(XLlDma* InstancePtr, u32 Data)
+*
+*****************************************************************************/
+#define XLlDma_mSetCr(InstancePtr, Data)                                \
+	XLlDma_mWriteReg((InstancePtr)->RegBase, XLLDMA_DMACR_OFFSET, (Data))
+
+
+/************************** Function Prototypes ******************************/
+
+/*
+ * Initialization and control functions in xlldma.c
+ */
+void XLlDma_Initialize(XLlDma * InstancePtr, u32 BaseAddress);
+void XLlDma_Reset(XLlDma * InstancePtr);
+void XLlDma_Pause(XLlDma * InstancePtr);
+void XLlDma_Resume(XLlDma * InstancePtr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xlldma_bd.h b/drivers/xilinx_common/xlldma_bd.h
new file mode 100644
index 0000000..2d33d9a
--- /dev/null
+++ b/drivers/xilinx_common/xlldma_bd.h
@@ -0,0 +1,302 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file xlldma_bd.h
+ *
+ * This header provides operations to manage buffer descriptors (BD) in support
+ * of Local-Link scatter-gather DMA (see xlldma.h).
+ *
+ * The API exported by this header defines abstracted macros that allow the
+ * application to read/write specific BD fields.
+ *
+ * <b>Buffer Descriptors</b>
+ *
+ * A buffer descriptor defines a DMA transaction (see "Transaction"
+ * section in xlldma.h). The macros defined by this header file allow access
+ * to most fields within a BD to tailor a DMA transaction according to
+ * application and hardware requirements.  See the hardware IP DMA spec for
+ * more information on BD fields and how they affect transfers.
+ *
+ * The XLlDma_Bd structure defines a BD. The organization of this structure is
+ * driven mainly by the hardware for use in scatter-gather DMA transfers.
+ *
+ * <b>Accessor Macros</b>
+ *
+ * Most of the BD attributes can be accessed through macro functions defined
+ * here in this API. Words such as XLLDMA_BD_USR1_OFFSET (see xlldma_hw.h)
+ * should be accessed using XLlDma_mBdRead() and XLlDma_mBdWrite() as defined
+ * in xlldma_hw.h. The USR words are implementation dependent. For example,
+ * they may implement checksum offloading fields for Ethernet devices. Accessor
+ * macros may be defined in the device specific API to get at this data.
+ *
+ * <b>Performance</b>
+ *
+ * BDs are typically in a non-cached memory space. Limiting I/O to BDs can
+ * improve overall performance of the DMA channel.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a xd   12/21/06 First release
+ * </pre>
+ *
+ *****************************************************************************/
+
+#ifndef XLLDMA_BD_H		/* prevent circular inclusions */
+#define XLLDMA_BD_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xenv.h"
+#include "xlldma_hw.h"
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * The XLlDma_Bd is the type for buffer descriptors (BDs).
+ */
+typedef u32 XLlDma_Bd[XLLDMA_BD_NUM_WORDS];
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* Read the given Buffer Descriptor word.
+*
+* @param    BaseAddress is the base address of the BD to read
+* @param    Offset is the word offset to be read
+*
+* @return   The 32-bit value of the field
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRead(u32 BaseAddress, u32 Offset)
+*
+******************************************************************************/
+#define XLlDma_mBdRead(BaseAddress, Offset)				\
+	(*(u32*)((u32)(BaseAddress) + (u32)(Offset)))
+
+
+/*****************************************************************************/
+/**
+*
+* Write the given Buffer Descriptor word.
+*
+* @param    BaseAddress is the base address of the BD to write
+* @param    Offset is the word offset to be written
+* @param    Data is the 32-bit value to write to the field
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    void XLlDma_mBdWrite(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+******************************************************************************/
+#define XLlDma_mBdWrite(BaseAddress, Offset, Data)			\
+	(*(u32*)((u32)(BaseAddress) + (u32)(Offset)) = (Data))
+
+
+/*****************************************************************************/
+/**
+ * Zero out all BD fields
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Nothing
+ *
+ * @note
+ * C-style signature:
+ *    void XLlDma_mBdClear(XLlDma_Bd* BdPtr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdClear(BdPtr)                    \
+	memset((BdPtr), 0, sizeof(XLlDma_Bd))
+
+
+/*****************************************************************************/
+/**
+ * Set the BD's STS/CTRL field. The word containing STS/CTRL also contains the
+ * USR0 field. USR0 will not be modified. This operation requires a read-
+ * modify-write operation. If it is wished to set both STS/CTRL and USR0 with
+ * a single write operation, then use XLlDma_mBdWrite(BdPtr,
+ * XLLDMA_BD_STSCTRL_USR0_OFFSET, Data).
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Data is the value to write to STS/CTRL. Or 0 or more
+ *         XLLDMA_BD_STSCTRL_*** values defined in xlldma_hw.h to create a
+ *         valid value for this parameter
+ *
+ * @note
+ * C-style signature:
+ *    u32 XLlDma_mBdSetStsCtrl(XLlDma_Bd* BdPtr, u32 Data)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdSetStsCtrl(BdPtr, Data)                                   \
+	XLlDma_mBdWrite((BdPtr), XLLDMA_BD_STSCTRL_USR0_OFFSET,             \
+		(XLlDma_mBdRead((BdPtr), XLLDMA_BD_STSCTRL_USR0_OFFSET)     \
+		& XLLDMA_BD_STSCTRL_USR0_MASK) |			    \
+		((Data) & XLLDMA_BD_STSCTRL_MASK))
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the word containing the BD's STS/CTRL field. This word also
+ * contains the USR0 field.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Word at offset XLLDMA_BD_DMASR_OFFSET. Use XLLDMA_BD_STSCTRL_***
+ *         values defined in xlldma_hw.h to interpret this returned value
+ *
+ * @note
+ * C-style signature:
+ *    u32 XLlDma_mBdGetStsCtrl(XLlDma_Bd* BdPtr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdGetStsCtrl(BdPtr)              \
+	XLlDma_mBdRead((BdPtr), XLLDMA_BD_STSCTRL_USR0_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Set transfer length in bytes for the given BD. The length must be set each
+ * time a BD is submitted to hardware.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  LenBytes is the number of bytes to transfer.
+ *
+ * @note
+ * C-style signature:
+ *    void XLlDma_mBdSetLength(XLlDma_Bd* BdPtr, u32 LenBytes)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdSetLength(BdPtr, LenBytes)                            \
+	XLlDma_mBdWrite((BdPtr), XLLDMA_BD_BUFL_OFFSET, (LenBytes))
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the BD length field.
+ *
+ * For TX channels, the returned value is the same as that written with
+ * XLlDma_mBdSetLength().
+ *
+ * For RX channels, the returned value is what was written by the DMA engine
+ * after processing the BD. This value represents the number of bytes
+ * processed.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @return Bytes processed by hardware or set by XLlDma_mBdSetLength().
+ *
+ * @note
+ * C-style signature:
+ *    u32 XLlDma_mBdGetLength(XLlDma_Bd* BdPtr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdGetLength(BdPtr)                      \
+	XLlDma_mBdRead((BdPtr), XLLDMA_BD_BUFL_OFFSET)
+
+
+/*****************************************************************************/
+/**
+ * Set the ID field of the given BD. The ID is an arbitrary piece of data the
+ * application can associate with a specific BD.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Id is a 32 bit quantity to set in the BD
+ *
+ * @note
+ * C-style signature:
+ *    void XLlDma_mBdSetId(XLlDma_Bd* BdPtr, void Id)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdSetId(BdPtr, Id)                                      \
+	(XLlDma_mBdWrite((BdPtr), XLLDMA_BD_ID_OFFSET, (u32)(Id)))
+
+
+/*****************************************************************************/
+/**
+ * Retrieve the ID field of the given BD previously set with XLlDma_mBdSetId.
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    u32 XLlDma_mBdGetId(XLlDma_Bd* BdPtr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdGetId(BdPtr) (XLlDma_mBdRead((BdPtr), XLLDMA_BD_ID_OFFSET))
+
+
+/*****************************************************************************/
+/**
+ * Set the BD's buffer address.
+ *
+ * @param  BdPtr is the BD to operate on
+ * @param  Addr is the address to set
+ *
+ * @note
+ * C-style signature:
+ *    void XLlDma_mBdSetBufAddr(XLlDma_Bd* BdPtr, u32 Addr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdSetBufAddr(BdPtr, Addr)                               \
+	(XLlDma_mBdWrite((BdPtr), XLLDMA_BD_BUFA_OFFSET, (u32)(Addr)))
+
+
+/*****************************************************************************/
+/**
+ * Get the BD's buffer address
+ *
+ * @param  BdPtr is the BD to operate on
+ *
+ * @note
+ * C-style signature:
+ *    u32 XLlDma_mBdGetBufAddrLow(XLlDma_Bd* BdPtr)
+ *
+ *****************************************************************************/
+#define XLlDma_mBdGetBufAddr(BdPtr)                     \
+	(XLlDma_mBdRead((BdPtr), XLLDMA_BD_BUFA_OFFSET))
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xlldma_bdring.c b/drivers/xilinx_common/xlldma_bdring.c
new file mode 100644
index 0000000..1f5a29a
--- /dev/null
+++ b/drivers/xilinx_common/xlldma_bdring.c
@@ -0,0 +1,1124 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xlldma_bdring.c
+*
+* This file implements buffer descriptor ring related functions. For more
+* information on this driver, see xlldma.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   12/21/06 First release
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include <linux/string.h>
+
+#include "xlldma.h"
+#include "xenv.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/******************************************************************************
+ * Define methods to flush and invalidate cache for BDs should they be
+ * located in cached memory. These macros may NOPs if the underlying
+ * XCACHE_FLUSH_DCACHE_RANGE and XCACHE_INVALIDATE_DCACHE_RANGE macros are not
+ * implemented or they do nothing.
+ *****************************************************************************/
+#ifdef XCACHE_FLUSH_DCACHE_RANGE
+#  define XLLDMA_CACHE_FLUSH(BdPtr)               \
+	XCACHE_FLUSH_DCACHE_RANGE((BdPtr), XLLDMA_BD_HW_NUM_BYTES)
+#else
+#  define XLLDMA_CACHE_FLUSH(BdPtr)
+#endif
+
+#ifdef XCACHE_INVALIDATE_DCACHE_RANGE
+#  define XLLDMA_CACHE_INVALIDATE(BdPtr)          \
+	XCACHE_INVALIDATE_DCACHE_RANGE((BdPtr), XLLDMA_BD_HW_NUM_BYTES)
+#else
+#  define XLLDMA_CACHE_INVALIDATE(BdPtr)
+#endif
+
+/******************************************************************************
+ * Compute the virtual address of a descriptor from its physical address
+ *
+ * @param BdPtr is the physical address of the BD
+ *
+ * @returns Virtual address of BdPtr
+ *
+ * @note Assume BdPtr is always a valid BD in the ring
+ * @note RingPtr is an implicit parameter
+ *****************************************************************************/
+#define XLLDMA_PHYS_TO_VIRT(BdPtr) \
+	((u32)(BdPtr) + (RingPtr->FirstBdAddr - RingPtr->FirstBdPhysAddr))
+
+/******************************************************************************
+ * Compute the physical address of a descriptor from its virtual address
+ *
+ * @param BdPtr is the virtual address of the BD
+ *
+ * @returns Physical address of BdPtr
+ *
+ * @note Assume BdPtr is always a valid BD in the ring
+ * @note RingPtr is an implicit parameter
+ *****************************************************************************/
+#define XLLDMA_VIRT_TO_PHYS(BdPtr) \
+	((u32)(BdPtr) - (RingPtr->FirstBdAddr - RingPtr->FirstBdPhysAddr))
+
+/******************************************************************************
+ * Move the BdPtr argument ahead an arbitrary number of BDs wrapping around
+ * to the beginning of the ring if needed.
+ *
+ * We know if a wraparound should occur if the new BdPtr is greater than
+ * the high address in the ring OR if the new BdPtr crosses the 0xFFFFFFFF
+ * to 0 boundary.
+ *
+ * @param RingPtr is the ring BdPtr appears in
+ * @param BdPtr on input is the starting BD position and on output is the
+ *        final BD position
+ * @param NumBd is the number of BD spaces to increment
+ *
+ *****************************************************************************/
+#define XLLDMA_RING_SEEKAHEAD(RingPtr, BdPtr, NumBd)			    \
+	{								    \
+		u32 Addr = (u32)(BdPtr);				    \
+									    \
+		Addr += ((RingPtr)->Separation * (NumBd));		    \
+		if ((Addr > (RingPtr)->LastBdAddr) || ((u32)(BdPtr) > Addr))\
+		{							    \
+			Addr -= (RingPtr)->Length;			    \
+		}							    \
+									    \
+		(BdPtr) = (XLlDma_Bd*)Addr;				    \
+	}
+
+/******************************************************************************
+ * Move the BdPtr argument backwards an arbitrary number of BDs wrapping
+ * around to the end of the ring if needed.
+ *
+ * We know if a wraparound should occur if the new BdPtr is less than
+ * the base address in the ring OR if the new BdPtr crosses the 0xFFFFFFFF
+ * to 0 boundary.
+ *
+ * @param RingPtr is the ring BdPtr appears in
+ * @param BdPtr on input is the starting BD position and on output is the
+ *        final BD position
+ * @param NumBd is the number of BD spaces to increment
+ *
+ *****************************************************************************/
+#define XLLDMA_RING_SEEKBACK(RingPtr, BdPtr, NumBd)			      \
+	{                                                                     \
+		u32 Addr = (u32)(BdPtr);				      \
+									      \
+		Addr -= ((RingPtr)->Separation * (NumBd));		      \
+		if ((Addr < (RingPtr)->FirstBdAddr) || ((u32)(BdPtr) < Addr)) \
+		{							      \
+			Addr += (RingPtr)->Length;			      \
+		}							      \
+									      \
+		(BdPtr) = (XLlDma_Bd*)Addr;				      \
+	}
+
+
+/************************** Function Prototypes ******************************/
+
+
+/************************** Variable Definitions *****************************/
+
+
+/*****************************************************************************/
+/**
+ * Using a memory segment allocated by the caller, create and setup the BD list
+ * for the given SGDMA ring.
+ *
+ * @param InstancePtr is the instance to be worked on.
+ * @param PhysAddr is the physical base address of application memory region.
+ * @param VirtAddr is the virtual base address of the application memory
+ *        region.If address translation is not being utilized, then VirtAddr
+ *        should be equivalent to PhysAddr.
+ * @param Alignment governs the byte alignment of individual BDs. This function
+ *        will enforce a minimum alignment of XLLDMA_BD_MINIMUM_ALIGNMENT bytes
+ *        with no maximum as long as it is specified as a power of 2.
+ * @param BdCount is the number of BDs to setup in the application memory
+ *        region. It is assumed the region is large enough to contain the BDs.
+ *        Refer to the "SGDMA Ring Creation" section  in xlldma.h for more
+ *        information. The minimum valid value for this parameter is 1.
+ *
+ * @return
+ *
+ * - XST_SUCCESS if initialization was successful
+ * - XST_NO_FEATURE if the provided instance is a non SGDMA type of DMA
+ *   channel.
+ * - XST_INVALID_PARAM under any of the following conditions: 1) PhysAddr
+ *   and/or VirtAddr are not aligned to the given Alignment parameter;
+ *   2) Alignment parameter does not meet minimum requirements or is not a
+ *   power of 2 value; 3) BdCount is 0.
+ * - XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans
+ *   over address 0x00000000 in virtual address space.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingCreate(XLlDma_BdRing * RingPtr, u32 PhysAddr,
+			u32 VirtAddr, u32 Alignment, unsigned BdCount)
+{
+	unsigned i;
+	u32 BdVirtAddr;
+	u32 BdPhysAddr;
+
+	/* In case there is a failure prior to creating list, make sure the
+	 * following attributes are 0 to prevent calls to other SG functions
+	 * from doing anything
+	 */
+	RingPtr->AllCnt = 0;
+	RingPtr->FreeCnt = 0;
+	RingPtr->HwCnt = 0;
+	RingPtr->PreCnt = 0;
+	RingPtr->PostCnt = 0;
+
+	/* Make sure Alignment parameter meets minimum requirements */
+	if (Alignment < XLLDMA_BD_MINIMUM_ALIGNMENT) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Make sure Alignment is a power of 2 */
+	if ((Alignment - 1) & Alignment) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Make sure PhysAddr and VirtAddr are on same Alignment */
+	if ((PhysAddr % Alignment) || (VirtAddr % Alignment)) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Is BdCount reasonable? */
+	if (BdCount == 0) {
+		return (XST_INVALID_PARAM);
+	}
+
+	/* Compute how many bytes will be between the start of adjacent BDs */
+	RingPtr->Separation =
+		(sizeof(XLlDma_Bd) + (Alignment - 1)) & ~(Alignment - 1);
+
+	/* Must make sure the ring doesn't span address 0x00000000. If it does,
+	 * then the next/prev BD traversal macros will fail.
+	 */
+	if (VirtAddr > (VirtAddr + (RingPtr->Separation * BdCount) - 1)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Initial ring setup:
+	 *  - Clear the entire space
+	 *  - Setup each BD's next pointer with the physical address of the
+	 *    next BD
+	 *  - Set each BD's DMA complete status bit
+	 */
+	memset((void *) VirtAddr, 0, (RingPtr->Separation * BdCount));
+
+	BdVirtAddr = VirtAddr;
+	BdPhysAddr = PhysAddr + RingPtr->Separation;
+	for (i = 1; i < BdCount; i++) {
+		XLlDma_mBdWrite(BdVirtAddr, XLLDMA_BD_NDESC_OFFSET, BdPhysAddr);
+		XLlDma_mBdWrite(BdVirtAddr, XLLDMA_BD_STSCTRL_USR0_OFFSET,
+				XLLDMA_BD_STSCTRL_COMPLETED_MASK);
+		XLLDMA_CACHE_FLUSH(BdVirtAddr);
+		BdVirtAddr += RingPtr->Separation;
+		BdPhysAddr += RingPtr->Separation;
+	}
+
+	/* At the end of the ring, link the last BD back to the top */
+	XLlDma_mBdWrite(BdVirtAddr, XLLDMA_BD_NDESC_OFFSET, PhysAddr);
+	XLLDMA_CACHE_FLUSH(BdVirtAddr);
+
+	/* Setup and initialize pointers and counters */
+	RingPtr->RunState = XST_DMA_SG_IS_STOPPED;
+	RingPtr->FirstBdAddr = VirtAddr;
+	RingPtr->FirstBdPhysAddr = PhysAddr;
+	RingPtr->LastBdAddr = BdVirtAddr;
+	RingPtr->Length = RingPtr->LastBdAddr - RingPtr->FirstBdAddr +
+		RingPtr->Separation;
+	RingPtr->AllCnt = BdCount;
+	RingPtr->FreeCnt = BdCount;
+	RingPtr->FreeHead = (XLlDma_Bd *) VirtAddr;
+	RingPtr->PreHead = (XLlDma_Bd *) VirtAddr;
+	RingPtr->HwHead = (XLlDma_Bd *) VirtAddr;
+	RingPtr->HwTail = (XLlDma_Bd *) VirtAddr;
+	RingPtr->PostHead = (XLlDma_Bd *) VirtAddr;
+	RingPtr->BdaRestart = (XLlDma_Bd *) PhysAddr;
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Clone the given BD into every BD in the ring. Except for
+ * XLLDMA_BD_NDESC_OFFSET, every field of the source BD is replicated in every
+ * BD in the ring.
+ *
+ * This function can be called only when all BDs are in the free group such as
+ * they are immediately after creation of the ring. This prevents modification
+ * of BDs while they are in use by hardware or the application.
+ *
+ * @param InstancePtr is the instance to be worked on.
+ * @param SrcBdPtr is the source BD template to be cloned into the list.
+ *
+ * @return
+ *   - XST_SUCCESS if the list was modified.
+ *   - XST_DMA_SG_NO_LIST if a list has not been created.
+ *   - XST_DMA_SG_LIST_ERROR if some of the BDs in this channel are under
+ *     hardware or application control.
+ *   - XST_DEVICE_IS_STARTED if the DMA channel has not been stopped.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingClone(XLlDma_BdRing * RingPtr, XLlDma_Bd * SrcBdPtr)
+{
+	unsigned i;
+	u32 CurBd;
+	u32 Save;
+	XLlDma_Bd TmpBd;
+
+	/* Can't do this function if there isn't a ring */
+	if (RingPtr->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Can't do this function with the channel running */
+	if (RingPtr->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_DEVICE_IS_STARTED);
+	}
+
+	/* Can't do this function with some of the BDs in use */
+	if (RingPtr->FreeCnt != RingPtr->AllCnt) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+
+	/* Make a copy of the template then modify it by setting complete bit
+	 * in status/control field
+	 */
+	memcpy(&TmpBd, SrcBdPtr, sizeof(XLlDma_Bd));
+	Save = XLlDma_mBdRead(&TmpBd, XLLDMA_BD_STSCTRL_USR0_OFFSET);
+	Save |= XLLDMA_BD_STSCTRL_COMPLETED_MASK;
+	XLlDma_mBdWrite(&TmpBd, XLLDMA_BD_STSCTRL_USR0_OFFSET, Save);
+
+	/* Starting from the top of the ring, save BD.Next, overwrite the
+	 * entire BD with the template, then restore BD.Next
+	 */
+	for (i = 0, CurBd = RingPtr->FirstBdAddr;
+	     i < RingPtr->AllCnt; i++, CurBd += RingPtr->Separation) {
+		Save = XLlDma_mBdRead(CurBd, XLLDMA_BD_NDESC_OFFSET);
+		memcpy((void *) CurBd, (void *) &TmpBd, sizeof(XLlDma_Bd));
+		XLlDma_mBdWrite(CurBd, XLLDMA_BD_NDESC_OFFSET, Save);
+		XLLDMA_CACHE_FLUSH(CurBd);
+	}
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Allow DMA transactions to commence on the given channels if descriptors are
+ * ready to be processed.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ *
+ * @return
+ * - XST_SUCCESS if the channel) were started.
+ * - XST_DMA_SG_NO_LIST if the channel) have no initialized BD ring.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingStart(XLlDma_BdRing * RingPtr)
+{
+	/* BD list has yet to be created for this channel */
+	if (RingPtr->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Do nothing if already started */
+	if (RingPtr->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_SUCCESS);
+	}
+
+	/* Sync hardware and driver with the last unprocessed BD or the 1st BD
+	 * in the ring if this is the first time starting the channel
+	 */
+	XLlDma_mWriteReg(RingPtr->ChanBase, XLLDMA_CDESC_OFFSET,
+			 (u32) RingPtr->BdaRestart);
+
+	/* Note as started */
+	RingPtr->RunState = XST_DMA_SG_IS_STARTED;
+
+	/* If there are unprocessed BDs then we want to channel to begin
+	 * processing right away
+	 */
+	if (RingPtr->HwCnt > 0) {
+		XLLDMA_CACHE_INVALIDATE(RingPtr->HwTail);
+
+		if ((XLlDma_mBdRead(RingPtr->HwTail,
+				    XLLDMA_BD_STSCTRL_USR0_OFFSET) &
+		     XLLDMA_BD_STSCTRL_COMPLETED_MASK) == 0) {
+			XLlDma_mWriteReg(RingPtr->ChanBase,
+					 XLLDMA_TDESC_OFFSET,
+					 XLLDMA_VIRT_TO_PHYS(RingPtr->HwTail));
+		}
+	}
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Set interrupt coalescing parameters for the given descriptor ring channel.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param Counter sets the packet counter on the channel. Valid range is
+ *        1..255, or XLLDMA_NO_CHANGE to leave this setting unchanged.
+ * @param Timer sets the waitbound timer on the channel. Valid range is
+ *        1..255, or XLLDMA_NO_CHANGE to leave this setting unchanged. LSB is
+ *        in units of 1 / (local link clock).
+ *
+ * @return
+ *        - XST_SUCCESS if interrupt coalescing settings updated
+ *        - XST_FAILURE if Counter or Timer parameters are out of range
+ *****************************************************************************/
+int XLlDma_BdRingSetCoalesce(XLlDma_BdRing * RingPtr, u32 Counter, u32 Timer)
+{
+	u32 Cr = XLlDma_mReadReg(RingPtr->ChanBase, XLLDMA_CR_OFFSET);
+
+	if (Counter != XLLDMA_NO_CHANGE) {
+		if ((Counter == 0) || (Counter > 0xFF)) {
+			return (XST_FAILURE);
+		}
+
+		Cr = (Cr & ~XLLDMA_CR_IRQ_COUNT_MASK) |
+			(Counter << XLLDMA_CR_IRQ_COUNT_SHIFT);
+		Cr |= XLLDMA_CR_LD_IRQ_CNT_MASK;
+	}
+
+	if (Timer != XLLDMA_NO_CHANGE) {
+		if ((Timer == 0) || (Timer > 0xFF)) {
+			return (XST_FAILURE);
+		}
+
+		Cr = (Cr & ~XLLDMA_CR_IRQ_TIMEOUT_MASK) |
+			(Timer << XLLDMA_CR_IRQ_TIMEOUT_SHIFT);
+		Cr |= XLLDMA_CR_LD_IRQ_CNT_MASK;
+	}
+
+	XLlDma_mWriteReg(RingPtr->ChanBase, XLLDMA_CR_OFFSET, Cr);
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Retrieve current interrupt coalescing parameters from the given descriptor
+ * ring channel.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param CounterPtr points to a memory location where the current packet
+ *        counter will be written.
+ * @param TimerPtr points to a memory location where the current waitbound
+ *        timer will be written.
+ *****************************************************************************/
+void XLlDma_BdRingGetCoalesce(XLlDma_BdRing * RingPtr,
+			      u32 *CounterPtr, u32 *TimerPtr)
+{
+	u32 Cr = XLlDma_mReadReg(RingPtr->ChanBase, XLLDMA_CR_OFFSET);
+
+	*CounterPtr =
+		((Cr & XLLDMA_CR_IRQ_COUNT_MASK) >> XLLDMA_CR_IRQ_COUNT_SHIFT);
+	*TimerPtr =
+		((Cr & XLLDMA_CR_IRQ_TIMEOUT_MASK) >>
+		 XLLDMA_CR_IRQ_TIMEOUT_SHIFT);
+}
+
+
+/*****************************************************************************/
+/**
+ * Reserve locations in the BD ring. The set of returned BDs may be modified in
+ * preparation for future DMA transactions). Once the BDs are ready to be
+ * submitted to hardware, the application must call XLlDma_BdRingToHw() in the
+ * same order which they were allocated here. Example:
+ *
+ * <pre>
+ *        NumBd = 2;
+ *        Status = XDsma_RingBdAlloc(MyRingPtr, NumBd, &MyBdSet);
+ *
+ *        if (Status != XST_SUCCESS)
+ *        {
+ *            // Not enough BDs available for the request
+ *        }
+ *
+ *        CurBd = MyBdSet;
+ *        for (i=0; i<NumBd; i++)
+ *        {
+ *            // Prepare CurBd.....
+ *
+ *            // Onto next BD
+ *            CurBd = XLlDma_mBdRingNext(MyRingPtr, CurBd);
+ *        }
+ *
+ *        // Give list to hardware
+ *        Status = XLlDma_BdRingToHw(MyRingPtr, NumBd, MyBdSet);
+ * </pre>
+ *
+ * A more advanced use of this function may allocate multiple sets of BDs.
+ * They must be allocated and given to hardware in the correct sequence:
+ * <pre>
+ *        // Legal
+ *        XLlDma_BdRingAlloc(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);
+ *
+ *        // Legal
+ *        XLlDma_BdRingAlloc(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingAlloc(MyRingPtr, NumBd2, &MySet2);
+ *        XLlDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);
+ *        XLlDma_BdRingToHw(MyRingPtr, NumBd2, MySet2);
+ *
+ *        // Not legal
+ *        XLlDma_BdRingAlloc(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingAlloc(MyRingPtr, NumBd2, &MySet2);
+ *        XLlDma_BdRingToHw(MyRingPtr, NumBd2, MySet2);
+ *        XLlDma_BdRingToHw(MyRingPtr, NumBd1, MySet1);
+ * </pre>
+ *
+ * Use the API defined in xlldmabd.h to modify individual BDs. Traversal of the
+ * BD set can be done using XLlDma_mBdRingNext() and XLlDma_mBdRingPrev().
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param NumBd is the number of BDs to allocate
+ * @param BdSetPtr is an output parameter, it points to the first BD available
+ *        for modification.
+ *
+ * @return
+ *   - XST_SUCCESS if the requested number of BDs was returned in the BdSetPtr
+ *     parameter.
+ *   - XST_FAILURE if there were not enough free BDs to satisfy the request.
+ *
+ * @note This function should not be preempted by another XLlDma_BdRing
+ *       function call that modifies the BD space. It is the caller's
+ *       responsibility to provide a mutual exclusion mechanism.
+ *
+ * @note Do not modify more BDs than the number requested with the NumBd
+ *       parameter. Doing so will lead to data corruption and system
+ *       instability.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingAlloc(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		       XLlDma_Bd ** BdSetPtr)
+{
+	/* Enough free BDs available for the request? */
+	if (RingPtr->FreeCnt < NumBd) {
+		return (XST_FAILURE);
+	}
+
+	/* Set the return argument and move FreeHead forward */
+	*BdSetPtr = RingPtr->FreeHead;
+	XLLDMA_RING_SEEKAHEAD(RingPtr, RingPtr->FreeHead, NumBd);
+	RingPtr->FreeCnt -= NumBd;
+	RingPtr->PreCnt += NumBd;
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Fully or partially undo an XLlDma_BdRingAlloc() operation. Use this function
+ * if all the BDs allocated by XLlDma_BdRingAlloc() could not be transferred to
+ * hardware with XLlDma_BdRingToHw().
+ *
+ * This function helps out in situations when an unrelated error occurs after
+ * BDs have been allocated but before they have been given to hardware.
+ *
+ * This function is not the same as XLlDma_BdRingFree(). The Free function
+ * returns BDs to the free list after they have been processed by hardware,
+ * while UnAlloc returns them before being processed by hardware.
+ *
+ * There are two scenarios where this function can be used. Full UnAlloc or
+ * Partial UnAlloc. A Full UnAlloc means all the BDs Alloc'd will be returned:
+ *
+ * <pre>
+ *    Status = XLlDma_BdRingAlloc(MyRingPtr, 10, &BdPtr);
+ *        .
+ *        .
+ *    if (Error)
+ *    {
+ *        Status = XLlDma_BdRingUnAlloc(MyRingPtr, 10, &BdPtr);
+ *    }
+ * </pre>
+ *
+ * A partial UnAlloc means some of the BDs Alloc'd will be returned:
+ *
+ * <pre>
+ *    Status = XLlDma_BdRingAlloc(MyRingPtr, 10, &BdPtr);
+ *    BdsLeft = 10;
+ *    CurBdPtr = BdPtr;
+ *
+ *    while (BdsLeft)
+ *    {
+ *       if (Error)
+ *       {
+ *          Status = XLlDma_BdRingUnAlloc(MyRingPtr, BdsLeft, CurBdPtr);
+ *       }
+ *
+ *       CurBdPtr = XLlDma_mBdRingNext(MyRingPtr, CurBdPtr);
+ *       BdsLeft--;
+ *    }
+ * </pre>
+ *
+ * A partial UnAlloc must include the last BD in the list that was Alloc'd.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param NumBd is the number of BDs to unallocate
+ * @param BdSetPtr points to the first of the BDs to be returned.
+ *
+ * @return
+ *   - XST_SUCCESS if the BDs were unallocated.
+ *   - XST_FAILURE if NumBd parameter was greater that the number of BDs in the
+ *     preprocessing state.
+ *
+ * @note This function should not be preempted by another XLlDma ring function
+ *       call that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingUnAlloc(XLlDma_BdRing * RingPtr, unsigned NumBd,
+			 XLlDma_Bd * BdSetPtr)
+{
+	/* Enough BDs in the free state for the request? */
+	if (RingPtr->PreCnt < NumBd) {
+		return (XST_FAILURE);
+	}
+
+	/* Set the return argument and move FreeHead backward */
+	XLLDMA_RING_SEEKBACK(RingPtr, RingPtr->FreeHead, NumBd);
+	RingPtr->FreeCnt += NumBd;
+	RingPtr->PreCnt -= NumBd;
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Enqueue a set of BDs to hardware that were previously allocated by
+ * XLlDma_BdRingAlloc(). Once this function returns, the argument BD set goes
+ * under hardware control. Any changes made to these BDs after this point will
+ * corrupt the BD list leading to data corruption and system instability.
+ *
+ * The set will be rejected if the last BD of the set does not mark the end of
+ * a packet.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param NumBd is the number of BDs in the set.
+ * @param BdSetPtr is the first BD of the set to commit to hardware.
+ *
+ * @return
+ *   - XST_SUCCESS if the set of BDs was accepted and enqueued to hardware
+ *   - XST_FAILURE if the set of BDs was rejected because the first BD
+ *     did not have its start-of-packet bit set, the last BD did not have
+ *     its end-of-packet bit set, or any one of the BD set has 0 as length
+ *     value
+ *   - XST_DMA_SG_LIST_ERROR if this function was called out of sequence with
+ *     XLlDma_BdRingAlloc()
+ *
+ * @note This function should not be preempted by another XLlDma ring function
+ *       call that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingToHw(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		      XLlDma_Bd * BdSetPtr)
+{
+	XLlDma_Bd *CurBdPtr;
+	unsigned i;
+	u32 BdStsCr;
+
+	/* If the commit set is empty, do nothing */
+	if (NumBd == 0) {
+		return (XST_SUCCESS);
+	}
+
+	/* Make sure we are in sync with XLlDma_BdRingAlloc() */
+	if ((RingPtr->PreCnt < NumBd) || (RingPtr->PreHead != BdSetPtr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	CurBdPtr = BdSetPtr;
+	BdStsCr = XLlDma_mBdRead(CurBdPtr, XLLDMA_BD_STSCTRL_USR0_OFFSET);
+
+	/* The first BD should have been marked as start-of-packet */
+	if (!(BdStsCr & XLLDMA_BD_STSCTRL_SOP_MASK)) {
+		return (XST_FAILURE);
+	}
+
+	/* For each BD being submitted except the last one, clear the completed
+	 * bit and stop_on_end bit in the status word
+	 */
+	for (i = 0; i < NumBd - 1; i++) {
+
+		/* Make sure the length value in the BD is non-zero. */
+		if (XLlDma_mBdGetLength(CurBdPtr) == 0) {
+			return (XST_FAILURE);
+		}
+
+		BdStsCr &=
+			~(XLLDMA_BD_STSCTRL_COMPLETED_MASK |
+			  XLLDMA_BD_STSCTRL_SOE_MASK);
+		XLlDma_mBdWrite(CurBdPtr, XLLDMA_BD_STSCTRL_USR0_OFFSET,
+				BdStsCr);
+
+		/* In RX channel case, the current BD should have the
+		 * XLLDMA_USERIP_APPWORD_OFFSET initialized to
+		 * XLLDMA_USERIP_APPWORD_INITVALUE
+		 */
+		if (RingPtr->IsRxChannel) {
+			XLlDma_mBdWrite(CurBdPtr, XLLDMA_USERIP_APPWORD_OFFSET,
+					XLLDMA_USERIP_APPWORD_INITVALUE);
+		}
+
+		/* Flush the current BD so DMA core could see the updates */
+		XLLDMA_CACHE_FLUSH(CurBdPtr);
+
+		CurBdPtr = XLlDma_mBdRingNext(RingPtr, CurBdPtr);
+		BdStsCr =
+			XLlDma_mBdRead(CurBdPtr, XLLDMA_BD_STSCTRL_USR0_OFFSET);
+	}
+
+	/* The last BD should have end-of-packet bit set */
+	if (!(BdStsCr & XLLDMA_BD_STSCTRL_EOP_MASK)) {
+		return (XST_FAILURE);
+	}
+
+	/* Make sure the length value in the last BD is non-zero. */
+	if (XLlDma_mBdGetLength(CurBdPtr) == 0) {
+		return (XST_FAILURE);
+	}
+
+	/* The last BD should also have the completed and stop-on-end bits
+	 * cleared
+	 */
+	BdStsCr &=
+		~(XLLDMA_BD_STSCTRL_COMPLETED_MASK |
+		  XLLDMA_BD_STSCTRL_SOE_MASK);
+	XLlDma_mBdWrite(CurBdPtr, XLLDMA_BD_STSCTRL_USR0_OFFSET, BdStsCr);
+
+	/* In RX channel case, the last BD should have the
+	 * XLLDMA_USERIP_APPWORD_OFFSET initialized to
+	 * XLLDMA_USERIP_APPWORD_INITVALUE
+	 */
+	if (RingPtr->IsRxChannel) {
+		XLlDma_mBdWrite(CurBdPtr, XLLDMA_USERIP_APPWORD_OFFSET,
+				XLLDMA_USERIP_APPWORD_INITVALUE);
+	}
+
+	/* Flush the last BD so DMA core could see the updates */
+	XLLDMA_CACHE_FLUSH(CurBdPtr);
+
+	/* This set has completed pre-processing, adjust ring pointers and
+	 * counters
+	 */
+	XLLDMA_RING_SEEKAHEAD(RingPtr, RingPtr->PreHead, NumBd);
+	RingPtr->PreCnt -= NumBd;
+	RingPtr->HwTail = CurBdPtr;
+	RingPtr->HwCnt += NumBd;
+
+	/* If it was enabled, tell the engine to begin processing */
+	if (RingPtr->RunState == XST_DMA_SG_IS_STARTED) {
+		XLlDma_mWriteReg(RingPtr->ChanBase, XLLDMA_TDESC_OFFSET,
+				 XLLDMA_VIRT_TO_PHYS(RingPtr->HwTail));
+	}
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Returns a set of BD(s) that have been processed by hardware. The returned
+ * BDs may be examined by the application to determine the outcome of the DMA
+ * transactions). Once the BDs have been examined, the application must call
+ * XLlDma_BdRingFree() in the same order which they were retrieved here.
+ *
+ * Example:
+ *
+ * <pre>
+ *        NumBd = XLlDma_BdRingFromHw(MyRingPtr, XLLDMA_ALL_BDS, &MyBdSet);
+ *
+ *        if (NumBd == 0)
+ *        {
+ *           // hardware has nothing ready for us yet
+ *        }
+ *
+ *        CurBd = MyBdSet;
+ *        for (i=0; i<NumBd; i++)
+ *        {
+ *           // Examine CurBd for post processing.....
+ *
+ *           // Onto next BD
+ *           CurBd = XLlDma_mBdRingNext(MyRingPtr, CurBd);
+ *        }
+ *
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return the list
+ * </pre>
+ *
+ * A more advanced use of this function may allocate multiple sets of BDs.
+ * They must be retrieved from hardware and freed in the correct sequence:
+ * <pre>
+ *        // Legal
+ *        XLlDma_BdRingFromHw(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd1, MySet1);
+ *
+ *        // Legal
+ *        XLlDma_BdRingFromHw(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingFromHw(MyRingPtr, NumBd2, &MySet2);
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd1, MySet1);
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd2, MySet2);
+ *
+ *        // Not legal
+ *        XLlDma_BdRingFromHw(MyRingPtr, NumBd1, &MySet1);
+ *        XLlDma_BdRingFromHw(MyRingPtr, NumBd2, &MySet2);
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd2, MySet2);
+ *        XLlDma_BdRingFree(MyRingPtr, NumBd1, MySet1);
+ * </pre>
+ *
+ * If hardware has partially completed a packet spanning multiple BDs, then
+ * none of the BDs for that packet will be included in the results.
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param BdLimit is the maximum number of BDs to return in the set. Use
+ *        XLLDMA_ALL_BDS to return all BDs that have been processed.
+ * @param BdSetPtr is an output parameter, it points to the first BD available
+ *        for examination.
+ *
+ * @return
+ *   The number of BDs processed by hardware. A value of 0 indicates that no
+ *   data is available. No more than BdLimit BDs will be returned.
+ *
+ * @note Treat BDs returned by this function as read-only.
+ *
+ * @note This function should not be preempted by another XLlDma ring function
+ *       call that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ *****************************************************************************/
+unsigned XLlDma_BdRingFromHw(XLlDma_BdRing * RingPtr, unsigned BdLimit,
+			     XLlDma_Bd ** BdSetPtr)
+{
+	XLlDma_Bd *CurBdPtr;
+	unsigned BdCount;
+	unsigned BdPartialCount;
+	u32 BdStsCr;
+	u32 UserIpAppWord;
+
+	CurBdPtr = RingPtr->HwHead;
+	BdCount = 0;
+	BdPartialCount = 0;
+
+	/* If no BDs in work group, then there's nothing to search */
+	if (RingPtr->HwCnt == 0) {
+		*BdSetPtr = NULL;
+		return (0);
+	}
+
+	/* Starting at HwHead, keep moving forward in the list until:
+	 *  - A BD is encountered with its completed bit clear in the status
+	 *    word which means hardware has not completed processing of that
+	 *    BD.
+	 *  - A BD is encountered with its XLLDMA_USERIP_APPWORD_OFFSET field
+	 *    with value XLLDMA_USERIP_APPWORD_INITVALUE which means hardware
+	 *    has not completed updating the BD structure.
+	 *  - RingPtr->HwTail is reached
+	 *  - The number of requested BDs has been processed
+	 */
+	while (BdCount < BdLimit) {
+		/* Read the status */
+		XLLDMA_CACHE_INVALIDATE(CurBdPtr);
+		BdStsCr = XLlDma_mBdRead(CurBdPtr,
+					 XLLDMA_BD_STSCTRL_USR0_OFFSET);
+
+		/* If the hardware still hasn't processed this BD then we are
+		 * done
+		 */
+		if (!(BdStsCr & XLLDMA_BD_STSCTRL_COMPLETED_MASK)) {
+			break;
+		}
+
+		/* In RX channel case, check if XLLDMA_USERIP_APPWORD_OFFSET
+		 * field of the BD has been updated. If not, RX channel has
+		 * not completed updating the BD structure and we delay
+		 * the processing of this BD to next time
+		 */
+		if (RingPtr->IsRxChannel) {
+			UserIpAppWord = XLlDma_mBdRead(CurBdPtr,
+						       XLLDMA_USERIP_APPWORD_OFFSET);
+			if (UserIpAppWord == XLLDMA_USERIP_APPWORD_INITVALUE) {
+				break;
+			}
+		}
+
+
+		BdCount++;
+
+		/* Hardware has processed this BD so check the "last" bit. If
+		 * it is clear, then there are more BDs for the current packet.
+		 * Keep a count of these partial packet BDs.
+		 */
+		if (BdStsCr & XLLDMA_BD_STSCTRL_EOP_MASK) {
+			BdPartialCount = 0;
+		}
+		else {
+			BdPartialCount++;
+		}
+
+		/* Reached the end of the work group */
+		if (CurBdPtr == RingPtr->HwTail) {
+			break;
+		}
+
+		/* Move on to next BD in work group */
+		CurBdPtr = XLlDma_mBdRingNext(RingPtr, CurBdPtr);
+	}
+
+	/* Subtract off any partial packet BDs found */
+	BdCount -= BdPartialCount;
+
+	/* If BdCount is non-zero then BDs were found to return. Set return
+	 * parameters, update pointers and counters, return success
+	 */
+	if (BdCount) {
+		*BdSetPtr = RingPtr->HwHead;
+		RingPtr->HwCnt -= BdCount;
+		RingPtr->PostCnt += BdCount;
+		XLLDMA_RING_SEEKAHEAD(RingPtr, RingPtr->HwHead, BdCount);
+		return (BdCount);
+	}
+	else {
+		*BdSetPtr = NULL;
+		return (0);
+	}
+}
+
+
+/*****************************************************************************/
+/**
+ * Frees a set of BDs that had been previously retrieved with
+ * XLlDma_BdRingFromHw().
+ *
+ * @param RingPtr is a pointer to the descriptor ring instance to be worked on.
+ * @param NumBd is the number of BDs to free.
+ * @param BdSetPtr is the head of a list of BDs returned by
+ *        XLlDma_BdRingFromHw().
+ *
+ * @return
+ *   - XST_SUCCESS if the set of BDs was freed.
+ *   - XST_DMA_SG_LIST_ERROR if this function was called out of sequence with
+ *     XLlDma_BdRingFromHw().
+ *
+ * @note This function should not be preempted by another XLlDma function call
+ *       that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ * @internal
+ *          This Interrupt handler provided by application MUST clear pending
+ *          interrupts before handling them by calling the call back. Otherwise
+ *          the following corner case could raise some issue:
+ *
+ *           - A packet was transmitted and asserted an TX interrupt, and if
+ *             this interrupt handler calls the call back before clears the
+ *             interrupt, another packet could get transmitted (and assert the
+ *             interrupt) between when the call back function returned and when
+ *             the interrupt clearing operation begins, and the interrupt
+ *             clearing operation will clear the interrupt raised by the second
+ *             packet and won't never process its according buffer descriptors
+ *             until a new interrupt occurs.
+ *
+ *           Changing the sequence to "Clear interrupts, then handle" solve this
+ *           issue. If the interrupt raised by the second packet is before the
+ *           the interrupt clearing operation, the descriptors associated with
+ *           the second packet must have been finished by hardware and ready for
+ *           the handling by the call back; otherwise, the interrupt raised by
+ *           the second packet is after the interrupt clearing operation,
+ *           the packet's buffer descriptors will be handled by the call back in
+ *           current pass, if the descriptors are finished before the call back
+ *           is invoked, or next pass otherwise.
+ *
+ *           Please note that if the second packet is handled by the call back
+ *           in current pass, the next pass could find no buffer descriptor
+ *           finished by the hardware. (i.e., XLlDma_BdRingFromHw() returns 0).
+ *           As XLlDma_BdRingFromHw() and XLlDma_BdRingFree() are used in pair,
+ *           XLlDma_BdRingFree() covers this situation by checking if the BD
+ *           list to free is empty
+ *****************************************************************************/
+int XLlDma_BdRingFree(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		      XLlDma_Bd * BdSetPtr)
+{
+	/* If the BD Set to free is empty, return immediately with value
+	 * XST_SUCCESS. See the @internal comment block above for detailed
+	 * information
+	 */
+	if (NumBd == 0) {
+		return XST_SUCCESS;
+	}
+
+	/* Make sure we are in sync with XLlDma_BdRingFromHw() */
+	if ((RingPtr->PostCnt < NumBd) || (RingPtr->PostHead != BdSetPtr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Update pointers and counters */
+	RingPtr->FreeCnt += NumBd;
+	RingPtr->PostCnt -= NumBd;
+	XLLDMA_RING_SEEKAHEAD(RingPtr, RingPtr->PostHead, NumBd);
+
+	return (XST_SUCCESS);
+}
+
+
+/*****************************************************************************/
+/**
+ * Check the internal data structures of the BD ring for the provided channel.
+ * The following checks are made:
+ *
+ *   - Is the BD ring linked correctly in physical address space.
+ *   - Do the internal pointers point to BDs in the ring.
+ *   - Do the internal counters add up.
+ *
+ * The channel should be stopped prior to calling this function.
+ *
+ * @param RingPtr is a pointer to the descriptor ring to be worked on.
+ *
+ * @return
+ *   - XST_SUCCESS if no errors were found.
+ *   - XST_DMA_SG_NO_LIST if the ring has not been created.
+ *   - XST_IS_STARTED if the channel is not stopped.
+ *   - XST_DMA_SG_LIST_ERROR if a problem is found with the internal data
+ *     structures. If this value is returned, the channel should be reset to
+ *     avoid data corruption or system instability.
+ *
+ * @note This function should not be preempted by another XLlDma ring function
+ *       call that modifies the BD space. It is the caller's responsibility to
+ *       provide a mutual exclusion mechanism.
+ *
+ *****************************************************************************/
+int XLlDma_BdRingCheck(XLlDma_BdRing * RingPtr)
+{
+	u32 AddrV, AddrP;
+	unsigned i;
+
+	/* Is the list created */
+	if (RingPtr->AllCnt == 0) {
+		return (XST_DMA_SG_NO_LIST);
+	}
+
+	/* Can't check if channel is running */
+	if (RingPtr->RunState == XST_DMA_SG_IS_STARTED) {
+		return (XST_IS_STARTED);
+	}
+
+	/* RunState doesn't make sense */
+	else if (RingPtr->RunState != XST_DMA_SG_IS_STOPPED) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify internal pointers point to correct memory space */
+	AddrV = (u32) RingPtr->FreeHead;
+	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->PreHead;
+	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->HwHead;
+	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->HwTail;
+	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	AddrV = (u32) RingPtr->PostHead;
+	if ((AddrV < RingPtr->FirstBdAddr) || (AddrV > RingPtr->LastBdAddr)) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify internal counters add up */
+	if ((RingPtr->HwCnt + RingPtr->PreCnt + RingPtr->FreeCnt +
+	     RingPtr->PostCnt) != RingPtr->AllCnt) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* Verify BDs are linked correctly */
+	AddrV = RingPtr->FirstBdAddr;
+	AddrP = RingPtr->FirstBdPhysAddr + RingPtr->Separation;
+	for (i = 1; i < RingPtr->AllCnt; i++) {
+		XLLDMA_CACHE_INVALIDATE(AddrV);
+		/* Check next pointer for this BD. It should equal to the
+		 * physical address of next BD
+		 */
+		if (XLlDma_mBdRead(AddrV, XLLDMA_BD_NDESC_OFFSET) != AddrP) {
+			return (XST_DMA_SG_LIST_ERROR);
+		}
+
+		/* Move on to next BD */
+		AddrV += RingPtr->Separation;
+		AddrP += RingPtr->Separation;
+	}
+
+	XLLDMA_CACHE_INVALIDATE(AddrV);
+	/* Last BD should point back to the beginning of ring */
+	if (XLlDma_mBdRead(AddrV, XLLDMA_BD_NDESC_OFFSET) !=
+	    RingPtr->FirstBdPhysAddr) {
+		return (XST_DMA_SG_LIST_ERROR);
+	}
+
+	/* No problems found */
+	return (XST_SUCCESS);
+}
diff --git a/drivers/xilinx_common/xlldma_bdring.h b/drivers/xilinx_common/xlldma_bdring.h
new file mode 100644
index 0000000..91cef66
--- /dev/null
+++ b/drivers/xilinx_common/xlldma_bdring.h
@@ -0,0 +1,434 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xlldma_bdring.h
+*
+* This file contains DMA channel related structure and constant definition
+* as well as function prototypes. Each DMA channel is managed by a Buffer
+* Descriptor ring, and so XLlDma_BdRing is chosen as the symbol prefix used in
+* this file. See xlldma.h for more information.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   12/21/06 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XLLDMA_BDRING_H		/* prevent circular inclusions */
+#define XLLDMA_BDRING_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xlldma_hw.h"
+#include "xlldma_bd.h"
+
+/** Container structure for descriptor storage control. If address translation
+ * is enabled, then all addresses and pointers excluding FirstBdPhysAddr are
+ * expressed in terms of the virtual address.
+ */
+typedef struct {
+	u32 ChanBase;	       /**< Virtual base address of channel registers
+                                       */
+	u32 IsRxChannel;       /**< Is this a receive channel ? */
+	u32 FirstBdPhysAddr;   /**< Physical address of 1st BD in list */
+	u32 FirstBdAddr;       /**< Virtual address of 1st BD in list */
+	u32 LastBdAddr;	       /**< Virtual address of last BD in the list */
+	u32 Length;	       /**< Total size of ring in bytes */
+	u32 RunState;	       /**< Flag to indicate channel is started */
+	u32 Separation;	       /**< Number of bytes between the starting
+	                            address of adjacent BDs */
+	XLlDma_Bd *FreeHead;   /**< First BD in the free group */
+	XLlDma_Bd *PreHead;    /**< First BD in the pre-work group */
+	XLlDma_Bd *HwHead;     /**< First BD in the work group */
+	XLlDma_Bd *HwTail;     /**< Last BD in the work group */
+	XLlDma_Bd *PostHead;   /**< First BD in the post-work group */
+	XLlDma_Bd *BdaRestart; /**< BD to load when channel is started */
+	u32 FreeCnt;	       /**< Number of allocatable BDs in free group */
+	u32 PreCnt;	       /**< Number of BDs in pre-work group */
+	u32 HwCnt;	       /**< Number of BDs in work group */
+	u32 PostCnt;	       /**< Number of BDs in post-work group */
+	u32 AllCnt;	       /**< Total Number of BDs for channel */
+} XLlDma_BdRing;
+
+/*****************************************************************************/
+/**
+* Use this macro at initialization time to determine how many BDs will fit
+* within the given memory constraints.
+*
+* The results of this macro can be provided to XLlDma_BdRingCreate().
+*
+* @param Alignment specifies what byte alignment the BDs must fall on and
+*        must be a power of 2 to get an accurate calculation (32, 64, 126,...)
+* @param Bytes is the number of bytes to be used to store BDs.
+*
+* @return Number of BDs that can fit in the given memory area
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingCntCalc(u32 Alignment, u32 Bytes)
+*
+******************************************************************************/
+#define XLlDma_mBdRingCntCalc(Alignment, Bytes)                           \
+	(u32)((Bytes)/((sizeof(XLlDma_Bd)+((Alignment)-1))&~((Alignment)-1)))
+
+
+/*****************************************************************************/
+/**
+* Use this macro at initialization time to determine how many bytes of memory
+* are required to contain a given number of BDs at a given alignment.
+*
+* @param Alignment specifies what byte alignment the BDs must fall on. This
+*        parameter must be a power of 2 to get an accurate calculation (32, 64,
+*        128,...)
+* @param NumBd is the number of BDs to calculate memory size requirements for
+*
+* @return The number of bytes of memory required to create a BD list with the
+*         given memory constraints.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingMemCalc(u32 Alignment, u32 NumBd)
+*
+******************************************************************************/
+#define XLlDma_mBdRingMemCalc(Alignment, NumBd)			\
+	(u32)((sizeof(XLlDma_Bd)+((Alignment)-1))&~((Alignment)-1))*(NumBd)
+
+
+/****************************************************************************/
+/**
+* Return the total number of BDs allocated by this channel with
+* XLlDma_BdRingCreate().
+*
+* @param  RingPtr is the BD ring to operate on.
+*
+* @return The total number of BDs allocated for this channel.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingGetCnt(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingGetCnt(RingPtr) ((RingPtr)->AllCnt)
+
+
+/****************************************************************************/
+/**
+* Return the number of BDs allocatable with XLlDma_BdRingAlloc() for pre-
+* processing.
+*
+* @param  RingPtr is the BD ring to operate on.
+*
+* @return The number of BDs currently allocatable.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingGetFreeCnt(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingGetFreeCnt(RingPtr)  ((RingPtr)->FreeCnt)
+
+
+/****************************************************************************/
+/**
+* Snap shot the latest BD a BD ring is processing.
+*
+* @param  RingPtr is the BD ring to operate on.
+*
+* @return None
+*
+* @note
+* C-style signature:
+*    void XLlDma_mBdRingSnapShotCurrBd(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingSnapShotCurrBd(RingPtr)				  \
+	{								  \
+		(RingPtr)->BdaRestart = 				  \
+			(XLlDma_Bd *)XLlDma_mReadReg((RingPtr)->ChanBase, \
+					XLLDMA_CDESC_OFFSET);		  \
+	}
+
+
+/****************************************************************************/
+/**
+* Return the next BD in the ring.
+*
+* @param  RingPtr is the BD ring to operate on.
+* @param  BdPtr is the current BD.
+*
+* @return The next BD in the ring relative to the BdPtr parameter.
+*
+* @note
+* C-style signature:
+*    XLlDma_Bd *XLlDma_mBdRingNext(XLlDma_BdRing* RingPtr, XLlDma_Bd *BdPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingNext(RingPtr, BdPtr)			\
+		(((u32)(BdPtr) >= (RingPtr)->LastBdAddr) ?	\
+			(XLlDma_Bd*)(RingPtr)->FirstBdAddr :	\
+			(XLlDma_Bd*)((u32)(BdPtr) + (RingPtr)->Separation))
+
+
+/****************************************************************************/
+/**
+* Return the previous BD in the ring.
+*
+* @param  InstancePtr is the DMA channel to operate on.
+* @param  BdPtr is the current BD.
+*
+* @return The previous BD in the ring relative to the BdPtr parameter.
+*
+* @note
+* C-style signature:
+*    XLlDma_Bd *XLlDma_mBdRingPrev(XLlDma_BdRing* RingPtr, XLlDma_Bd *BdPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingPrev(RingPtr, BdPtr)				\
+		(((u32)(BdPtr) <= (RingPtr)->FirstBdAddr) ?		\
+			(XLlDma_Bd*)(RingPtr)->LastBdAddr :		\
+			(XLlDma_Bd*)((u32)(BdPtr) - (RingPtr)->Separation))
+
+/****************************************************************************/
+/**
+* Retrieve the contents of the channel status register XLLDMA_SR_OFFSET
+*
+* @param  RingPtr is the channel instance to operate on.
+*
+* @return Current contents of SR_OFFSET
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingGetSr(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingGetSr(RingPtr)				\
+		XLlDma_mReadReg((RingPtr)->ChanBase, XLLDMA_SR_OFFSET)
+
+
+/****************************************************************************/
+/**
+* Retrieve the contents of the channel control register XLLDMA_CR_OFFSET
+*
+* @param  RingPtr is the channel instance to operate on.
+*
+* @return Current contents of CR_OFFSET
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingGetCr(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingGetCr(RingPtr)				\
+		XLlDma_mReadReg((RingPtr)->ChanBase, XLLDMA_CR_OFFSET)
+
+
+/****************************************************************************/
+/**
+* Set the contents of the channel control register XLLDMA_CR_OFFSET. This
+* register does not affect the other DMA channel.
+*
+* @param  RingPtr is the channel instance to operate on.
+* @param  Data is the data to write to CR_OFFSET
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingSetCr(XLlDma_BdRing* RingPtr, u32 Data)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingSetCr(RingPtr, Data)				\
+		XLlDma_mWriteReg((RingPtr)->ChanBase, XLLDMA_CR_OFFSET, (Data))
+
+
+/****************************************************************************/
+/**
+* Check if the current DMA channel is busy with a DMA operation.
+*
+* @param  RingPtr is the channel instance to operate on.
+*
+* @return TRUE if the DMA is busy. FALSE otherwise
+*
+* @note
+* C-style signature:
+*    XBoolean XLlDma_mBdRingBusy(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingBusy(RingPtr)					 \
+		((XLlDma_mReadReg((RingPtr)->ChanBase, XLLDMA_SR_OFFSET) \
+			& XLLDMA_SR_ENGINE_BUSY_MASK) ? TRUE : FALSE)
+
+
+/****************************************************************************/
+/**
+* Set interrupt enable bits for a channel. This operation will modify the
+* XLLDMA_CR_OFFSET register.
+*
+* @param  RingPtr is the channel instance to operate on.
+* @param  Mask consists of the interrupt signals to enable. They are formed by
+*         OR'ing one or more of the following bitmasks together:
+*         XLLDMA_CR_IRQ_EN_MASK, XLLDMA_CR_IRQ_ERROR_EN_MASK,
+*         XLLDMA_CR_IRQ_DELAY_EN_MASK, XLLDMA_CR_IRQ_COALESCE_EN_MASK and
+*         XLLDMA_CR_IRQ_ALL_EN_MASK. Bits not specified in the mask are not
+*         affected.
+*
+* @note
+* C-style signature:
+*    void XLlDma_mBdRingIntEnable(XLlDma_BdRing* RingPtr, u32 Mask)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingIntEnable(RingPtr, Mask)			\
+	{							\
+		u32 Reg = XLlDma_mReadReg((RingPtr)->ChanBase,	\
+				XLLDMA_CR_OFFSET);		\
+		Reg |= ((Mask) & XLLDMA_CR_IRQ_ALL_EN_MASK);	\
+		XLlDma_mWriteReg((RingPtr)->ChanBase, XLLDMA_CR_OFFSET, Reg);\
+	}
+
+
+/****************************************************************************/
+/**
+* Clear interrupt enable bits for a channel. This operation will modify the
+* XLLDMA_CR_OFFSET register.
+*
+* @param  RingPtr is the channel instance to operate on.
+* @param  Mask consists of the interrupt signals to disable. They are formed
+*         by OR'ing one or more of the following bitmasks together:
+*         XLLDMA_CR_IRQ_EN_MASK, XLLDMA_CR_IRQ_ERROR_EN_MASK,
+*         XLLDMA_CR_IRQ_DELAY_EN_MASK, XLLDMA_CR_IRQ_COALESCE_EN_MASK and
+*         XLLDMA_CR_IRQ_ALL_EN_MASK. Bits not specified in the mask are not
+*         affected.
+*
+* @note
+* C-style signature:
+*    void XLlDma_mBdRingIntDisable(XLlDma_BdRing* RingPtr, u32 Mask)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingIntDisable(RingPtr, Mask)				\
+	{								\
+		u32 Reg = XLlDma_mReadReg((RingPtr)->ChanBase,		\
+				XLLDMA_CR_OFFSET);			\
+		Reg &= ~((Mask) & XLLDMA_CR_IRQ_ALL_EN_MASK);		\
+		XLlDma_mWriteReg((RingPtr)->ChanBase, XLLDMA_CR_OFFSET, Reg);\
+	}
+
+
+/****************************************************************************/
+/**
+* Get enabled interrupts of a channel.
+*
+* @param  RingPtr is the channel instance to operate on.
+* @return Enabled interrupts of a channel. Use XLLDMA_CR_IRQ_* defined in
+*         xlldma_hw.h to interpret this returned value.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingIntGetEnabled(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingIntGetEnabled(RingPtr)				\
+		(XLlDma_mReadReg((RingPtr)->ChanBase, XLLDMA_CR_OFFSET) \
+			& XLLDMA_CR_IRQ_ALL_EN_MASK)
+
+
+/****************************************************************************/
+/**
+* Retrieve the contents of the channel's IRQ register XDMACR_IRQ_OFFSET. This
+* operation can be used to see which interrupts are pending.
+*
+* @param  RingPtr is the channel instance to operate on.
+*
+* @return Current contents of the IRQ_OFFSET register. Use XLLDMA_IRQ_***
+*         values defined in xlldma_hw.h to interpret the returned value.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingGetIrq(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingGetIrq(RingPtr)				\
+		XLlDma_mReadReg((RingPtr)->ChanBase, XLLDMA_IRQ_OFFSET)
+
+
+/****************************************************************************/
+/**
+* Acknowledge asserted interrupts.
+*
+* @param  RingPtr is the channel instance to operate on.
+* @param  Mask are the interrupt signals to acknowledge and are made by Or'ing
+*         one or more of the following bits: XLLDMA_IRQ_ERROR_MASK,
+*         XLLDMA_IRQ_DELAY_MASK, XLLDMA_IRQ_COALESCE_MASK, XLLDMA_IRQ_ALL_MASK.
+*         Any mask bit set for an unasserted interrupt has no effect.
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mBdRingAckIrq(XLlDma_BdRing* RingPtr)
+*
+*****************************************************************************/
+#define XLlDma_mBdRingAckIrq(RingPtr, Mask)				\
+		XLlDma_mWriteReg((RingPtr)->ChanBase, XLLDMA_IRQ_OFFSET,\
+			(Mask) & XLLDMA_IRQ_ALL_MASK)
+
+/************************* Function Prototypes ******************************/
+
+/*
+ * Descriptor ring functions xlldma_bdring.c
+ */
+int XLlDma_BdRingCreate(XLlDma_BdRing * RingPtr, u32 PhysAddr,
+			u32 VirtAddr, u32 Alignment, unsigned BdCount);
+int XLlDma_BdRingCheck(XLlDma_BdRing * RingPtr);
+int XLlDma_BdRingClone(XLlDma_BdRing * RingPtr, XLlDma_Bd * SrcBdPtr);
+int XLlDma_BdRingAlloc(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		       XLlDma_Bd ** BdSetPtr);
+int XLlDma_BdRingUnAlloc(XLlDma_BdRing * RingPtr, unsigned NumBd,
+			 XLlDma_Bd * BdSetPtr);
+int XLlDma_BdRingToHw(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		      XLlDma_Bd * BdSetPtr);
+unsigned XLlDma_BdRingFromHw(XLlDma_BdRing * RingPtr, unsigned BdLimit,
+			     XLlDma_Bd ** BdSetPtr);
+int XLlDma_BdRingFree(XLlDma_BdRing * RingPtr, unsigned NumBd,
+		      XLlDma_Bd * BdSetPtr);
+int XLlDma_BdRingStart(XLlDma_BdRing * RingPtr);
+int XLlDma_BdRingSetCoalesce(XLlDma_BdRing * RingPtr, u32 Counter, u32 Timer);
+void XLlDma_BdRingGetCoalesce(XLlDma_BdRing * RingPtr,
+			      u32 *CounterPtr, u32 *TimerPtr);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xlldma_hw.h b/drivers/xilinx_common/xlldma_hw.h
new file mode 100644
index 0000000..0481e72
--- /dev/null
+++ b/drivers/xilinx_common/xlldma_hw.h
@@ -0,0 +1,373 @@
+/* $Id: */
+
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file xlldma_hw.h
+*
+* This header file contains identifiers and register-level driver functions (or
+* macros) that can be used to access the Local-Link Scatter-gather Direct
+* Memory Access Gather (LLDMA) device.
+*
+* For more information about the operation of this device, see the hardware
+* specification and documentation in the higher level driver xlldma.h source
+* code file.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   12/21/06 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XLLDMA_HW_H		/* prevent circular inclusions */
+#define XLLDMA_HW_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+
+/** @name Device Bus Type definition The constant
+ * CONFIG_XILINX_LLDMA_USE_DCR is used to inform this driver the type
+ * of the BUS the DMA device is on. If the DMA core is on DCR BUS
+ * using indirect addressing, which currently only happens on V5FX,
+ * then this option must be set.  On other architectures where dma
+ * ports are accessed through memory mapped io, this must not be set.
+ *@{
+ */
+#ifdef CONFIG_XILINX_LLDMA_USE_DCR
+#include "xio_dcr.h"
+#else
+#include "xio.h"
+#endif
+/*@}*/
+
+/************************** Constant Definitions *****************************/
+
+/** @name Buffer Descriptor Alignment
+ *  @{
+ */
+#define XLLDMA_BD_MINIMUM_ALIGNMENT 0x40  /**< Minimum byte alignment
+                                               requirement for descriptors to
+                                               satisfy both hardware/software
+                                               needs */
+/*@}*/
+
+
+/* Register offset definitions. Unless otherwise noted, register access is
+ * 32 bit.
+ */
+
+#ifdef CONFIG_XILINX_LLDMA_USE_DCR
+
+/* DMA core is on DCR BUS */
+
+/** @name Device registers for DCR based systems.
+ *  Offsets defined in DCR address space. TX and RX channels consist of
+ *  identical registers
+ *  @{
+ */
+#define XLLDMA_TX_OFFSET    0x00000000	/**< TX channel registers base
+                                             offset [0..7] */
+#define XLLDMA_RX_OFFSET    0x00000008	/**< RX channel registers base
+                                             offset [8..F] */
+#define XLLDMA_DMACR_OFFSET 0x00000010	/**< DMA control register */
+
+/* This set of registers are applicable for both channels. Add
+ * XLLDMA_TX_OFFSET to get to TX channel, and XLLDMA_RX_OFFSET to get to RX
+ * channel
+ */
+#define XLLDMA_NDESC_OFFSET 0x00000000	/**< Next descriptor pointer */
+#define XLLDMA_BUFA_OFFSET  0x00000001	/**< Current buffer address */
+#define XLLDMA_BUFL_OFFSET  0x00000002	/**< Current buffer length */
+#define XLLDMA_CDESC_OFFSET 0x00000003	/**< Current descriptor pointer */
+#define XLLDMA_TDESC_OFFSET 0x00000004	/**< Tail descriptor pointer */
+#define XLLDMA_CR_OFFSET    0x00000005	/**< Channel control */
+#define XLLDMA_IRQ_OFFSET   0x00000006	/**< Interrupt register */
+#define XLLDMA_SR_OFFSET    0x00000007	/**< Status */
+/*@}*/
+
+#else /* Non-DCR interface is used */
+
+/** @name Device registers for Non-DCR based systems.
+ *  Offsets defined in Non-DCR address space. TX and RX channels consist of
+ *  identical registers
+ *  @{
+ */
+#define XLLDMA_TX_OFFSET    0x00000000	/**< TX channel registers base
+                                             offset */
+#define XLLDMA_RX_OFFSET    0x00000020	/**< RX channel registers base
+                                             offset */
+#define XLLDMA_DMACR_OFFSET 0x00000040	/**< DMA control register */
+
+/* This set of registers are applicable for both channels. Add
+ * XLLDMA_TX_OFFSET to get to TX channel, and XLLDMA_RX_OFFSET to get to RX
+ * channel
+ */
+#define XLLDMA_NDESC_OFFSET 0x00000000	/**< Next descriptor pointer */
+#define XLLDMA_BUFA_OFFSET  0x00000004	/**< Current buffer address */
+#define XLLDMA_BUFL_OFFSET  0x00000008	/**< Current buffer length */
+#define XLLDMA_CDESC_OFFSET 0x0000000C	/**< Current descriptor pointer */
+#define XLLDMA_TDESC_OFFSET 0x00000010	/**< Tail descriptor pointer */
+#define XLLDMA_CR_OFFSET    0x00000014	/**< Channel control */
+#define XLLDMA_IRQ_OFFSET   0x00000018	/**< Interrupt register */
+#define XLLDMA_SR_OFFSET    0x0000001C	/**< Status */
+
+/*@}*/
+
+#endif /* #ifdef CONFIG_XILINX_LLDMA_USE_DCR */
+
+/** @name Buffer Descriptor register offsets
+ *  USR fields are defined by higher level IP. For example, checksum offload
+ *  setup for EMAC type devices. The 1st 8 words are utilized by hardware. Any
+ *  words after the 8th are for software use only.
+ *  @{
+ */
+#define XLLDMA_BD_NDESC_OFFSET        0x00  /**< Next descriptor pointer */
+#define XLLDMA_BD_BUFA_OFFSET         0x04  /**< Buffer address */
+#define XLLDMA_BD_BUFL_OFFSET         0x08  /**< Buffer length */
+#define XLLDMA_BD_STSCTRL_USR0_OFFSET 0x0C  /**< Status and Control and
+                                                 hardware implementation
+                                                 specific */
+#define XLLDMA_BD_USR1_OFFSET         0x10  /**< Hardware implementation
+                                                 specific */
+#define XLLDMA_BD_USR2_OFFSET         0x14  /**< Hardware implementation
+                                                 specific */
+#define XLLDMA_BD_USR3_OFFSET         0x18  /**< Hardware implementation
+                                                 specific */
+#define XLLDMA_BD_USR4_OFFSET         0x1C  /**< Hardware implementation
+                                                 specific */
+#define XLLDMA_BD_ID_OFFSET           0x20  /**< Software application use */
+
+#define XLLDMA_BD_NUM_WORDS              9  /**< Number of 32-bit words that
+                                                 make up a full BD */
+#define XLLDMA_BD_HW_NUM_WORDS           8  /**< Number of 32-bit words that
+                                                 make up the hardware
+                                                 accessible portion of a BD */
+#define XLLDMA_BD_HW_NUM_BYTES          32  /**< Number of bytes that make up
+                                                 the hardware accessible
+                                                 portion of a BD */
+/*@}*/
+
+
+/* Register masks. The following constants define bit locations of various
+ * control bits in the registers. Constants are not defined for those registers
+ * that have a single bit field representing all 32 bits. For further
+ * information on the meaning of the various bit masks, refer to the hardware
+ * spec.
+ */
+
+
+/** @name Bitmasks of XLLDMA_TX_CR_OFFSET and XLLDMA_RX_CR_OFFSET registers
+ * @{
+ */
+#define XLLDMA_CR_IRQ_TIMEOUT_MASK      0xFF000000 /**< Interrupt coalesce
+                                                        waitbound timeout */
+#define XLLDMA_CR_IRQ_COUNT_MASK        0x00FF0000 /**< Interrupt coalesce
+                                                        count threshold */
+#define XLLDMA_CR_MSB_ADDR_MASK         0x0000F000 /**< MSB address of DMA
+                                                        buffers and descriptors
+                                                        for 36 bit
+                                                        addressing */
+#define XLLDMA_CR_APP_EN_MASK           0x00000800 /**< Application data mask
+                                                        enable */
+#define XLLDMA_CR_USE_1_BIT_CNT_MASK    0x00000400 /**< Turn 4 and 2 bit
+                                                        interrupt counters into
+                                                        1 bit counters */
+#define XLLDMA_CR_USE_INT_ON_END_MASK   0x00000200 /**< Use interrupt-on-end */
+#define XLLDMA_CR_LD_IRQ_CNT_MASK       0x00000100 /**< Load IRQ_COUNT */
+#define XLLDMA_CR_IRQ_EN_MASK           0x00000080 /**< Master interrupt
+                                                        enable */
+#define XLLDMA_CR_IRQ_ERROR_EN_MASK     0x00000004 /**< Enable error
+                                                        interrupt */
+#define XLLDMA_CR_IRQ_DELAY_EN_MASK     0x00000002 /**< Enable coalesce delay
+                                                        interrupt */
+#define XLLDMA_CR_IRQ_COALESCE_EN_MASK  0x00000001 /**< Enable coalesce count
+                                                        interrupt */
+#define XLLDMA_CR_IRQ_ALL_EN_MASK       0x00000087 /**< All interrupt enable
+                                                        bits */
+
+/* Shift constants for selected masks */
+#define XLLDMA_CR_IRQ_TIMEOUT_SHIFT     24
+#define XLLDMA_CR_IRQ_COUNT_SHIFT       16
+#define XLLDMA_CR_MSB_ADDR_SHIFT        12
+
+/*@}*/
+
+
+/** @name Bitmasks of XLLDMA_TX_IRQ_OFFSET & XLLDMA_RX_IRQ_OFFSET registers
+ * @{
+ */
+#define XLLDMA_IRQ_WRQ_EMPTY_MASK        0x00004000 /**< Write Command Queue
+                                                         Empty -- RX channel
+                                                         Only */
+#define XLLDMA_IRQ_COALESCE_COUNTER_MASK 0x00003C00 /**< Coalesce IRQ 4 bit
+                                                         counter */
+#define XLLDMA_IRQ_DELAY_COUNTER_MASK    0x00000300 /**< Coalesce delay IRQ 2
+                                                         bit counter */
+#define XLLDMA_IRQ_PLB_RD_ERROR_MASK     0x00000010 /**< PLB Read Error IRQ */
+#define XLLDMA_IRQ_PLB_WR_ERROR_MASK     0x00000008 /**< PLB Write Error IRQ */
+#define XLLDMA_IRQ_ERROR_MASK            0x00000004 /**< Error IRQ */
+#define XLLDMA_IRQ_DELAY_MASK            0x00000002 /**< Coalesce delay IRQ */
+#define XLLDMA_IRQ_COALESCE_MASK         0x00000001 /**< Coalesce threshold
+                                                         IRQ */
+#define XLLDMA_IRQ_ALL_ERR_MASK          0x0000001C /**< All error interrupt */
+#define XLLDMA_IRQ_ALL_MASK              0x0000001F /**< All interrupt bits */
+
+/* Shift constants for selected masks */
+#define XLLDMA_IRQ_COALESCE_COUNTER_SHIFT 10
+#define XLLDMA_IRQ_DELAY_COUNTER_SHIFT     8
+
+/*@}*/
+
+
+/** @name Bitmasks of XLLDMA_TX_SR_OFFSET and XLLDMA_RX_SR_OFFSET registers
+ * @{
+ */
+#define XLLDMA_SR_IRQ_ON_END_MASK   0x00000040 /**< IRQ on end has occurred */
+#define XLLDMA_SR_STOP_ON_END_MASK  0x00000020 /**< Stop on end has occurred */
+#define XLLDMA_SR_COMPLETED_MASK    0x00000010 /**< BD completed */
+#define XLLDMA_SR_SOP_MASK          0x00000008 /**< Current BD has SOP set */
+#define XLLDMA_SR_EOP_MASK          0x00000004 /**< Current BD has EOP set */
+#define XLLDMA_SR_ENGINE_BUSY_MASK  0x00000002 /**< Channel is busy */
+/*@}*/
+
+
+/** @name Bitmasks associated with XLLDMA_DMACR_OFFSET register
+ * @{
+ */
+#define XLLDMA_DMACR_TX_PAUSE_MASK             0x20000000 /**< Pause TX channel
+                                                                  */
+#define XLLDMA_DMACR_RX_PAUSE_MASK             0x10000000 /**< Pause RX channel
+                                                                  */
+#define XLLDMA_DMACR_PLB_ERR_DIS_MASK          0x00000020 /**< Disable PLB
+                                                               error detection
+                                                                  */
+#define XLLDMA_DMACR_RX_OVERFLOW_ERR_DIS_MASK  0x00000010 /**< Disable error
+                                                               when 2 or 4 bit
+                                                               coalesce counter
+                                                               overflows */
+#define XLLDMA_DMACR_TX_OVERFLOW_ERR_DIS_MASK  0x00000008 /**< Disable error
+                                                               when 2 or 4 bit
+                                                               coalesce counter
+                                                               overflows */
+#define XLLDMA_DMACR_TAIL_PTR_EN_MASK          0x00000004 /**< Enable use of
+                                                               tail pointer
+                                                               register */
+#define XLLDMA_DMACR_EN_ARB_HOLD_MASK          0x00000002 /**< Enable
+                                                               arbitration
+                                                               hold */
+#define XLLDMA_DMACR_SW_RESET_MASK             0x00000001 /**< Assert Software
+                                                               reset for both
+                                                               channels */
+/*@}*/
+
+
+/** @name Bitmasks of XLLDMA_BD_STSCTRL_USR0_OFFSET descriptor word
+ *  @{
+ */
+#define XLLDMA_BD_STSCTRL_ERROR_MASK      0x80000000  /**< DMA error */
+#define XLLDMA_BD_STSCTRL_IOE_MASK        0x40000000  /**< Interrupt on end */
+#define XLLDMA_BD_STSCTRL_SOE_MASK        0x20000000  /**< Stop on end */
+#define XLLDMA_BD_STSCTRL_COMPLETED_MASK  0x10000000  /**< DMA completed */
+#define XLLDMA_BD_STSCTRL_SOP_MASK        0x08000000  /**< Start of packet */
+#define XLLDMA_BD_STSCTRL_EOP_MASK        0x04000000  /**< End of packet */
+#define XLLDMA_BD_STSCTRL_BUSY_MASK       0x02000000  /**< DMA channel busy */
+
+#define XLLDMA_BD_STSCTRL_MASK            0xFF000000  /**< Status/Control field
+                                                               */
+#define XLLDMA_BD_STSCTRL_USR0_MASK       0x00FFFFFF  /**< User field #0 */
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+#ifdef CONFIG_XILINX_LLDMA_USE_DCR
+
+/* DCR interface is used */
+
+#define XLlDma_In32  XIo_DcrIn
+#define XLlDma_Out32 XIo_DcrOut
+
+#else
+
+/* Non-DCR interface is used */
+
+#define XLlDma_In32  XIo_In32
+#define XLlDma_Out32 XIo_Out32
+
+#endif
+
+/*****************************************************************************/
+/**
+*
+* Read the given register.
+*
+* @param    BaseAddress is the base address of the device
+* @param    RegOffset is the register offset to be read
+*
+* @return   The 32-bit value of the register
+*
+* @note
+* C-style signature:
+*    u32 XLlDma_mReadReg(u32 BaseAddress, u32 RegOffset)
+*
+******************************************************************************/
+#define XLlDma_mReadReg(BaseAddress, RegOffset)             \
+    XLlDma_In32((BaseAddress) + (RegOffset))
+
+/*****************************************************************************/
+/**
+*
+* Write the given register.
+*
+* @param    BaseAddress is the base address of the device
+* @param    RegOffset is the register offset to be written
+* @param    Data is the 32-bit value to write to the register
+*
+* @return   None.
+*
+* @note
+* C-style signature:
+*    void XLlDma_mWriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
+*
+******************************************************************************/
+#define XLlDma_mWriteReg(BaseAddress, RegOffset, Data)          \
+    XLlDma_Out32((BaseAddress) + (RegOffset), (Data))
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xlldma_userip.h b/drivers/xilinx_common/xlldma_userip.h
new file mode 100644
index 0000000..e05a66c
--- /dev/null
+++ b/drivers/xilinx_common/xlldma_userip.h
@@ -0,0 +1,106 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2007 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xlldma_userip.h
+*
+* This file is for the User-IP core (like Local-Link TEMAC) to define constants
+* that are the User-IP core specific. DMA driver requires the constants to work
+* correctly. Two constants must be defined in this file:
+*
+*   - XLLDMA_USR_APPWORD_OFFSET:
+*
+*     This constant defines a user word the User-IP always updates in the RX
+*     Buffer Descriptors (BD) during any Receive transaction.
+*
+*     The DMA driver initializes this chosen user word of any RX BD to the
+*     pre-defined value (see XLLDMA_USR_APPWORD_INITVALUE below) before
+*     giving it to the RX channel. The DMA relies on its updation (by the
+*     User-IP) to ensure the BD has been completed by the RX channel besides
+*     checking the COMPLETE bit in XLLDMA_BD_STSCTRL_USR0_OFFSET field (see
+*     xlldma_hw.h).
+*
+*     The only valid options for this constant are XLLDMA_BD_USR1_OFFSET,
+*     XLLDMA_BD_USR2_OFFSET, XLLDMA_BD_USR3_OFFSET and XLLDMA_BD_USR4_OFFSET.
+*
+*     If the User-IP does not update any of the option fields above, the DMA
+*     driver will not work properly.
+*
+*   - XLLDMA_USR_APPWORD_INITVALUE:
+*
+*     This constant defines the value the DMA driver uses to populate the
+*     XLLDMA_USR_APPWORD_OFFSET field (see above) in any RX BD before giving
+*     the BD to the RX channel for receive transaction.
+*
+*     It must be ensured that the User-IP will always populates a different
+*     value from this constant into the XLLDMA_USR_APPWORD_OFFSET field at
+*     the end of any receive transaction. Failing to do so will cause the
+*     DMA driver to work improperly.
+*
+* If the User-IP uses different setting, the correct setting must be defined as
+* a compiler options used in the Makefile. In either case the default
+* definition of the constants in this file will be discarded.
+*
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   02/21/07 First release
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XLLDMA_USERIP_H		/* prevent circular inclusions */
+#define XLLDMA_USERIP_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xlldma_hw.h"
+
+/************************** Constant Definitions *****************************/
+
+#ifndef XLLDMA_USERIP_APPWORD_OFFSET
+#define XLLDMA_USERIP_APPWORD_OFFSET    XLLDMA_BD_USR4_OFFSET
+#endif
+
+#ifndef XLLDMA_USERIP_APPWORD_INITVALUE
+#define XLLDMA_USERIP_APPWORD_INITVALUE 0xFFFFFFFF
+#endif
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xllfifo.c b/drivers/xilinx_common/xllfifo.c
new file mode 100644
index 0000000..5ee6595
--- /dev/null
+++ b/drivers/xilinx_common/xllfifo.c
@@ -0,0 +1,393 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2005-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file llfifo.c
+ *
+ * The Xilinx local link FIFO driver component. This driver supports the
+ * Xilinx xps_ll_fifo core.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a jvb  10/13/06 First release
+ * </pre>
+ ******************************************************************************/
+
+
+/***************************** Include Files *********************************/
+
+#include <linux/string.h>
+
+#include "xllfifo_hw.h"
+#include "xllfifo.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+#define FIFO_WIDTH_BYTES 4
+
+/*
+ * Implementation Notes:
+ *
+ * This Fifo driver makes use of a byte streamer driver (xstreamer.h). The code
+ * is structured like so:
+ *
+ * +--------------------+
+ * |     llfifo         |
+ * |   +----------------+
+ * |   | +--------------+
+ * |   | |  xstreamer   |
+ * |   | +--------------+
+ * |   +----------------+
+ * |                    |
+ * +--------------------+
+ *
+ * Initialization
+ * At initialization time this driver (llfifo) sets up the streamer objects to
+ * use routines in this driver (llfifo) to perform the actual I/O to the H/W
+ * FIFO core.
+ *
+ * Operation
+ * Once the streamer objects are set up, the API routines in this driver, just
+ * call through to the streamer driver to perform the read/write operations.
+ * The streamer driver will eventually make calls back into the routines (which
+ * reside in this driver) given at initialization to peform the actual I/O.
+ *
+ * Interrupts
+ * Interrupts are handled in the OS/Application layer above this driver.
+ */
+
+xdbg_stmnt(u32 _xllfifo_rr_value;)
+xdbg_stmnt(u32 _xllfifo_ipie_value;)
+xdbg_stmnt(u32 _xllfifo_ipis_value;)
+
+/****************************************************************************/
+/*
+*
+* XLlFifo_RxGetWord reads one 32 bit word from the FIFO specified by
+* <i>InstancePtr</i>.
+*
+* XLlFifo_RxGetLen or XLlFifo_iRxGetLen must be called before calling
+* XLlFifo_RxGetWord. Otherwise, the hardware will raise an <i>Over Read
+* Exception</i>.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_RxGetWord returns the 32 bit word read from the FIFO.
+*
+* @note
+* C-style signature:
+*    u32 XLlFifo_RxGetWord(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_RxGetWord(InstancePtr) \
+	XLlFifo_ReadReg((InstancePtr)->BaseAddress, XLLF_RDFD_OFFSET)
+
+/****************************************************************************/
+/*
+*
+* XLlFifo_TxPutWord writes the 32 bit word, <i>Word</i> to the FIFO specified by
+* <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_TxPutWord(XLlFifo *InstancePtr, u32 Word)
+*
+*****************************************************************************/
+#define XLlFifo_TxPutWord(InstancePtr, Word) \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_TDFD_OFFSET, \
+			(Word))
+
+/*****************************************************************************/
+/*
+*
+* XLlFifo_iRxOccupancy returns the number of 32-bit words available (occupancy)
+* to be read from the receive channel of the FIFO, specified by
+* <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_iRxOccupancy returns the occupancy count in 32-bit words for
+*           the specified FIFO.
+*
+******************************************************************************/
+static u32 XLlFifo_iRxOccupancy(XLlFifo *InstancePtr)
+{
+	XASSERT_NONVOID(InstancePtr);
+
+	return XLlFifo_ReadReg(InstancePtr->BaseAddress,
+			XLLF_RDFO_OFFSET);
+}
+
+/*****************************************************************************/
+/*
+*
+* XLlFifo_iRxGetLen notifies the hardware that the program is ready to receive the
+* next frame from the receive channel of the FIFO specified by <i>InstancePtr</i>.
+*
+* Note that the program must first call XLlFifo_iRxGetLen before pulling data
+* out of the receive channel of the FIFO with XLlFifo_Read.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_iRxGetLen returns the number of bytes available in the next
+*           frame.
+*
+******************************************************************************/
+static u32 XLlFifo_iRxGetLen(XLlFifo *InstancePtr)
+{
+	XASSERT_NONVOID(InstancePtr);
+
+	return XLlFifo_ReadReg(InstancePtr->BaseAddress,
+		XLLF_RLF_OFFSET);
+}
+
+/*****************************************************************************/
+/*
+*
+* XLlFifo_iRead_Aligned reads, <i>WordCount</i>, words from the FIFO referenced by
+* <i>InstancePtr</i> to the block of memory, referenced by <i>BufPtr</i>.
+*
+* XLlFifo_iRead_Aligned assumes that <i>BufPtr</i> is already aligned according
+* to the following hardware limitations:
+*    ppc        - aligned on 32 bit boundaries to avoid performance penalties
+*                 from unaligned exception handling.
+*    microblaze - aligned on 32 bit boundaries as microblaze does not handle
+*                 unaligned transfers.
+*
+* Care must be taken to ensure that the number of words read with one or more
+* calls to XLlFifo_Read() does not exceed the number of bytes (rounded up to
+* the nearest whole 32 bit word) available given from the last call to
+* XLlFifo_RxGetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address to place the data read.
+*
+* @param    WordCount specifies the number of 32 bit words to read.
+*
+* @return   XLlFifo_iRead_Aligned always returns XST_SUCCESS. Error handling is
+*           otherwise handled through hardware exceptions and interrupts.
+*
+* @note
+*
+* C Signature: int XLlFifo_iRead_Aligned(XLlFifo *InstancePtr,
+*                      void *BufPtr, unsigned WordCount);
+*
+******************************************************************************/
+/* static */ int XLlFifo_iRead_Aligned(XLlFifo *InstancePtr, void *BufPtr,
+			     unsigned WordCount)
+{
+	unsigned WordsRemaining = WordCount;
+	u32 *BufPtrIdx = BufPtr;
+
+	xdbg_printf(XDBG_DEBUG_FIFO_RX, "XLlFifo_iRead_Aligned: start\n");
+	XASSERT_NONVOID(InstancePtr);
+	XASSERT_NONVOID(BufPtr);
+	/* assert bufer is 32 bit aligned */
+	XASSERT_NONVOID(((unsigned)BufPtr & 0x3) == 0x0);
+	xdbg_printf(XDBG_DEBUG_FIFO_RX, "XLlFifo_iRead_Aligned: after asserts\n");
+
+	while (WordsRemaining) {
+/*		xdbg_printf(XDBG_DEBUG_FIFO_RX,
+			    "XLlFifo_iRead_Aligned: WordsRemaining: %d\n",
+			    WordsRemaining);
+*/
+		*BufPtrIdx = XLlFifo_RxGetWord(InstancePtr);
+		BufPtrIdx++;
+		WordsRemaining--;
+	}
+	xdbg_printf(XDBG_DEBUG_FIFO_RX,
+		    "XLlFifo_iRead_Aligned: returning SUCCESS\n");
+	return XST_SUCCESS;
+}
+
+/****************************************************************************/
+/*
+*
+* XLlFifo_iTxVacancy returns the number of unused 32 bit words available
+* (vacancy) in the send channel of the FIFO, specified by <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_iTxVacancy returns the vacancy count in 32-bit words for
+*           the specified FIFO.
+*
+*****************************************************************************/
+static u32 XLlFifo_iTxVacancy(XLlFifo *InstancePtr)
+{
+	XASSERT_NONVOID(InstancePtr);
+
+	return XLlFifo_ReadReg(InstancePtr->BaseAddress,
+			XLLF_TDFV_OFFSET);
+}
+
+/*****************************************************************************/
+/*
+*
+* XLlFifo_iTxSetLen begins a hardware transfer of data out of the transmit
+* channel of the FIFO, specified by <i>InstancePtr</i>. <i>Bytes</i> specifies the number
+* of bytes in the frame to transmit.
+*
+* Note that <i>Bytes</i> (rounded up to the nearest whole 32 bit word) must be same
+* number of words just written using one or more calls to
+* XLlFifo_iWrite_Aligned()
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    Bytes specifies the number of bytes to transmit.
+*
+* @return   N/A
+*
+******************************************************************************/
+static void XLlFifo_iTxSetLen(XLlFifo *InstancePtr, u32 Bytes)
+{
+	XASSERT_VOID(InstancePtr);
+
+	XLlFifo_WriteReg(InstancePtr->BaseAddress, XLLF_TLF_OFFSET,
+			Bytes);
+}
+
+/*****************************************************************************/
+/*
+*
+* XLlFifo_iWrite_Aligned writes, <i>WordCount</i>, words to the FIFO referenced by
+* <i>InstancePtr</i> from the block of memory, referenced by <i>BufPtr</i>.
+*
+* XLlFifo_iWrite_Aligned assumes that <i>BufPtr</i> is already aligned according
+* to the following hardware limitations:
+*    ppc        - aligned on 32 bit boundaries to avoid performance penalties
+*                 from unaligned exception handling.
+*    microblaze - aligned on 32 bit boundaries as microblaze does not handle
+*                 unaligned transfers.
+*
+* Care must be taken to ensure that the number of words written with one or
+* more calls to XLlFifo_iWrite_Aligned() matches the number of bytes (rounded up
+* to the nearest whole 32 bit word) given in the next call to
+* XLlFifo_iTxSetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address to place the data read.
+*
+* @param    WordCount specifies the number of 32 bit words to read.
+*
+* @return   XLlFifo_iWrite_Aligned always returns XST_SUCCESS. Error handling is
+*           otherwise handled through hardware exceptions and interrupts.
+*
+* @note
+*
+* C Signature: int XLlFifo_iWrite_Aligned(XLlFifo *InstancePtr,
+*                      void *BufPtr, unsigned WordCount);
+*
+******************************************************************************/
+/* static */ int XLlFifo_iWrite_Aligned(XLlFifo *InstancePtr, void *BufPtr,
+			      unsigned WordCount)
+{
+	unsigned WordsRemaining = WordCount;
+	u32 *BufPtrIdx = BufPtr;
+
+	xdbg_printf(XDBG_DEBUG_FIFO_TX,
+		    "XLlFifo_iWrite_Aligned: Inst: %p; Buff: %p; Count: %d\n",
+		    InstancePtr, BufPtr, WordCount);
+	XASSERT_NONVOID(InstancePtr);
+	XASSERT_NONVOID(BufPtr);
+	/* assert bufer is 32 bit aligned */
+	XASSERT_NONVOID(((unsigned)BufPtr & 0x3) == 0x0);
+
+	xdbg_printf(XDBG_DEBUG_FIFO_TX,
+		    "XLlFifo_iWrite_Aligned: WordsRemaining: %d\n",
+		    WordsRemaining);
+	while (WordsRemaining) {
+		XLlFifo_TxPutWord(InstancePtr, *BufPtrIdx);
+		BufPtrIdx++;
+		WordsRemaining--;
+	}
+	
+	xdbg_printf(XDBG_DEBUG_FIFO_TX,
+		    "XLlFifo_iWrite_Aligned: returning SUCCESS\n");
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_Initialize initializes an XPS_ll_Fifo device along with the
+* <i>InstancePtr</i> that references it.
+*
+* @param    InstancePtr references the memory instance to be associated with
+*           the FIFO device upon initialization.
+*
+* @param    BaseAddress is the processor address used to access the
+*           base address of the Fifo device.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XLlFifo_Initialize(XLlFifo *InstancePtr, u32 BaseAddress)
+{
+	XASSERT_VOID(InstancePtr);
+	XASSERT_VOID(BaseAddress);
+
+	/* Clear instance memory */
+	memset(InstancePtr, 0, sizeof(XLlFifo));
+
+	/*
+	 * We don't care about the physical base address, just copy the
+	 * processor address over it.
+	 */
+	InstancePtr->BaseAddress = BaseAddress;
+
+	InstancePtr->IsReady = XCOMPONENT_IS_READY;
+
+	XLlFifo_TxReset(InstancePtr);
+	XLlFifo_RxReset(InstancePtr);
+
+	XStrm_RxInitialize(&(InstancePtr->RxStreamer), FIFO_WIDTH_BYTES,
+			(void *)InstancePtr,
+                        (XStrm_XferFnType)XLlFifo_iRead_Aligned,
+                        (XStrm_GetLenFnType)XLlFifo_iRxGetLen,
+                        (XStrm_GetOccupancyFnType)XLlFifo_iRxOccupancy);
+
+	XStrm_TxInitialize(&(InstancePtr->TxStreamer), FIFO_WIDTH_BYTES,
+			(void *)InstancePtr,
+                        (XStrm_XferFnType)XLlFifo_iWrite_Aligned,
+                        (XStrm_SetLenFnType)XLlFifo_iTxSetLen,
+                        (XStrm_GetVacancyFnType)XLlFifo_iTxVacancy);
+}
+
diff --git a/drivers/xilinx_common/xllfifo.h b/drivers/xilinx_common/xllfifo.h
new file mode 100644
index 0000000..2df16cb
--- /dev/null
+++ b/drivers/xilinx_common/xllfifo.h
@@ -0,0 +1,575 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2005-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+ *
+ * @file llfifo.h
+ *
+ * The Xilinx Dual Channel Fifo driver component. This driver supports the
+ * Virtex-5(TM) and Virtex-4(TM) XPS_ll_Fifo.
+ *
+ * For a full description of the bridge features, please see the HW spec. This driver
+ * supports the following features:
+ *   - Memory mapped access to host interface registers
+ *   - API for polled frame transfers
+ *   - API for interrupt driven frame transfers
+ *   - Virtual memory support
+ *   - Full duplex operation
+ *
+ * <h2>Driver Description</h2>
+ *
+ * This driver enables higher layer software to access the XPS_llFifo core
+ * using any alignment in the data buffers.
+ * 
+ * This driver supports send and receive channels in the same instance
+ * structure in the same fashion as the hardware core.
+ * 
+ * <h2>Initialization</h2>
+ *
+ * An instance of this driver is initialized using a call to Initialize().
+ * 
+ * <h2>Usage</h2>
+ * 
+ * It is fairly simple to use the API provided by this FIFO driver. The
+ * only somewhat tricky part is that the calling code must correctly call
+ * a couple routines in the right sequence for receive and transmit.
+ *
+ * This sequence is described here. Check the routine functional 
+ * descriptions for information on how to use a specific API routine.
+ *
+ * <h3>Receive</h3>
+ *
+ * A frame is received by using the following sequence:<br>
+ * 1) call XLlFifo_RxGetLen() to get the length of the next incoming frame<br>
+ * 2) call XLlFifo_Read() one or more times to read the number of bytes
+ *    reported by XLlFifo_RxGetLen().<br>
+ *
+ * For example:
+ * <pre>
+ * 	frame_len = XLlFifo_RxGetLen(&RxInstance);
+ * 	while (frame_len) {
+ * 		unsigned bytes = min(sizeof(buffer), frame_len);
+ * 		XLlFifo_Read(&RxInstance, buffer, bytes);
+ * 		// ********
+ * 		// do something with buffer here
+ * 		// ********
+ * 		frame_len -= bytes;
+ * 	}
+ * </pre>
+ *
+ * This FIFO hardware core does <b>not</b> support a sequence where the
+ * calling code calls RxGetLen() twice in a row and then receive the data
+ * for two frames. Each frame must be read in by calling RxGetLen() just
+ * prior to reading the data.
+ *
+ * <h3>Transmit</h3>
+ * A frame is transmittted by using the following sequence:<br>
+ * 1) call XLlFifo_Write() one or more times to write all the of bytes in
+ *    the next frame.<br>
+ * 2) call XLlFifo_TxSetLen() to begin the transmission of frame just
+ *    written.<br>
+ *
+ * For example:
+ * <pre>
+ * 	frame_left = frame_len;
+ * 	while (frame_left) {
+ * 		unsigned bytes = min(sizeof(buffer), frame_left);
+ * 		XLlFifo_Write(&TxInstance, buffer, bytes);
+ * 		// ********
+ * 		// do something here to refill buffer
+ * 		// ********
+ * 	}
+ * 	XLlFifo_TxSetLen(&RxInstance, frame_len);
+ * </pre>
+ *
+ * This FIFO hardware core does <b>not</b> support a sequence where the
+ * calling code writes the data for two frames and then calls TxSetLen()
+ * twice in a row. Each frame must be written by writting the data for one
+ * frame and then calling TxSetLen().
+ * 
+ * <h2>Interrupts</h2>
+ * This driver does not handle interrupts from the FIFO hardware. The
+ * software layer above may make use of the interrupts by setting up its
+ * own handlers for the interrupts.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a jvb  10/12/06 First release
+ * </pre>
+ *
+ *****************************************************************************/
+#ifndef XLLFIFO_H		/* prevent circular inclusions */
+#define XLLFIFO_H		/* by using preprocessor symbols */
+
+/* force C linkage */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xllfifo_hw.h"
+#include "xstreamer.h"
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * This typedef defines a run-time instance of an XLlFifo device.
+ */
+typedef struct XLlFifo {
+	u32 BaseAddress;  /**< BaseAddress is the physical base address of the
+	                   *   device's registers
+	                   */
+
+	u32 IsReady;           /**< IsReady is non-zero if the driver instance
+	                        *   has been initialized.
+	                        */
+	XStrm_RxFifoStreamer RxStreamer; /**< RxStreamer is the byte streamer
+	                                  *   instance for the receive channel.
+	                                  */
+	XStrm_TxFifoStreamer TxStreamer; /**< TxStreamer is the byte streamer
+	                                  *   instance for the transmit channel.
+	                                  */
+} XLlFifo;
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_Reset resets both the Tx and Rx channels and the local link interface
+* the FIFO specified by <i>InstancePtr</i>. XLlFifo_TxReset resets also sends a
+* reset pulse to the downstream device (e.g. TEMAC). XLlFifo_Reset drops any
+* bytes in the FIFO not yet retrieved. XLlFifo_Reset drops any bytes in the FIFO
+* not yet transmitted.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_Reset(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_Reset(InstancePtr) \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_LLR_OFFSET, \
+			XLLF_LLR_RESET_MASK)
+
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_Status returns a bit mask of the interrupt status register (ISR)
+* for the FIFO specified by <i>InstancePtr</i>. XLlFifo_Status can be used
+* to query the status of the FIFO without having to have interrupts enabled.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_IntStatus returns a bit mask of the status conditions.
+*           The mask will be a set of bitwise or'd values from the
+*           <code>XLLF_INT_*_MASK</code> preprocessor symbols.
+*
+* @note
+* C-style signature:
+*    u32 XLlFifo_IntStatus(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_Status(InstancePtr) \
+	 XLlFifo_ReadReg((InstancePtr)->BaseAddress, XLLF_ISR_OFFSET)
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IntEnable enables the interrupts specified in <i>Mask</i> for the
+* FIFO specified by <i>InstancePtr</i>. The corresponding interrupt for each bit
+* set to 1 in <i>Mask</i>, will be enabled.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    Mask contains a bit mask of the interrupts to enable. The mask
+*           can be formed using a set of bitwise or'd values from the
+*           <code>XLLF_INT_*_MASK</code> preprocessor symbols.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_IntEnable(XLlFifo *InstancePtr, u32 Mask)
+*
+*****************************************************************************/
+#define XLlFifo_IntEnable(InstancePtr, Mask) \
+{ \
+	u32 Reg = XLlFifo_ReadReg((InstancePtr)->BaseAddress, \
+			XLLF_IER_OFFSET); \
+	Reg |= ((Mask) & XLLF_INT_ALL_MASK);                    \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_IER_OFFSET, \
+			Reg); \
+}
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IntDisable disables the interrupts specified in <i>Mask</i> for the
+* FIFO specified by <i>InstancePtr</i>. The corresponding interrupt for each bit
+* set to 1 in <i>Mask</i>, will be disabled. In other words, XLlFifo_IntDisable
+* uses the "set a bit to clear it" scheme.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    Mask contains a bit mask of the interrupts to disable. The mask
+*           can be formed using a set of bitwise or'd values from the
+*           <code>XLLF_INT_*_MASK</code> preprocessor symbols.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_IntDisable(XLlFifo *InstancePtr, u32 Mask)
+*
+*****************************************************************************/
+#define XLlFifo_IntDisable(InstancePtr, Mask) \
+{ \
+	u32 Reg = XLlFifo_ReadReg((InstancePtr)->BaseAddress, \
+			XLLF_IER_OFFSET); \
+	Reg &= ~((Mask) & XLLF_INT_ALL_MASK);  \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_IER_OFFSET, \
+			Reg); \
+}
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IntPending returns a bit mask of the pending interrupts for the
+* FIFO specified by <i>InstancePtr</i>. Each bit set to 1 in the return value
+* represents a pending interrupt.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_IntPending returns a bit mask of the interrupts that are
+*           pending. The mask will be a set of bitwise or'd values from the
+*           <code>XLLF_INT_*_MASK</code> preprocessor symbols.
+*
+* @note
+* C-style signature:
+*    u32 XLlFifo_IntPending(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#ifdef DEBUG
+extern u32 _xllfifo_ipie_value;
+extern u32 _xllfifo_ipis_value;
+#define XLlFifo_IntPending(InstancePtr) \
+	(_xllfifo_ipie_value = XLlFifo_ReadReg( \
+		(InstancePtr)->BaseAddress, XLLF_IER_OFFSET),  \
+	_xllfifo_ipis_value = XLlFifo_ReadReg( \
+		(InstancePtr)->BaseAddress, XLLF_ISR_OFFSET),  \
+	(_xllfifo_ipie_value & _xllfifo_ipis_value))
+#else
+#define XLlFifo_IntPending(InstancePtr) \
+	(XLlFifo_ReadReg((InstancePtr)->BaseAddress, XLLF_IER_OFFSET) &  \
+	 XLlFifo_ReadReg((InstancePtr)->BaseAddress, XLLF_ISR_OFFSET))
+#endif
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IntClear clears pending interrupts specified in <i>Mask</i> for the
+* FIFO specified by <i>InstancePtr</i>. The corresponding pending interrupt for
+* each bit set to 1 in <i>Mask</i>, will be cleared. In other words,
+* XLlFifo_IntClear uses the "set a bit to clear it" scheme.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    Mask contains a bit mask of the pending interrupts to clear. The
+*           mask can be formed using a set of bitwise or'd values from the
+*           <code>XLLF_INT_*_MASK</code> preprocessor symbols.
+*
+* @note
+* C-style signature:
+*    void XLlFifo_IntClear(XLlFifo *InstancePtr, u32 Mask)
+*
+*****************************************************************************/
+#define XLlFifo_IntClear(InstancePtr, Mask) \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_ISR_OFFSET, \
+			((Mask) & XLLF_INT_ALL_MASK))
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_RxReset resets the receive channel of the FIFO specified by
+* <i>InstancePtr</i>. XLlFifo_RxReset drops any bytes in the FIFO not yet
+* retrieved.
+*
+* The calling software may want to test for the completion of the reset by
+* reading the interrupt status (IS) register and testing for the Rx Reset
+* complete (RRC) bit.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_RxReset(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_RxReset(InstancePtr) \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_RDFR_OFFSET, \
+			XLLF_RDFR_RESET_MASK)
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IsRxEmpty returns true if the receive channel of the FIFO, specified
+* by <i>InstancePtr</i>, is empty.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_IsRxEmpty returns TRUE when the receive channel of the
+*           FIFO is empty. Otherwise, XLlFifo_IsRxEmpty returns FALSE.
+*
+* @note
+* C-style signature:
+*    int XLlFifo_IsRxEmpty(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_IsRxEmpty(InstancePtr) \
+	((XStrm_IsRxInternalEmpty(&((InstancePtr)->RxStreamer)) && \
+	((XLlFifo_ReadReg((InstancePtr)->BaseAddress, \
+			XLLF_RDFO_OFFSET) == 0))) \
+			? TRUE : FALSE)
+
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_RxOccupancy returns the number of 32-bit words available (occupancy) to
+* be read from the receive channel of the FIFO, specified by <i>InstancePtr</i>.
+*
+* The xps_ll_fifo core uses the same fifo to store data values and frame length
+* values. Upon initialization, the XLlFifo_RxOccupancy will give the value of
+* 1, which means one length value (a reserved fifo location) and no data
+* values.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_RxOccupancy returns the occupancy count for the specified
+*           packet FIFO.
+*
+* @note
+*
+* C Signature: u32 XLlFifo_RxOccupancy(XLlFifo *InstancePtr)
+*
+******************************************************************************/
+#define XLlFifo_RxOccupancy(InstancePtr) \
+	XStrm_RxOccupancy(&((InstancePtr)->RxStreamer))
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_RxGetLen notifies the hardware that the program is ready to receive
+* the next frame from the receive channel of the FIFO, specified by
+* <i>InstancePtr</i>.
+*
+* Note that the program must first call XLlFifo_RxGetLen before pulling data
+* out of the receive channel of the FIFO with XLlFifo_Read.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_RxGetLen returns the number of bytes available in the next
+*           frame.
+*
+* @note
+*
+* C Signature: u32 XLlFifo_RxGetLen(XLlFifo *InstancePtr)
+*
+******************************************************************************/
+#define XLlFifo_RxGetLen(InstancePtr) \
+	XStrm_RxGetLen(&((InstancePtr)->RxStreamer))
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_Read reads <i>Bytes</i> bytes from the receive channel of the FIFO
+* referenced by <i>InstancePtr</i> to the block of memory, referenced by
+* <i>BufPtr</i>. 
+*
+* Care must be taken to ensure that the number of bytes read with one or more
+* calls to XLlFifo_Read() does not exceed the number of bytes available given
+* from the last call to XLlFifo_RxGetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address to place the data read.
+*
+* @param    Bytes specifies the number of bytes to read.
+*
+* @return   N/A
+*
+* @note
+* Error handling is handled through hardware exceptions and interrupts.
+*
+* C Signature: void XLlFifo_Read(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)
+*
+******************************************************************************/
+#define XLlFifo_Read(InstancePtr, BufPtr, Bytes) \
+	XStrm_Read(&((InstancePtr)->RxStreamer), (BufPtr), (Bytes))
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_TxReset resets the transmit channel of the FIFO specified by
+* <i>InstancePtr</i>. XLlFifo_TxReset drops any bytes in the FIFO not yet
+* transmitted.
+*
+* The calling software may want to test for the completion of the reset by
+* reading the interrupt status (IS) register and testing for the Tx Reset
+* complete (TRC) bit.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_TxReset(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_TxReset(InstancePtr) \
+	XLlFifo_WriteReg((InstancePtr)->BaseAddress, XLLF_TDFR_OFFSET, \
+			XLLF_TDFR_RESET_MASK)
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_IsTxDone returns true if the transmission in the transmit channel
+* of the FIFO, specified by <i>InstancePtr</i>, is complete. XLlFifo_IsTxDone
+* works only if the TC bit in the IS register is cleared before sending a
+* frame.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_IsTxDone returns TRUE when the transmit channel of the
+*           FIFO is complete. Otherwise, XLlFifo_IsTxDone returns FALSE.
+*
+* @note
+* C-style signature:
+*    int XLlFifo_IsTxDone(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_IsTxDone(InstancePtr) \
+	((XLlFifo_ReadReg((InstancePtr)->BaseAddress, XLLF_ISR_OFFSET) & \
+		XLLF_INT_TC_MASK) \
+		? TRUE : FALSE)
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_TxVacancy returns the number of unused 32 bit words available
+* (vacancy) in the send channel of the FIFO specified by <i>InstancePtr</i>.
+*
+* The xps_ll_fifo core uses tXLLF_he same fifo to store data values and frame length
+* values. Upon initialization, the XLlFifo_TxVacancy will give the value of
+* FIFO_WIDTH - 1, which means one length value used (a reserved fifo location)
+* and no data values yet present.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XLlFifo_TxVacancy returns the vacancy count in 32-bit words for
+*           the specified FIFO.
+*
+* @note
+* C-style signature:
+*    u32 XLlFifo_TxVacancy(XLlFifo *InstancePtr)
+*
+*****************************************************************************/
+#define XLlFifo_TxVacancy(InstancePtr) \
+	XStrm_TxVacancy(&((InstancePtr)->TxStreamer))
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_TxSetLen begins a hardware transfer of <i>Bytes</i> bytes out of the
+* transmit channel of the FIFO specified by <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    Bytes specifies the frame length in bytes.
+*
+* @return   N/A
+*
+* @note
+*
+* C Signature: void XLlFifo_TxSetLen(XLlFifo *InstancePtr, u32 Bytes)
+*
+******************************************************************************/
+#define XLlFifo_TxSetLen(InstancePtr, Bytes) \
+	XStrm_TxSetLen(&((InstancePtr)->TxStreamer), (Bytes))
+
+/*****************************************************************************/
+/**
+*
+* XLlFifo_Write writes <i>Bytes</i> bytes of the block of memory, referenced by
+* <i>BufPtr</i>, to the transmit channel of the FIFO referenced by
+* <i>InstancePtr</i>. 
+*
+* Care must be taken to ensure that the number of bytes written with one or
+* more calls to XLlFifo_Write() matches the number of bytes given in the next
+* call to XLlFifo_TxSetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address of data to write.
+*
+* @param    Bytes specifies the number of bytes to write.
+*
+* @return   N/A
+*
+* @note
+* Error handling is handled through hardware exceptions and interrupts.
+*
+* C Signature: void XLlFifo_Write(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)
+*
+******************************************************************************/
+#define XLlFifo_Write(InstancePtr, BufPtr, Bytes) \
+	XStrm_Write(&((InstancePtr)->TxStreamer), (BufPtr), (Bytes))
+	
+ 
+/************************** Function Prototypes ******************************/
+/*
+ * Initialization functions in xtemac_sinit.c
+ */
+void XLlFifo_Initialize(XLlFifo *InstancePtr, u32 BaseAddress);
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* XLLFIFO_H  end of preprocessor protection symbols */
diff --git a/drivers/xilinx_common/xllfifo_hw.h b/drivers/xilinx_common/xllfifo_hw.h
new file mode 100644
index 0000000..9b7522b
--- /dev/null
+++ b/drivers/xilinx_common/xllfifo_hw.h
@@ -0,0 +1,211 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2004-2006 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file llfifo_hw.h
+*
+* This header file contains identifiers and low-level driver functions (or
+* macros) that can be used to access the xps_ll_fifo core.
+* High-level driver functions are defined in xpfifo.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a jvb  10/16/06 First release.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XLLFIFO_HW_H		/* prevent circular inclusions */
+#define XLLFIFO_HW_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xio.h"
+#include "xdebug.h"
+			 
+/************************** Constant Definitions *****************************/
+
+/* Register offset definitions. Unless otherwise noted, register access is
+ * 32 bit.
+ */
+
+/** @name Registers
+ *  @{
+ */
+#define XLLF_ISR_OFFSET  0x00000000  /**< Interrupt Status */
+#define XLLF_IER_OFFSET  0x00000004 /**< Interrupt Enable */
+
+#define XLLF_TDFR_OFFSET 0x00000008  /**< Transmit Reset */
+#define XLLF_TDFV_OFFSET 0x0000000c  /**< Transmit Vacancy */
+#define XLLF_TDFD_OFFSET 0x00000010  /**< Transmit Data */
+#define XLLF_TLF_OFFSET  0x00000014  /**< Transmit Length */
+
+#define XLLF_RDFR_OFFSET 0x00000018  /**< Receive Reset */
+#define XLLF_RDFO_OFFSET 0x0000001c  /**< Receive Occupancy */
+#define XLLF_RDFD_OFFSET 0x00000020  /**< Receive Data */
+#define XLLF_RLF_OFFSET  0x00000024  /**< Receive Length */
+#define XLLF_LLR_OFFSET  0x00000028  /**< Local Link Reset */
+
+/*@}*/
+
+/* Register masks. The following constants define bit locations of various
+ * control bits in the registers. Constants are not defined for those registers
+ * that have a single bit field representing all 32 bits. For further
+ * information on the meaning of the various bit masks, refer to the HW spec.
+ */
+
+/** @name Interrupt bits
+ *  These bits are associated with the XLLF_IER_OFFSET and XLLF_ISR_OFFSET
+ *  registers.
+ * @{
+ */
+#define XLLF_INT_RPURE_MASK       0x80000000 /**< Receive under-read */
+#define XLLF_INT_RPORE_MASK       0x40000000 /**< Receive over-read */
+#define XLLF_INT_RPUE_MASK        0x20000000 /**< Receive underrun (empty) */
+#define XLLF_INT_TPOE_MASK        0x10000000 /**< Transmit overrun */
+#define XLLF_INT_TC_MASK          0x08000000 /**< Transmit complete */
+#define XLLF_INT_RC_MASK          0x04000000 /**< Receive complete */
+#define XLLF_INT_TSE_MASK         0x02000000 /**< Transmit length mismatch */
+#define XLLF_INT_TRC_MASK         0x01000000 /**< Transmit reset complete */
+#define XLLF_INT_RRC_MASK         0x00800000 /**< Receive reset complete */
+#define XLLF_INT_ALL_MASK         0xff800000 /**< All the ints */
+#define XLLF_INT_ERROR_MASK       0xf2000000 /**< Error status ints */
+#define XLLF_INT_RXERROR_MASK     0xe0000000 /**< Receive Error status ints */
+#define XLLF_INT_TXERROR_MASK     0x12000000 /**< Transmit Error status ints */
+/*@}*/
+
+/** @name Reset register values
+ *  These bits are associated with the XLLF_TDFR_OFFSET and XLLF_RDFR_OFFSET
+ *  reset registers.
+ * @{
+ */
+#define XLLF_RDFR_RESET_MASK        0x000000a5 /**< receive reset value */
+#define XLLF_TDFR_RESET_MASK        0x000000a5 /**< Transmit reset value */
+#define XLLF_LLR_RESET_MASK        0x000000a5 /**< Local Link reset value */
+/*@}*/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/**** debug macros ****/
+#define XLlFifo_reg_name(RegOffset) \
+	(((RegOffset) == XLLF_ISR_OFFSET) ? "ISR": \
+	((RegOffset) == XLLF_IER_OFFSET) ? "IER": \
+	((RegOffset) == XLLF_TDFR_OFFSET) ? "TDFR {tx reset}": \
+	((RegOffset) == XLLF_TDFV_OFFSET) ? "TDFV {tx vacancy}": \
+	((RegOffset) == XLLF_TDFD_OFFSET) ? "TDFD {tx data}": \
+	((RegOffset) == XLLF_TLF_OFFSET) ? "TLF {tx length}": \
+	((RegOffset) == XLLF_RDFR_OFFSET) ? "RDFR {rx reset}": \
+	((RegOffset) == XLLF_RDFO_OFFSET) ? "RDFO {rx occupancy}": \
+	((RegOffset) == XLLF_RDFD_OFFSET) ? "RDFD {rx data}": \
+	((RegOffset) == XLLF_RLF_OFFSET) ? "RLF {rx length}": \
+	"unknown")
+
+#define XLlFifo_print_reg_o(BaseAddress, RegOffset, Value) \
+	 xdbg_printf(XDBG_DEBUG_FIFO_REG, "0x%08x -> %s(0x%08x)\n", (Value), \
+			  XLlFifo_reg_name(RegOffset), \
+			 (RegOffset) + (BaseAddress))
+
+#define XLlFifo_print_reg_i(BaseAddress, RegOffset, Value) \
+	xdbg_printf(XDBG_DEBUG_FIFO_REG, "%s(0x%08x) -> 0x%08x\n", \
+			 XLlFifo_reg_name(RegOffset), \
+			(RegOffset) + (BaseAddress), (Value))
+/**** end debug macros ****/
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_ReadReg returns the value of the register at the offet,
+* <i>RegOffset</i>, from the memory mapped base address, <i>BaseAddress</i>.
+*
+* @param    BaseAddress specifies the base address of the device.
+*
+* @param    RegOffset specifies the offset from BaseAddress.
+*
+* @return   XLlFifo_ReadReg returns the value of the specified register.
+*
+* @note
+* C-style signature:
+*    u32 XLlFifo_ReadReg(u32 BaseAddress, u32 RegOffset)
+*
+*****************************************************************************/
+#ifdef DEBUG
+extern u32 _xllfifo_rr_value;
+#define XLlFifo_ReadReg(BaseAddress, RegOffset) \
+	((((RegOffset) > 0x24) ? xdbg_printf(XDBG_DEBUG_ERROR, \
+		"XLlFifo_WriteReg: Woah! wrong reg addr: 0x%08x\n", \
+		(RegOffset)) : 0), \
+	_xllfifo_rr_value = XIo_In32((BaseAddress) + (RegOffset)), \
+	XLlFifo_print_reg_i((BaseAddress), (RegOffset), _xllfifo_rr_value), \
+	_xllfifo_rr_value)
+#else
+#define XLlFifo_ReadReg(BaseAddress, RegOffset) \
+	(XIo_In32((BaseAddress) + (RegOffset)))
+#endif
+
+/****************************************************************************/
+/**
+*
+* XLlFifo_WriteReg writes the value, <i>Value</i>, to the register at the
+* offet, <i>RegOffset</i>, from the memory mapped base address,
+* <i>BaseAddress</i>.
+*
+* @param    BaseAddress specifies the base address of the device.
+*
+* @param    RegOffset specifies the offset from BaseAddress.
+*
+* @param    Value is value to write to the register.
+*
+* @return   N/A
+*
+* @note
+* C-style signature:
+*    void XLlFifo_WriteReg(u32 BaseAddress, u32 RegOffset, u32 Value)
+*
+*****************************************************************************/
+#ifdef DEBUG
+#define XLlFifo_WriteReg(BaseAddress, RegOffset, Value) \
+	(((RegOffset) > 0x24) ? xdbg_printf(XDBG_DEBUG_ERROR, \
+		"XLlFifo_WriteReg: Woah! wrong reg addr: 0x%08x\n", \
+		(RegOffset)) : 0), \
+	XLlFifo_print_reg_o((BaseAddress), (RegOffset), (Value)), \
+	(XIo_Out32((BaseAddress) + (RegOffset), (Value)))
+#else
+#define XLlFifo_WriteReg(BaseAddress, RegOffset, Value) \
+	((XIo_Out32((BaseAddress) + (RegOffset), (Value))))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* XLLFIFO_HW_H  end of protection macro */
diff --git a/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.c b/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.c
new file mode 100644
index 0000000..3c64fb3
--- /dev/null
+++ b/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.c
@@ -0,0 +1,852 @@
+/* $Id: xpacket_fifo_l_v2_00_a.c,v 1.1 2006/12/13 14:22:53 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2003-2004 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xpacket_fifo_l_v2_00_a.c
+*
+* Contains low-level (Level 0) functions for the XPacketFifoV200a driver.
+* See xpacket_fifo_v2_00_a.h for information about the high-level (Level 1)
+* driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- ------------------------------------------------------
+* 2.00a rpm  10/22/03  First release. Moved most of Level 1 driver functions
+*                      into this layer.
+* 2.00a rmm  02/24/04  Added L0WriteDRE function.
+* 2.00a xd   10/27/04  Changed comments to support doxygen for API
+*                      documentation.
+* </pre>
+*
+*****************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xio.h"
+#include "xpacket_fifo_l_v2_00_a.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************* Variable Definitions ******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+static int Write32(u32 RegBaseAddress, u32 DataBaseAddress,
+		   u8 *BufferPtr, u32 ByteCount);
+
+static int Write64(u32 RegBaseAddress, u32 DataBaseAddress,
+		   u8 *BufferPtr, u32 ByteCount);
+
+static int Read32(u32 RegBaseAddress, u32 DataBaseAddress,
+		  u8 *BufferPtr, u32 ByteCount);
+
+static int Read64(u32 RegBaseAddress, u32 DataBaseAddress,
+		  u8 *BufferPtr, u32 ByteCount);
+
+
+/*****************************************************************************/
+/**
+*
+* Read data from a FIFO and puts it into a specified buffer. The packet FIFO is
+* currently 32 or 64 bits wide such that an input buffer which is a series of
+* bytes is filled from the FIFO a word at a time. If the requested byte count
+* is not a multiple of 32/64 bit words, it is necessary for this function to
+* format the remaining 32/64 bit word from the FIFO into a series of bytes in
+* the buffer. There may be up to 3/7 extra bytes which must be extracted from
+* the last word of the FIFO and put into the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer to write the data into. This
+*        buffer must be 32 bit aligned or an alignment exception could be
+*        generated. Since this buffer is a byte buffer, the data is assumed to
+*        be endian independent.
+*
+* @param ByteCount contains the number of bytes to read from the FIFO. This
+*        number of bytes must be present in the FIFO or an error will be
+*        returned.
+*
+* @return
+*
+* XST_SUCCESS indicates the operation was successful.  If the number of
+* bytes specified by the byte count is not present in the FIFO
+* XST_PFIFO_LACK_OF_DATA is returned.
+* <br><br>
+* If the function was successful, the specified buffer is modified to contain
+* the bytes which were removed from the FIFO.
+*
+* @note
+*
+* Note that the exact number of bytes which are present in the FIFO is
+* not known by this function.  It can only check for a number of 32/64 bit
+* words such that if the byte count specified is incorrect, but is still
+* possible based on the number of words in the FIFO, up to 3/7 garbage bytes
+* may be present at the end of the buffer.
+* <br><br>
+* This function assumes that if the device consuming data from the FIFO is
+* a byte device, the order of the bytes to be consumed is from the most
+* significant byte to the least significant byte of a 32/64 bit word removed
+* from the FIFO.
+*
+******************************************************************************/
+int XPacketFifoV200a_L0Read(u32 RegBaseAddress, u32 DataBaseAddress,
+			    u8 *BufferPtr, u32 ByteCount)
+{
+	u32 Width;
+	int Result = XST_FIFO_ERROR;
+
+	/* determine the width of the FIFO
+	 */
+	Width = XIo_In32(RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_FIFO_WIDTH_MASK;
+
+	if ((Width == XPF_V200A_FIFO_WIDTH_LEGACY_TYPE) ||
+	    (Width == XPF_V200A_FIFO_WIDTH_32BITS_TYPE)) {
+		Result = Read32(RegBaseAddress, DataBaseAddress, BufferPtr,
+				ByteCount);
+	}
+	else if (Width == XPF_V200A_FIFO_WIDTH_64BITS_TYPE) {
+		Result = Read64(RegBaseAddress, DataBaseAddress, BufferPtr,
+				ByteCount);
+	}
+
+	return Result;
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Write data into a packet FIFO. The packet FIFO is currently 32 or 64 bits
+* wide such that an input buffer which is a series of bytes must be written
+* into the FIFO a word at a time. If the buffer is not a multiple of 32 bit
+* words, it is necessary for this function to format the remaining bytes into
+* a single 32 bit word to be inserted into the FIFO. This is necessary to
+* avoid any accesses past the end of the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent. This buffer must be 32 bit
+*        aligned or an alignment exception could be generated.
+*
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+*
+* XST_SUCCESS is returned if the operation succeeded.  If there is not enough
+* room in the FIFO to hold the specified bytes, XST_PFIFO_NO_ROOM is
+* returned.
+*
+* @note
+*
+* This function assumes that if the device inserting data into the FIFO is
+* a byte device, the order of the bytes in each 32/64 bit word is from the most
+* significant byte to the least significant byte.
+*
+******************************************************************************/
+int XPacketFifoV200a_L0Write(u32 RegBaseAddress,
+			     u32 DataBaseAddress, u8 *BufferPtr, u32 ByteCount)
+{
+	u32 Width;
+	int Result = XST_FIFO_ERROR;
+
+
+	/* determine the width of the FIFO
+	 */
+	Width = XIo_In32(RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_FIFO_WIDTH_MASK;
+
+	if ((Width == XPF_V200A_FIFO_WIDTH_LEGACY_TYPE) ||
+	    (Width == XPF_V200A_FIFO_WIDTH_32BITS_TYPE)) {
+		Result = Write32(RegBaseAddress, DataBaseAddress, BufferPtr,
+				 ByteCount);
+	}
+	else if (Width == XPF_V200A_FIFO_WIDTH_64BITS_TYPE) {
+		Result = Write64(RegBaseAddress, DataBaseAddress, BufferPtr,
+				 ByteCount);
+	}
+
+	return Result;
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Write data into a packet FIFO configured for the Data Realignment Engine
+* (DRE). A packet FIFO channel configured in this way will accept any
+* combination of byte, half-word, or word writes. The DRE will shift the data
+* into the correct byte lane.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent. There are no alignment
+*        restrictions.
+*
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+*
+* XST_SUCCESS is returned if the operation succeeded.  If there is not enough
+* room in the FIFO to hold the specified bytes, XST_PFIFO_NO_ROOM is
+* returned.
+*
+* @note
+*
+* This function assumes that if the device inserting data into the FIFO is
+* a byte device, the order of the bytes in each 32/64 bit word is from the most
+* significant byte to the least significant byte.
+*
+******************************************************************************/
+int XPacketFifoV200a_L0WriteDre(u32 RegBaseAddress,
+				u32 DataBaseAddress,
+				u8 *BufferPtr, u32 ByteCount)
+{
+	u32 FifoRoomLeft;
+	u32 BytesLeft;
+	u32 Width;
+
+	/* calculate how many slots are left in the FIFO
+	 */
+	FifoRoomLeft =
+		XIo_In32(RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET)
+		& XPF_V200A_COUNT_MASK;
+
+	/* determine the width of the FIFO
+	 */
+	Width = XIo_In32(RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_FIFO_WIDTH_MASK;
+
+	/* from the width, determine how many bytes can be written to the FIFO
+	 */
+	if ((Width == XPF_V200A_FIFO_WIDTH_LEGACY_TYPE) ||
+	    (Width == XPF_V200A_FIFO_WIDTH_32BITS_TYPE)) {
+		FifoRoomLeft *= 4;
+	}
+	else if (Width == XPF_V200A_FIFO_WIDTH_64BITS_TYPE) {
+		FifoRoomLeft *= 8;
+	}
+
+	/* Make sure there's enough room in the FIFO */
+	if (FifoRoomLeft < ByteCount) {
+		return XST_PFIFO_NO_ROOM;
+	}
+
+	/* Determine the number of bytes to write until 32 bit alignment is
+	 * reached, then write those bytes to the FIFO one byte at a time
+	 */
+	BytesLeft = (unsigned) BufferPtr % sizeof(u32);
+	ByteCount -= BytesLeft;
+	while (BytesLeft--) {
+		XIo_Out8(DataBaseAddress, *BufferPtr++);
+	}
+
+	/* Write as many 32 bit words as we can */
+	BytesLeft = ByteCount;
+	while (BytesLeft >= sizeof(u32)) {
+		XIo_Out32(DataBaseAddress, *(u32 *) BufferPtr);
+		BufferPtr += sizeof(u32);
+		BytesLeft -= sizeof(u32);
+	}
+
+	/* Write remaining bytes */
+	while (BytesLeft--) {
+		XIo_Out8(DataBaseAddress, *BufferPtr++);
+	}
+
+	return XST_SUCCESS;
+
+}
+
+/*****************************************************************************/
+/**
+*
+* Read data from a FIFO and puts it into a specified buffer. The packet FIFO
+* is 32 bits wide such that an input buffer which is a series of bytes is
+* filled from the FIFO a word at a time. If the requested byte count is not
+* a multiple of 32 bit words, it is necessary for this function to format the
+* remaining 32 bit word from the FIFO into a series of bytes in the buffer.
+* There may be up to 3 extra bytes which must be extracted from the last word
+* of the FIFO and put into the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer to write the data into. This
+*        buffer must be 32 bit aligned or an alignment exception could be
+*        generated. Since this buffer is a byte buffer, the data is assumed to
+*        be endian independent.
+*
+* @param ByteCount contains the number of bytes to read from the FIFO. This
+*        number of bytes must be present in the FIFO or an error will be
+*        returned.
+*
+* @return
+*
+* XST_SUCCESS indicates the operation was successful.  If the number of
+* bytes specified by the byte count is not present in the FIFO
+* XST_PFIFO_LACK_OF_DATA is returned.
+* <br><br>
+* If the function was successful, the specified buffer is modified to contain
+* the bytes which were removed from the FIFO.
+*
+* @note
+*
+* Note that the exact number of bytes which are present in the FIFO is
+* not known by this function.  It can only check for a number of 32 bit
+* words such that if the byte count specified is incorrect, but is still
+* possible based on the number of words in the FIFO, up to 3 garbage bytes
+* may be present at the end of the buffer.
+* <br><br>
+* This function assumes that if the device consuming data from the FIFO is
+* a byte device, the order of the bytes to be consumed is from the most
+* significant byte to the least significant byte of a 32 bit word removed
+* from the FIFO.
+*
+******************************************************************************/
+static int Read32(u32 RegBaseAddress, u32 DataBaseAddress,
+		  u8 *BufferPtr, u32 ByteCount)
+{
+	u32 FifoCount;
+	u32 WordCount;
+	u32 ExtraByteCount;
+	u32 *WordBuffer = (u32 *) BufferPtr;
+
+	/* get the count of how many 32 bit words are in the FIFO, if there
+	 * aren't enough words to satisfy the request, return an error
+	 */
+
+	FifoCount =
+		XIo_In32(RegBaseAddress +
+			 XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_COUNT_MASK;
+
+	if ((FifoCount * XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT) < ByteCount) {
+		return XST_PFIFO_LACK_OF_DATA;
+	}
+
+	/* calculate the number of words to read from the FIFO before the word
+	 * containing the extra bytes, and calculate the number of extra bytes
+	 * the extra bytes are defined as those at the end of the buffer when
+	 * the buffer does not end on a 32 bit boundary
+	 */
+	WordCount = ByteCount / XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT;
+	ExtraByteCount = ByteCount % XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT;
+
+	/* Read the 32 bit words from the FIFO for all the buffer except the
+	 * last word which contains the extra bytes, the following code assumes
+	 * that the buffer is 32 bit aligned, otherwise an alignment exception
+	 * could be generated
+	 */
+	for (FifoCount = 0; FifoCount < WordCount; FifoCount++) {
+		WordBuffer[FifoCount] = XIo_In32(DataBaseAddress);
+	}
+
+	/* if there are extra bytes to handle, read the last word from the FIFO
+	 * and insert the extra bytes into the buffer
+	 */
+	if (ExtraByteCount > 0) {
+		u32 LastWord;
+		u8 *WordPtr;
+		u8 *ExtraBytesBuffer = (u8 *) (WordBuffer + WordCount);
+
+		/* get the last word from the FIFO for the extra bytes */
+
+		LastWord = XIo_In32(DataBaseAddress);
+
+		/* one extra byte in the last word, put the byte into the next
+		 * location of the buffer, bytes in a word of the FIFO are ordered
+		 * from most significant byte to least
+		 */
+		WordPtr = (u8 *) &LastWord;
+		if (ExtraByteCount == 1) {
+			ExtraBytesBuffer[0] = WordPtr[0];
+		}
+
+		/* two extra bytes in the last word, put each byte into the next
+		 * two locations of the buffer
+		 */
+		else if (ExtraByteCount == 2) {
+			ExtraBytesBuffer[0] = WordPtr[0];
+			ExtraBytesBuffer[1] = WordPtr[1];
+		}
+		/* three extra bytes in the last word, put each byte into the next
+		 * three locations of the buffer
+		 */
+		else if (ExtraByteCount == 3) {
+			ExtraBytesBuffer[0] = WordPtr[0];
+			ExtraBytesBuffer[1] = WordPtr[1];
+			ExtraBytesBuffer[2] = WordPtr[2];
+		}
+	}
+
+	return XST_SUCCESS;
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Read data from a FIFO and puts it into a specified buffer. The packet FIFO
+* is 64 bits wide such that an input buffer which is a series of bytes is
+* filled from the FIFO a word at a time. If the requested byte count is not
+* a multiple of 64 bit words, it is necessary for this function to format the
+* remaining 64 bit word from the FIFO into a series of bytes in the buffer.
+* There may be up to 7 extra bytes which must be extracted from the last word
+* of the FIFO and put into the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer to write the data into. This
+*        buffer must be 32 bit aligned or an alignment exception could be
+*        generated. Since this buffer is a byte buffer, the data is assumed to
+*        be endian independent.
+*
+* @param ByteCount contains the number of bytes to read from the FIFO. This
+*        number of bytes must be present in the FIFO or an error will be
+*        returned.
+*
+* @return
+*
+* XST_SUCCESS indicates the operation was successful.  If the number of
+* bytes specified by the byte count is not present in the FIFO
+* XST_PFIFO_LACK_OF_DATA is returned.
+* <br><br>
+* If the function was successful, the specified buffer is modified to contain
+* the bytes which were removed from the FIFO.
+*
+* @note
+*
+* Note that the exact number of bytes which are present in the FIFO is
+* not known by this function.  It can only check for a number of 64 bit
+* words such that if the byte count specified is incorrect, but is still
+* possible based on the number of words in the FIFO, up to 7 garbage bytes
+* may be present at the end of the buffer.
+* <br><br>
+* This function assumes that if the device consuming data from the FIFO is
+* a byte device, the order of the bytes to be consumed is from the most
+* significant byte to the least significant byte of a 64 bit word removed
+* from the FIFO.
+*
+******************************************************************************/
+static int Read64(u32 RegBaseAddress, u32 DataBaseAddress,
+		  u8 *BufferPtr, u32 ByteCount)
+{
+	u32 FifoCount;
+	u32 WordCount;
+	u32 ExtraByteCount;
+	u32 *WordBuffer = (u32 *) BufferPtr;
+
+	/* get the count of how many 64 bit words are in the FIFO, if there
+	 * aren't enough words to satisfy the request, return an error
+	 */
+
+	FifoCount =
+		XIo_In32(RegBaseAddress +
+			 XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_COUNT_MASK;
+
+	if ((FifoCount * XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT) < ByteCount) {
+		return XST_PFIFO_LACK_OF_DATA;
+	}
+
+	/* calculate the number of words to read from the FIFO before the word
+	 * containing the extra bytes, and calculate the number of extra bytes
+	 * the extra bytes are defined as those at the end of the buffer when
+	 * the buffer does not end on a 32 bit boundary
+	 */
+	WordCount = ByteCount / XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT;
+	ExtraByteCount = ByteCount % XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT;
+
+	/* Read the 64 bit words from the FIFO for all the buffer except the
+	 * last word which contains the extra bytes, the following code assumes
+	 * that the buffer is 32 bit aligned, otherwise an alignment exception
+	 * could be generated. The MSWord must be read first followed by the
+	 * LSWord
+	 */
+	for (FifoCount = 0; FifoCount < WordCount; FifoCount++) {
+		WordBuffer[(FifoCount * 2)] = XIo_In32(DataBaseAddress);
+		WordBuffer[(FifoCount * 2) + 1] = XIo_In32(DataBaseAddress + 4);
+	}
+
+	/* if there are extra bytes to handle, read the last word from the FIFO
+	 * and insert the extra bytes into the buffer
+	 */
+	if (ExtraByteCount > 0) {
+		u32 MSLastWord;
+		u32 LSLastWord;
+		u8 *WordPtr;
+		u8 *ExtraBytesBuffer = (u8 *) (WordBuffer + (WordCount * 2));
+		u8 Index = 0;
+
+		/* get the last word from the FIFO for the extra bytes */
+
+		MSLastWord = XIo_In32(DataBaseAddress);
+		LSLastWord = XIo_In32(DataBaseAddress + 4);
+
+		/* four or more extra bytes in the last word, put the byte into
+		 * the next location of the buffer, bytes in a word of the FIFO
+		 * are ordered from most significant byte to least
+		 */
+		WordPtr = (u8 *) &MSLastWord;
+		if (ExtraByteCount >= 4) {
+			ExtraBytesBuffer[Index] = WordPtr[0];
+			ExtraBytesBuffer[Index + 1] = WordPtr[1];
+			ExtraBytesBuffer[Index + 2] = WordPtr[2];
+			ExtraBytesBuffer[Index + 3] = WordPtr[3];
+			ExtraByteCount = ExtraByteCount - 4;
+			MSLastWord = LSLastWord;
+			Index = 4;
+		}
+
+		/* one extra byte in the last word, put the byte into the next
+		 * location of the buffer, bytes in a word of the FIFO are
+		 * ordered from most significant byte to least
+		 */
+		if (ExtraByteCount == 1) {
+			ExtraBytesBuffer[Index] = WordPtr[0];
+		}
+
+		/* two extra bytes in the last word, put each byte into the next
+		 * two locations of the buffer
+		 */
+		else if (ExtraByteCount == 2) {
+			ExtraBytesBuffer[Index] = WordPtr[0];
+			ExtraBytesBuffer[Index + 1] = WordPtr[1];
+		}
+		/* three extra bytes in the last word, put each byte into the next
+		 * three locations of the buffer
+		 */
+		else if (ExtraByteCount == 3) {
+			ExtraBytesBuffer[Index] = WordPtr[0];
+			ExtraBytesBuffer[Index + 1] = WordPtr[1];
+			ExtraBytesBuffer[Index + 2] = WordPtr[2];
+		}
+	}
+
+	return XST_SUCCESS;
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Write data into a 32 bit packet FIFO. The packet FIFO is 32 bits wide in this
+* function call such that an input buffer which is a series of bytes must be
+* written into the FIFO a word at a time. If the buffer is not a multiple of
+* 32 bit words, it is necessary for this function to format the remaining bytes
+* into a single 32 bit word to be inserted into the FIFO. This is necessary to
+* avoid any accesses past the end of the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent. This buffer must be 32 bit
+*        aligned or an alignment exception could be generated.
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+*
+* XST_SUCCESS is returned if the operation succeeded.  If there is not enough
+* room in the FIFO to hold the specified bytes, XST_PFIFO_NO_ROOM is
+* returned.
+*
+* @note
+*
+* This function assumes that if the device inserting data into the FIFO is
+* a byte device, the order of the bytes in each 32 bit word is from the most
+* significant byte to the least significant byte.
+*
+******************************************************************************/
+static int Write32(u32 RegBaseAddress, u32 DataBaseAddress,
+		   u8 *BufferPtr, u32 ByteCount)
+{
+	u32 FifoCount;
+	u32 WordCount;
+	u32 ExtraByteCount;
+	u32 *WordBuffer = (u32 *) BufferPtr;
+
+	/* get the count of how many words may be inserted into the FIFO */
+
+	FifoCount =
+		XIo_In32(RegBaseAddress +
+			 XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_COUNT_MASK;
+
+	/* Calculate the number of 32 bit words required to insert the
+	 * specified number of bytes in the FIFO and determine the number
+	 * of extra bytes if the buffer length is not a multiple of 32 bit
+	 * words
+	 */
+
+	WordCount = ByteCount / XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT;
+	ExtraByteCount = ByteCount % XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT;
+
+	/* take into account the extra bytes in the total word count */
+
+	if (ExtraByteCount > 0) {
+		WordCount++;
+	}
+
+	/* if there's not enough room in the FIFO to hold the specified
+	 * number of bytes, then indicate an error,
+	 */
+	if (FifoCount < WordCount) {
+		return XST_PFIFO_NO_ROOM;
+	}
+
+	/* readjust the word count to not take into account the extra bytes */
+
+	if (ExtraByteCount > 0) {
+		WordCount--;
+	}
+
+	/* Write all the bytes of the buffer which can be written as 32 bit
+	 * words into the FIFO, waiting to handle the extra bytes separately
+	 */
+	for (FifoCount = 0; FifoCount < WordCount; FifoCount++) {
+		XIo_Out32(DataBaseAddress, WordBuffer[FifoCount]);
+	}
+
+	/* if there are extra bytes to handle, extract them from the buffer
+	 * and create a 32 bit word and write it to the FIFO
+	 */
+	if (ExtraByteCount > 0) {
+		u32 LastWord = 0;
+		u8 *WordPtr;
+		u8 *ExtraBytesBuffer = (u8 *) (WordBuffer + WordCount);
+
+		/* one extra byte in the buffer, put the byte into the last word
+		 * to be inserted into the FIFO, perform this processing inline
+		 * rather than in a loop to help performance
+		 */
+		WordPtr = (u8 *) &LastWord;
+		if (ExtraByteCount == 1) {
+			WordPtr[0] = ExtraBytesBuffer[0];
+		}
+
+		/* two extra bytes in the buffer, put each byte into the last word
+		 * to be inserted into the FIFO
+		 */
+		else if (ExtraByteCount == 2) {
+			WordPtr[0] = ExtraBytesBuffer[0];
+			WordPtr[1] = ExtraBytesBuffer[1];
+		}
+
+		/* three extra bytes in the buffer, put each byte into the last
+		 * word to be inserted into the FIFO
+		 */
+		else if (ExtraByteCount == 3) {
+			WordPtr[0] = ExtraBytesBuffer[0];
+			WordPtr[1] = ExtraBytesBuffer[1];
+			WordPtr[2] = ExtraBytesBuffer[2];
+		}
+
+		/* write the last 32 bit word to the FIFO and return with
+		 * no errors
+		 */
+
+		XIo_Out32(DataBaseAddress, LastWord);
+	}
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* Write data into a 64 bit packet FIFO. The packet FIFO is 64 bits wide in this
+* function call such that an input buffer which is a series of bytes must be
+* written into the FIFO a word at a time. If the buffer is not a multiple of
+* 64 bit words, it is necessary for this function to format the remaining bytes
+* into two 32 bit words to be inserted into the FIFO. This is necessary to
+* avoid any accesses past the end of the buffer.
+*
+* @param RegBaseAddress is the base address of the FIFO registers.
+*
+* @param DataBaseAddress is the base address of the FIFO keyhole.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent. This buffer must be 32 bit
+*        aligned or an alignment exception could be generated.
+*
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+*
+* XST_SUCCESS is returned if the operation succeeded.  If there is not enough
+* room in the FIFO to hold the specified bytes, XST_PFIFO_NO_ROOM is
+* returned.
+*
+* @note
+*
+* This function assumes that if the device inserting data into the FIFO is
+* a byte device, the order of the bytes in each 64 bit word is from the most
+* significant byte to the least significant byte.
+*
+******************************************************************************/
+static int Write64(u32 RegBaseAddress, u32 DataBaseAddress,
+		   u8 *BufferPtr, u32 ByteCount)
+{
+	u32 FifoCount;
+	u32 WordCount;
+	u32 ExtraByteCount;
+	u32 *WordBuffer = (u32 *) BufferPtr;
+
+	/* get the count of how many words may be inserted into the FIFO */
+
+	FifoCount =
+		XIo_In32(RegBaseAddress +
+			 XPF_V200A_COUNT_STATUS_REG_OFFSET) &
+		XPF_V200A_COUNT_MASK;
+
+	/* Calculate the number of 64 bit words required to insert the
+	 * specified number of bytes in the FIFO and determine the number
+	 * of extra bytes if the buffer length is not a multiple of 64 bit
+	 * words
+	 */
+
+	WordCount = ByteCount / XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT;
+	ExtraByteCount = ByteCount % XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT;
+
+	/* take into account the extra bytes in the total word count */
+
+	if (ExtraByteCount > 0) {
+		WordCount++;
+	}
+
+	/* if there's not enough room in the FIFO to hold the specified
+	 * number of bytes, then indicate an error,
+	 */
+	if (FifoCount < WordCount) {
+		return XST_PFIFO_NO_ROOM;
+	}
+
+	/* readjust the word count to not take into account the extra bytes */
+
+	if (ExtraByteCount > 0) {
+		WordCount--;
+	}
+
+	/* Write all the bytes of the buffer which can be written as 32 bit
+	 * words into the FIFO, waiting to handle the extra bytes separately
+	 * The MSWord must be written first followed by the LSWord
+	 */
+	for (FifoCount = 0; FifoCount < WordCount; FifoCount++) {
+		XIo_Out32(DataBaseAddress, WordBuffer[(FifoCount * 2)]);
+		XIo_Out32(DataBaseAddress + 4, WordBuffer[(FifoCount * 2) + 1]);
+	}
+
+	/* if there are extra bytes to handle, extract them from the buffer
+	 * and create two 32 bit words and write to the FIFO
+	 */
+	if (ExtraByteCount > 0) {
+
+		u32 MSLastWord = 0;
+		u32 LSLastWord = 0;
+		u8 Index = 0;
+		u8 *WordPtr;
+		u8 *ExtraBytesBuffer = (u8 *) (WordBuffer + (WordCount * 2));
+
+		/* four extra bytes in the buffer, put the bytes into the last word
+		 * to be inserted into the FIFO, perform this processing inline
+		 * rather than in a loop to help performance
+		 */
+		WordPtr = (u8 *) &MSLastWord;
+
+		if (ExtraByteCount >= 4) {
+			WordPtr[0] = ExtraBytesBuffer[Index];
+			WordPtr[1] = ExtraBytesBuffer[Index + 1];
+			WordPtr[2] = ExtraBytesBuffer[Index + 2];
+			WordPtr[3] = ExtraBytesBuffer[Index + 3];
+			ExtraByteCount = ExtraByteCount - 4;
+			WordPtr = (u8 *) &LSLastWord;
+			Index = 4;
+		}
+
+		/* one extra byte in the buffer, put the byte into the last word
+		 * to be inserted into the FIFO, perform this processing inline
+		 * rather than in a loop to help performance
+		 */
+		if (ExtraByteCount == 1) {
+			WordPtr[0] = ExtraBytesBuffer[Index];
+		}
+
+		/* two extra bytes in the buffer, put each byte into the last word
+		 * to be inserted into the FIFO
+		 */
+		else if (ExtraByteCount == 2) {
+			WordPtr[0] = ExtraBytesBuffer[Index];
+			WordPtr[1] = ExtraBytesBuffer[Index + 1];
+		}
+
+		/* three extra bytes in the buffer, put each byte into the last
+		 * word to be inserted into the FIFO
+		 */
+		else if (ExtraByteCount == 3) {
+			WordPtr[0] = ExtraBytesBuffer[Index];
+			WordPtr[1] = ExtraBytesBuffer[Index + 1];
+			WordPtr[2] = ExtraBytesBuffer[Index + 2];
+		}
+
+		/* write the last 64 bit word to the FIFO and return with no errors
+		 * The MSWord must be written first followed by the LSWord
+		 */
+		XIo_Out32(DataBaseAddress, MSLastWord);
+		XIo_Out32(DataBaseAddress + 4, LSLastWord);
+	}
+
+	return XST_SUCCESS;
+}
diff --git a/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.h b/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.h
new file mode 100644
index 0000000..62ec117
--- /dev/null
+++ b/drivers/xilinx_common/xpacket_fifo_l_v2_00_a.h
@@ -0,0 +1,145 @@
+/* $Id: xpacket_fifo_l_v2_00_a.h,v 1.1 2006/12/13 14:23:01 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2003-2004 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xpacket_fifo_l_v2_00_a.h
+*
+* This header file contains identifiers and low-level (Level 0) driver
+* functions (or macros) that can be used to access the FIFO.  High-level driver
+* (Level 1) functions are defined in xpacket_fifo_v2_00_a.h.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- ------------------------------------------------------
+* 2.00a rpm  10/22/03  First release. Moved most of Level 1 driver functions
+*                      into this layer.
+* 2.00a rmm  02/24/04  Added L0WriteDre function.
+* 2.00a xd   10/27/04  Changed comments to support doxygen for API
+*                      documentation.
+* </pre>
+*
+*****************************************************************************/
+#ifndef XPACKET_FIFO_L_V200A_H	/* prevent circular inclusions */
+#define XPACKET_FIFO_L_V200A_H	/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+/** @name FIFO types
+ *
+ * These constants specify the FIFO type and are mutually exclusive
+ * @{
+ */
+#define XPF_V200A_READ_FIFO_TYPE      0	    /**< a read FIFO */
+#define XPF_V200A_WRITE_FIFO_TYPE     1	    /**< a write FIFO */
+/* @} */
+
+/** @name Register offsets
+ *
+ * These constants define the offsets to each of the registers from the
+ * register base address, each of the constants are a number of bytes
+ * @{
+ */
+#define XPF_V200A_RESET_REG_OFFSET            0UL /**< Reset register */
+#define XPF_V200A_MODULE_INFO_REG_OFFSET      0UL /**< MIR register */
+#define XPF_V200A_COUNT_STATUS_REG_OFFSET     4UL /**< Count/Status register */
+/* @} */
+
+/**
+ * This constant is used with the Reset Register
+ */
+#define XPF_V200A_RESET_FIFO_MASK             0x0000000A
+
+/** @name Occupancy/Vacancy Count Register constants
+ * @{
+ */
+/** Constant used with the Occupancy/Vacancy Count Register. This
+ *  register also contains FIFO status
+ */
+#define XPF_V200A_COUNT_MASK                  0x00FFFFFF
+#define XPF_V200A_DEADLOCK_MASK               0x20000000
+#define XPF_V200A_ALMOST_EMPTY_FULL_MASK      0x40000000
+#define XPF_V200A_EMPTY_FULL_MASK             0x80000000
+#define XPF_V200A_VACANCY_SCALED_MASK         0x10000000
+/* @} */
+
+/**
+ * This constant is used to mask the Width field
+ */
+#define XPF_V200A_FIFO_WIDTH_MASK             0x0E000000
+
+/** @name Width field
+ * @{
+ */
+/** Constant used with the Width field */
+#define XPF_V200A_FIFO_WIDTH_LEGACY_TYPE      0x00000000
+#define XPF_V200A_FIFO_WIDTH_8BITS_TYPE       0x02000000
+#define XPF_V200A_FIFO_WIDTH_16BITS_TYPE      0x04000000
+#define XPF_V200A_FIFO_WIDTH_32BITS_TYPE      0x06000000
+#define XPF_V200A_FIFO_WIDTH_64BITS_TYPE      0x08000000
+#define XPF_V200A_FIFO_WIDTH_128BITS_TYPE     0x0A000000
+#define XPF_V200A_FIFO_WIDTH_256BITS_TYPE     0x0C000000
+#define XPF_V200A_FIFO_WIDTH_512BITS_TYPE     0x0E000000
+/* @} */
+
+/** @name FIFO word width
+ * @{
+ */
+/** Width of a FIFO word */
+#define XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT       4
+#define XPF_V200A_64BIT_FIFO_WIDTH_BYTE_COUNT       8
+/* @} */
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+int XPacketFifoV200a_L0Read(u32 RegBaseAddress,
+			    u32 DataBaseAddress,
+			    u8 *ReadBufferPtr, u32 ByteCount);
+
+int XPacketFifoV200a_L0Write(u32 RegBaseAddress,
+			     u32 DataBaseAddress,
+			     u8 *WriteBufferPtr, u32 ByteCount);
+
+int XPacketFifoV200a_L0WriteDre(u32 RegBaseAddress,
+				u32 DataBaseAddress,
+				u8 *BufferPtr, u32 ByteCount);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xpacket_fifo_v2_00_a.c b/drivers/xilinx_common/xpacket_fifo_v2_00_a.c
new file mode 100644
index 0000000..402a1d1
--- /dev/null
+++ b/drivers/xilinx_common/xpacket_fifo_v2_00_a.c
@@ -0,0 +1,329 @@
+/* $Id: xpacket_fifo_v2_00_a.c,v 1.1 2006/12/13 14:23:11 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2003 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xpacket_fifo_v2_00_a.c
+*
+* Contains functions for the XPacketFifoV200a component. See
+* xpacket_fifo_v2_00_a.h for more information about the component.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 2.00a ecm 12/30/02  First release
+* 2.00a rmm 05/14/03  Fixed diab compiler warnings
+* 2.00a rpm 10/22/03  Created and made use of Level 0 driver
+* 2.00a rmm 02/24/04  Added WriteDRE function.
+* 2.00a xd  10/27/04  Changed comments to support doxygen for API
+*                     documentation.
+* </pre>
+*
+*****************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xio.h"
+#include "xstatus.h"
+#include "xpacket_fifo_v2_00_a.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************* Variable Definitions ******************************/
+
+
+/************************** Function Prototypes ******************************/
+
+
+/*****************************************************************************/
+/**
+*
+* This function initializes a packet FIFO.  Initialization resets the
+* FIFO such that it's empty and ready to use.
+*
+* @param    InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @param    RegBaseAddress contains the base address of the registers for
+*           the packet FIFO.
+*
+* @param    DataBaseAddress contains the base address of the data for
+*           the packet FIFO.
+*
+* @return   Always returns XST_SUCCESS.
+*
+* @note     None.
+*
+******************************************************************************/
+int XPacketFifoV200a_Initialize(XPacketFifoV200a * InstancePtr,
+				u32 RegBaseAddress, u32 DataBaseAddress)
+{
+	/* assert to verify input argument are valid */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+
+	/* initialize the component variables to the specified state */
+
+	InstancePtr->RegBaseAddress = RegBaseAddress;
+	InstancePtr->DataBaseAddress = DataBaseAddress;
+	InstancePtr->IsReady = XCOMPONENT_IS_READY;
+
+	/* reset the FIFO such that it's empty and ready to use and indicate the
+	 * initialization was successful, note that the is ready variable must be
+	 * set prior to calling the reset function to prevent an assert
+	 */
+	XPF_V200A_RESET(InstancePtr);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* This function performs a self-test on the specified packet FIFO.  The self
+* test resets the FIFO and reads a register to determine if it is the correct
+* reset value.  This test is destructive in that any data in the FIFO will
+* be lost.
+*
+* @param InstancePtr is a pointer to the packet FIFO to be operated on.
+*
+* @param FifoType specifies the type of FIFO, read or write, for the self test.
+*        The FIFO type is specified by the values XPF_V200A_READ_FIFO_TYPE or
+*        XPF_V200A_WRITE_FIFO_TYPE.
+*
+* @return
+*
+* XST_SUCCESS is returned if the selftest is successful, or
+* XST_PFIFO_BAD_REG_VALUE indicating that the value read back from the
+* occupancy/vacancy count register after a reset does not match the
+* specified reset value.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XPacketFifoV200a_SelfTest(XPacketFifoV200a * InstancePtr, u32 FifoType)
+{
+	u32 Register;
+
+	/* assert to verify valid input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID((FifoType == XPF_V200A_READ_FIFO_TYPE) ||
+			(FifoType == XPF_V200A_WRITE_FIFO_TYPE));
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	/* reset the FIFO and then check to make sure the occupancy/vacancy
+	 * register contents are correct for a reset condition
+	 */
+	XPF_V200A_RESET(InstancePtr);
+
+	Register = XIo_In32(InstancePtr->RegBaseAddress +
+			    XPF_V200A_COUNT_STATUS_REG_OFFSET);
+
+	/* check the value of the register to ensure that it's correct for the
+	 * specified FIFO type since both FIFO types reset to empty, but a bit
+	 * in the register changes definition based upon FIFO type
+	 */
+
+	if (FifoType == XPF_V200A_READ_FIFO_TYPE) {
+		/* check the register value for a read FIFO which should be empty */
+
+		if ((Register & ~(XPF_V200A_FIFO_WIDTH_MASK)) !=
+		    XPF_V200A_EMPTY_FULL_MASK) {
+			return XST_PFIFO_BAD_REG_VALUE;
+		}
+	}
+	else {
+		/* check the register value for a write FIFO which should not be full
+		 * on reset
+		 */
+		if (((Register & ~(XPF_V200A_FIFO_WIDTH_MASK) &
+		      XPF_V200A_EMPTY_FULL_MASK)) != 0) {
+			return XST_PFIFO_BAD_REG_VALUE;
+		}
+	}
+
+	/* check the register value for the proper FIFO width */
+
+	Register &= ~XPF_V200A_EMPTY_FULL_MASK;
+
+	if (((Register & XPF_V200A_FIFO_WIDTH_MASK) !=
+	     XPF_V200A_FIFO_WIDTH_LEGACY_TYPE) &&
+	    ((Register & XPF_V200A_FIFO_WIDTH_MASK) !=
+	     XPF_V200A_FIFO_WIDTH_32BITS_TYPE) &&
+	    ((Register & XPF_V200A_FIFO_WIDTH_MASK) !=
+	     XPF_V200A_FIFO_WIDTH_64BITS_TYPE)) {
+		return XST_PFIFO_BAD_REG_VALUE;
+	}
+
+	/* the test was successful */
+
+	return XST_SUCCESS;
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Read data from a FIFO and puts it into a specified buffer. This function
+* invokes the Level 0 driver function to read the FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @param BufferPtr points to the memory buffer to write the data into. This
+*        buffer must be 32 bit aligned or an alignment exception could be
+*        generated. Since this buffer is a byte buffer, the data is assumed to
+*        be endian independent.
+*
+* @param ByteCount contains the number of bytes to read from the FIFO. This
+*        number of bytes must be present in the FIFO or an error will be
+*        returned.
+*
+* @return
+* - XST_SUCCESS if the operation was successful
+*   <br><br>
+* - XST_PFIFO_LACK_OF_DATA if the number of bytes specified by the byte count
+*   is not present in the FIFO.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XPacketFifoV200a_Read(XPacketFifoV200a * InstancePtr,
+			  u8 *BufferPtr, u32 ByteCount)
+{
+	/* assert to verify valid input arguments including 32 bit alignment of
+	 * the buffer pointer
+	 */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufferPtr != NULL);
+	XASSERT_NONVOID(((u32) BufferPtr &
+			 (XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT - 1)) == 0);
+	XASSERT_NONVOID(ByteCount != 0);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	return XPacketFifoV200a_L0Read(InstancePtr->RegBaseAddress,
+				       InstancePtr->DataBaseAddress,
+				       BufferPtr, ByteCount);
+}
+
+/*****************************************************************************/
+/**
+*
+* Write data into a packet FIFO. This function invokes the Level 0 driver
+* function to read the FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent. This buffer must be 32 bit
+*        aligned or an alignment exception could be generated.
+*
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+* - XST_SUCCESS is returned if the operation succeeded.
+*   <br><br>
+* - XST_PFIFO_NO_ROOM is returned if there is not enough room in the FIFO to
+*   hold the specified bytes.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XPacketFifoV200a_Write(XPacketFifoV200a * InstancePtr,
+			   u8 *BufferPtr, u32 ByteCount)
+{
+	/* assert to verify valid input arguments including 32 bit alignment of
+	 * the buffer pointer
+	 */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufferPtr != NULL);
+	XASSERT_NONVOID(((u32) BufferPtr &
+			 (XPF_V200A_32BIT_FIFO_WIDTH_BYTE_COUNT - 1)) == 0);
+	XASSERT_NONVOID(ByteCount != 0);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+
+	return XPacketFifoV200a_L0Write(InstancePtr->RegBaseAddress,
+					InstancePtr->DataBaseAddress,
+					BufferPtr, ByteCount);
+}
+
+
+/*****************************************************************************/
+/**
+*
+* Write data into a packet FIFO configured with the Data Realignment engine
+* (DRE). There are no alignment restrictions. The FIFO can be written on any
+* byte boundary. The FIFO must be at least 32 bits wide.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @param BufferPtr points to the memory buffer that data is to be read from
+*        and written into the FIFO. Since this buffer is a byte buffer, the
+*        data is assumed to be endian independent.
+*
+* @param ByteCount contains the number of bytes to read from the buffer and to
+*        write to the FIFO.
+*
+* @return
+*
+* XST_SUCCESS is returned if the operation succeeded.  If there is not enough
+* room in the FIFO to hold the specified bytes, XST_PFIFO_NO_ROOM is
+* returned.
+*
+* @note
+*
+* This function assumes that if the device inserting data into the FIFO is
+* a byte device, the order of the bytes in each 32/64 bit word is from the most
+* significant byte to the least significant byte.
+*
+******************************************************************************/
+int XPacketFifoV200a_WriteDre(XPacketFifoV200a * InstancePtr,
+			      u8 *BufferPtr, u32 ByteCount)
+{
+	/* assert to verify valid input arguments */
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(BufferPtr != NULL);
+	XASSERT_NONVOID(ByteCount != 0);
+	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
+
+	return XPacketFifoV200a_L0WriteDre(InstancePtr->RegBaseAddress,
+					   InstancePtr->DataBaseAddress,
+					   BufferPtr, ByteCount);
+}
diff --git a/drivers/xilinx_common/xpacket_fifo_v2_00_a.h b/drivers/xilinx_common/xpacket_fifo_v2_00_a.h
new file mode 100644
index 0000000..5c64666
--- /dev/null
+++ b/drivers/xilinx_common/xpacket_fifo_v2_00_a.h
@@ -0,0 +1,281 @@
+/* $Id: xpacket_fifo_v2_00_a.h,v 1.1 2006/12/13 14:23:19 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2004 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xpacket_fifo_v2_00_a.h
+*
+* This component is a common component because it's primary purpose is to
+* prevent code duplication in drivers. A driver which must handle a packet
+* FIFO uses this component rather than directly manipulating a packet FIFO.
+*
+* A FIFO is a device which has dual port memory such that one user may be
+* inserting data into the FIFO while another is consuming data from the FIFO.
+* A packet FIFO is designed for use with packet protocols such as Ethernet and
+* ATM.  It is typically only used with devices when DMA and/or Scatter Gather
+* is used.  It differs from a nonpacket FIFO in that it does not provide any
+* interrupts for thresholds of the FIFO such that it is less useful without
+* DMA.
+*
+* @note
+*
+* This component has the capability to generate an interrupt when an error
+* condition occurs.  It is the user's responsibility to provide the interrupt
+* processing to handle the interrupt. This component provides the ability to
+* determine if that interrupt is active, a deadlock condition, and the ability
+* to reset the FIFO to clear the condition. In this condition, the device which
+* is using the FIFO should also be reset to prevent other problems. This error
+* condition could occur as a normal part of operation if the size of the FIFO
+* is not setup correctly.  See the hardware IP specification for more details.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -----------------------------------------------
+* 2.00a ecm 12/30/02  First release
+* 2.00a rpm 10/22/03  Created and made use of Level 0 driver
+* 2.00a rmm 02/24/04  Added WriteDre function.
+* 2.00a xd  10/27/04  Changed comments to support doxygen for API
+*                     documentation.
+* </pre>
+*
+*****************************************************************************/
+#ifndef XPACKET_FIFO_V200A_H	/* prevent circular inclusions */
+#define XPACKET_FIFO_V200A_H	/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xpacket_fifo_l_v2_00_a.h"
+
+/************************** Constant Definitions *****************************/
+
+/* See the low-level header file for constant definitions */
+
+/**************************** Type Definitions *******************************/
+
+/**
+ * The XPacketFifo driver instance data. The driver is required to allocate a
+ * variable of this type for every packet FIFO in the device.
+ */
+typedef struct {
+	u32 RegBaseAddress; /**< Base address of registers */
+	u32 IsReady;	    /**< Device is initialized and ready */
+	u32 DataBaseAddress;/**< Base address of data for FIFOs */
+} XPacketFifoV200a;
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/*****************************************************************************/
+/**
+*
+* Reset the specified packet FIFO.  Resetting a FIFO will cause any data
+* contained in the FIFO to be lost.
+*
+* @param    InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return   None.
+*
+* @note     C Signature: void XPF_V200A_RESET(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_RESET(InstancePtr) \
+    XIo_Out32((InstancePtr)->RegBaseAddress + XPF_V200A_RESET_REG_OFFSET, XPF_V200A_RESET_FIFO_MASK);
+
+
+/*****************************************************************************/
+/**
+*
+* Get the occupancy count for a read packet FIFO and the vacancy count for a
+* write packet FIFO. These counts indicate the number of 32-bit words
+* contained (occupancy) in the FIFO or the number of 32-bit words available
+* to write (vacancy) in the FIFO.
+*
+* @param    InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return   The occupancy or vacancy count for the specified packet FIFO.
+*
+* @note
+*
+* C Signature: u32 XPF_V200A_GET_COUNT(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_GET_COUNT(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_COUNT_MASK)
+
+
+/*****************************************************************************/
+/**
+*
+* Determine if the specified packet FIFO is almost empty. Almost empty is
+* defined for a read FIFO when there is only one data word in the FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return
+*
+* TRUE if the packet FIFO is almost empty, FALSE otherwise.
+*
+* @note
+*
+* C Signature: u32 XPF_V200A_IS_ALMOST_EMPTY(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_IS_ALMOST_EMPTY(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_ALMOST_EMPTY_FULL_MASK)
+
+
+/*****************************************************************************/
+/**
+*
+* Determine if the specified packet FIFO is almost full. Almost full is
+* defined for a write FIFO when there is only one available data word in the
+* FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return
+*
+* TRUE if the packet FIFO is almost full, FALSE otherwise.
+*
+* @note
+*
+* C Signature: u32 XPF_V200A_IS_ALMOST_FULL(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_IS_ALMOST_FULL(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_ALMOST_EMPTY_FULL_MASK)
+
+
+/*****************************************************************************/
+/**
+*
+* Determine if the specified packet FIFO is empty. This applies only to a
+* read FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return
+*
+* TRUE if the packet FIFO is empty, FALSE otherwise.
+*
+* @note
+*
+* C Signature: u32 XPF_V200A_IS_EMPTY(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_IS_EMPTY(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_EMPTY_FULL_MASK)
+
+
+/*****************************************************************************/
+/**
+*
+* Determine if the specified packet FIFO is full. This applies only to a
+* write FIFO.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return
+*
+* TRUE if the packet FIFO is full, FALSE otherwise.
+*
+* @note
+*
+* C Signature: u32 XPF_V200A_IS_FULL(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_IS_FULL(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_EMPTY_FULL_MASK)
+
+
+/*****************************************************************************/
+/**
+*
+* Determine if the specified packet FIFO is deadlocked.  This condition occurs
+* when the FIFO is full and empty at the same time and is caused by a packet
+* being written to the FIFO which exceeds the total data capacity of the FIFO.
+* It occurs because of the mark/restore features of the packet FIFO which allow
+* retransmission of a packet. The software should reset the FIFO and any devices
+* using the FIFO when this condition occurs.
+*
+* @param InstancePtr contains a pointer to the FIFO to operate on.
+*
+* @return
+*
+* TRUE if the packet FIFO is deadlocked, FALSE otherwise.
+*
+* @note
+*
+* This component has the capability to generate an interrupt when an error
+* condition occurs.  It is the user's responsibility to provide the interrupt
+* processing to handle the interrupt. This function provides the ability to
+* determine if a deadlock condition, and the ability to reset the FIFO to
+* clear the condition.
+* <br><br>
+* In this condition, the device which is using the FIFO should also be reset
+* to prevent other problems. This error condition could occur as a normal part
+* of operation if the size of the FIFO is not setup correctly.
+* <br><br>
+* C Signature: u32 XPF_V200A_IS_DEADLOCKED(XPacketFifoV200a *InstancePtr)
+*
+******************************************************************************/
+#define XPF_V200A_IS_DEADLOCKED(InstancePtr) \
+    (XIo_In32((InstancePtr)->RegBaseAddress + XPF_V200A_COUNT_STATUS_REG_OFFSET) & \
+    XPF_V200A_DEADLOCK_MASK)
+
+
+/************************** Function Prototypes ******************************/
+
+/**
+ * Standard functions
+ */
+int XPacketFifoV200a_Initialize(XPacketFifoV200a * InstancePtr,
+				u32 RegBaseAddress, u32 DataBaseAddress);
+int XPacketFifoV200a_SelfTest(XPacketFifoV200a * InstancePtr, u32 FifoType);
+
+/**
+ * Data functions
+ */
+int XPacketFifoV200a_Read(XPacketFifoV200a * InstancePtr,
+			  u8 *ReadBufferPtr, u32 ByteCount);
+int XPacketFifoV200a_Write(XPacketFifoV200a * InstancePtr,
+			   u8 *WriteBufferPtr, u32 ByteCount);
+int XPacketFifoV200a_WriteDre(XPacketFifoV200a * InstancePtr,
+			      u8 *WriteBufferPtr, u32 ByteCount);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xstatus.h b/drivers/xilinx_common/xstatus.h
new file mode 100644
index 0000000..678a506
--- /dev/null
+++ b/drivers/xilinx_common/xstatus.h
@@ -0,0 +1,357 @@
+/* $Id: xstatus.h,v 1.1 2006/12/13 14:23:26 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xstatus.h
+*
+* This file contains Xilinx software status codes.  Status codes have their
+* own data type called int.  These codes are used throughout the Xilinx
+* device drivers.
+*
+******************************************************************************/
+
+#ifndef XSTATUS_H		/* prevent circular inclusions */
+#define XSTATUS_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+/************************** Constant Definitions *****************************/
+
+/*********************** Common statuses 0 - 500 *****************************/
+
+#define XST_SUCCESS                     0L
+#define XST_FAILURE                     1L
+#define XST_DEVICE_NOT_FOUND            2L
+#define XST_DEVICE_BLOCK_NOT_FOUND      3L
+#define XST_INVALID_VERSION             4L
+#define XST_DEVICE_IS_STARTED           5L
+#define XST_DEVICE_IS_STOPPED           6L
+#define XST_FIFO_ERROR                  7L	/* an error occurred during an
+						   operation with a FIFO such as
+						   an underrun or overrun, this
+						   error requires the device to
+						   be reset */
+#define XST_RESET_ERROR                 8L	/* an error occurred which requires
+						   the device to be reset */
+#define XST_DMA_ERROR                   9L	/* a DMA error occurred, this error
+						   typically requires the device
+						   using the DMA to be reset */
+#define XST_NOT_POLLED                  10L	/* the device is not configured for
+						   polled mode operation */
+#define XST_FIFO_NO_ROOM                11L	/* a FIFO did not have room to put
+						   the specified data into */
+#define XST_BUFFER_TOO_SMALL            12L	/* the buffer is not large enough
+						   to hold the expected data */
+#define XST_NO_DATA                     13L	/* there was no data available */
+#define XST_REGISTER_ERROR              14L	/* a register did not contain the
+						   expected value */
+#define XST_INVALID_PARAM               15L	/* an invalid parameter was passed
+						   into the function */
+#define XST_NOT_SGDMA                   16L	/* the device is not configured for
+						   scatter-gather DMA operation */
+#define XST_LOOPBACK_ERROR              17L	/* a loopback test failed */
+#define XST_NO_CALLBACK                 18L	/* a callback has not yet been
+						   registered */
+#define XST_NO_FEATURE                  19L	/* device is not configured with
+						   the requested feature */
+#define XST_NOT_INTERRUPT               20L	/* device is not configured for
+						   interrupt mode operation */
+#define XST_DEVICE_BUSY                 21L	/* device is busy */
+#define XST_ERROR_COUNT_MAX             22L	/* the error counters of a device
+						   have maxed out */
+#define XST_IS_STARTED                  23L	/* used when part of device is
+						   already started i.e.
+						   sub channel */
+#define XST_IS_STOPPED                  24L	/* used when part of device is
+						   already stopped i.e.
+						   sub channel */
+#define XST_DATA_LOST                   26L	/* driver defined error */
+#define XST_RECV_ERROR                  27L	/* generic receive error */
+#define XST_SEND_ERROR                  28L	/* generic transmit error */
+#define XST_NOT_ENABLED                 29L	/* a requested service is not
+						   available because it has not
+						   been enabled */
+
+/***************** Utility Component statuses 401 - 500  *********************/
+
+#define XST_MEMTEST_FAILED              401L	/* memory test failed */
+
+
+/***************** Common Components statuses 501 - 1000 *********************/
+
+/********************* Packet Fifo statuses 501 - 510 ************************/
+
+#define XST_PFIFO_LACK_OF_DATA          501L	/* not enough data in FIFO   */
+#define XST_PFIFO_NO_ROOM               502L	/* not enough room in FIFO   */
+#define XST_PFIFO_BAD_REG_VALUE         503L	/* self test, a register value
+						   was invalid after reset */
+#define XST_PFIFO_ERROR                 504L	/* generic packet FIFO error */
+#define XST_PFIFO_DEADLOCK              505L	/* packet FIFO is reporting
+						 * empty and full simultaneously
+						 */
+
+/************************** DMA statuses 511 - 530 ***************************/
+
+#define XST_DMA_TRANSFER_ERROR          511L	/* self test, DMA transfer
+						   failed */
+#define XST_DMA_RESET_REGISTER_ERROR    512L	/* self test, a register value
+						   was invalid after reset */
+#define XST_DMA_SG_LIST_EMPTY           513L	/* scatter gather list contains
+						   no buffer descriptors ready
+						   to be processed */
+#define XST_DMA_SG_IS_STARTED           514L	/* scatter gather not stopped */
+#define XST_DMA_SG_IS_STOPPED           515L	/* scatter gather not running */
+#define XST_DMA_SG_LIST_FULL            517L	/* all the buffer desciptors of
+						   the scatter gather list are
+						   being used */
+#define XST_DMA_SG_BD_LOCKED            518L	/* the scatter gather buffer
+						   descriptor which is to be
+						   copied over in the scatter
+						   list is locked */
+#define XST_DMA_SG_NOTHING_TO_COMMIT    519L	/* no buffer descriptors have been
+						   put into the scatter gather
+						   list to be commited */
+#define XST_DMA_SG_COUNT_EXCEEDED       521L	/* the packet count threshold
+						   specified was larger than the
+						   total # of buffer descriptors
+						   in the scatter gather list */
+#define XST_DMA_SG_LIST_EXISTS          522L	/* the scatter gather list has
+						   already been created */
+#define XST_DMA_SG_NO_LIST              523L	/* no scatter gather list has
+						   been created */
+#define XST_DMA_SG_BD_NOT_COMMITTED     524L	/* the buffer descriptor which was
+						   being started was not committed
+						   to the list */
+#define XST_DMA_SG_NO_DATA              525L	/* the buffer descriptor to start
+						   has already been used by the
+						   hardware so it can't be reused
+						 */
+#define XST_DMA_SG_LIST_ERROR           526L	/* general purpose list access
+						   error */
+#define XST_DMA_BD_ERROR                527L	/* general buffer descriptor
+						   error */
+
+/************************** IPIF statuses 531 - 550 ***************************/
+
+#define XST_IPIF_REG_WIDTH_ERROR        531L	/* an invalid register width
+						   was passed into the function */
+#define XST_IPIF_RESET_REGISTER_ERROR   532L	/* the value of a register at
+						   reset was not valid */
+#define XST_IPIF_DEVICE_STATUS_ERROR    533L	/* a write to the device interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_DEVICE_ACK_ERROR       534L	/* the device interrupt status
+						   register did not reset when
+						   acked */
+#define XST_IPIF_DEVICE_ENABLE_ERROR    535L	/* the device interrupt enable
+						   register was not updated when
+						   other registers changed */
+#define XST_IPIF_IP_STATUS_ERROR        536L	/* a write to the IP interrupt
+						   status register did not read
+						   back correctly */
+#define XST_IPIF_IP_ACK_ERROR           537L	/* the IP interrupt status register
+						   did not reset when acked */
+#define XST_IPIF_IP_ENABLE_ERROR        538L	/* IP interrupt enable register was
+						   not updated correctly when other
+						   registers changed */
+#define XST_IPIF_DEVICE_PENDING_ERROR   539L	/* The device interrupt pending
+						   register did not indicate the
+						   expected value */
+#define XST_IPIF_DEVICE_ID_ERROR        540L	/* The device interrupt ID register
+						   did not indicate the expected
+						   value */
+#define XST_IPIF_ERROR                  541L	/* generic ipif error */
+
+/****************** Device specific statuses 1001 - 4095 *********************/
+
+/********************* Ethernet statuses 1001 - 1050 *************************/
+
+#define XST_EMAC_MEMORY_SIZE_ERROR  1001L	/* Memory space is not big enough
+						 * to hold the minimum number of
+						 * buffers or descriptors */
+#define XST_EMAC_MEMORY_ALLOC_ERROR 1002L	/* Memory allocation failed */
+#define XST_EMAC_MII_READ_ERROR     1003L	/* MII read error */
+#define XST_EMAC_MII_BUSY           1004L	/* An MII operation is in progress */
+#define XST_EMAC_OUT_OF_BUFFERS     1005L	/* Adapter is out of buffers */
+#define XST_EMAC_PARSE_ERROR        1006L	/* Invalid adapter init string */
+#define XST_EMAC_COLLISION_ERROR    1007L	/* Excess deferral or late
+						 * collision on polled send */
+
+/*********************** UART statuses 1051 - 1075 ***************************/
+#define XST_UART
+
+#define XST_UART_INIT_ERROR         1051L
+#define XST_UART_START_ERROR        1052L
+#define XST_UART_CONFIG_ERROR       1053L
+#define XST_UART_TEST_FAIL          1054L
+#define XST_UART_BAUD_ERROR         1055L
+#define XST_UART_BAUD_RANGE         1056L
+
+
+/************************ IIC statuses 1076 - 1100 ***************************/
+
+#define XST_IIC_SELFTEST_FAILED         1076	/* self test failed            */
+#define XST_IIC_BUS_BUSY                1077	/* bus found busy              */
+#define XST_IIC_GENERAL_CALL_ADDRESS    1078	/* mastersend attempted with   */
+					     /* general call address        */
+#define XST_IIC_STAND_REG_RESET_ERROR   1079	/* A non parameterizable reg   */
+					     /* value after reset not valid */
+#define XST_IIC_TX_FIFO_REG_RESET_ERROR 1080	/* Tx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_RX_FIFO_REG_RESET_ERROR 1081	/* Rx fifo included in design  */
+					     /* value after reset not valid */
+#define XST_IIC_TBA_REG_RESET_ERROR     1082	/* 10 bit addr incl in design  */
+					     /* value after reset not valid */
+#define XST_IIC_CR_READBACK_ERROR       1083	/* Read of the control register */
+					     /* didn't return value written */
+#define XST_IIC_DTR_READBACK_ERROR      1084	/* Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_DRR_READBACK_ERROR      1085	/* Read of the data Receive reg */
+					     /* didn't return value written */
+#define XST_IIC_ADR_READBACK_ERROR      1086	/* Read of the data Tx reg     */
+					     /* didn't return value written */
+#define XST_IIC_TBA_READBACK_ERROR      1087	/* Read of the 10 bit addr reg */
+					     /* didn't return written value */
+#define XST_IIC_NOT_SLAVE               1088	/* The device isn't a slave    */
+
+/*********************** ATMC statuses 1101 - 1125 ***************************/
+
+#define XST_ATMC_ERROR_COUNT_MAX    1101L	/* the error counters in the ATM
+						   controller hit the max value
+						   which requires the statistics
+						   to be cleared */
+
+/*********************** Flash statuses 1126 - 1150 **************************/
+
+#define XST_FLASH_BUSY                1126L	/* Flash is erasing or programming */
+#define XST_FLASH_READY               1127L	/* Flash is ready for commands */
+#define XST_FLASH_ERROR               1128L	/* Flash had detected an internal
+						   error. Use XFlash_DeviceControl
+						   to retrieve device specific codes */
+#define XST_FLASH_ERASE_SUSPENDED     1129L	/* Flash is in suspended erase state */
+#define XST_FLASH_WRITE_SUSPENDED     1130L	/* Flash is in suspended write state */
+#define XST_FLASH_PART_NOT_SUPPORTED  1131L	/* Flash type not supported by
+						   driver */
+#define XST_FLASH_NOT_SUPPORTED       1132L	/* Operation not supported */
+#define XST_FLASH_TOO_MANY_REGIONS    1133L	/* Too many erase regions */
+#define XST_FLASH_TIMEOUT_ERROR       1134L	/* Programming or erase operation
+						   aborted due to a timeout */
+#define XST_FLASH_ADDRESS_ERROR       1135L	/* Accessed flash outside its
+						   addressible range */
+#define XST_FLASH_ALIGNMENT_ERROR     1136L	/* Write alignment error */
+#define XST_FLASH_BLOCKING_CALL_ERROR 1137L	/* Couldn't return immediately from
+						   write/erase function with
+						   XFL_NON_BLOCKING_WRITE/ERASE
+						   option cleared */
+#define XST_FLASH_CFI_QUERY_ERROR     1138L	/* Failed to query the device */
+
+/*********************** SPI statuses 1151 - 1175 ****************************/
+
+#define XST_SPI_MODE_FAULT          1151	/* master was selected as slave */
+#define XST_SPI_TRANSFER_DONE       1152	/* data transfer is complete */
+#define XST_SPI_TRANSMIT_UNDERRUN   1153	/* slave underruns transmit register */
+#define XST_SPI_RECEIVE_OVERRUN     1154	/* device overruns receive register */
+#define XST_SPI_NO_SLAVE            1155	/* no slave has been selected yet */
+#define XST_SPI_TOO_MANY_SLAVES     1156	/* more than one slave is being
+						 * selected */
+#define XST_SPI_NOT_MASTER          1157	/* operation is valid only as master */
+#define XST_SPI_SLAVE_ONLY          1158	/* device is configured as slave-only */
+#define XST_SPI_SLAVE_MODE_FAULT    1159	/* slave was selected while disabled */
+
+/********************** OPB Arbiter statuses 1176 - 1200 *********************/
+
+#define XST_OPBARB_INVALID_PRIORITY  1176	/* the priority registers have either
+						 * one master assigned to two or more
+						 * priorities, or one master not
+						 * assigned to any priority
+						 */
+#define XST_OPBARB_NOT_SUSPENDED     1177	/* an attempt was made to modify the
+						 * priority levels without first
+						 * suspending the use of priority
+						 * levels
+						 */
+#define XST_OPBARB_PARK_NOT_ENABLED  1178	/* bus parking by id was enabled but
+						 * bus parking was not enabled
+						 */
+#define XST_OPBARB_NOT_FIXED_PRIORITY 1179	/* the arbiter must be in fixed
+						 * priority mode to allow the
+						 * priorities to be changed
+						 */
+
+/************************ Intc statuses 1201 - 1225 **************************/
+
+#define XST_INTC_FAIL_SELFTEST      1201	/* self test failed */
+#define XST_INTC_CONNECT_ERROR      1202	/* interrupt already in use */
+
+/********************** TmrCtr statuses 1226 - 1250 **************************/
+
+#define XST_TMRCTR_TIMER_FAILED     1226	/* self test failed */
+
+/********************** WdtTb statuses 1251 - 1275 ***************************/
+
+#define XST_WDTTB_TIMER_FAILED      1251L
+
+/********************** PlbArb statuses 1276 - 1300 **************************/
+
+#define XST_PLBARB_FAIL_SELFTEST    1276L
+
+/********************** Plb2Opb statuses 1301 - 1325 *************************/
+
+#define XST_PLB2OPB_FAIL_SELFTEST   1301L
+
+/********************** Opb2Plb statuses 1326 - 1350 *************************/
+
+#define XST_OPB2PLB_FAIL_SELFTEST   1326L
+
+/********************** SysAce statuses 1351 - 1360 **************************/
+
+#define XST_SYSACE_NO_LOCK          1351L	/* No MPU lock has been granted */
+
+/********************** PCI Bridge statuses 1361 - 1375 **********************/
+
+#define XST_PCI_INVALID_ADDRESS     1361L
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
diff --git a/drivers/xilinx_common/xstreamer.c b/drivers/xilinx_common/xstreamer.c
new file mode 100644
index 0000000..97ccbeb
--- /dev/null
+++ b/drivers/xilinx_common/xstreamer.c
@@ -0,0 +1,512 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2005-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/*
+* @file xstreamer.c
+*
+* See xtreamer.h for a description on how to use this driver.
+*
+* <pre>
+* MODIFICATION HISTORY:
+*
+* Ver   Who  Date     Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a jvb  10/13/06 First release - based on Robert McGee's streaming packet
+*                     fifo driver.
+* </pre>
+******************************************************************************/
+
+/***************************** Include Files *********************************/
+
+#include "xstreamer.h"
+
+/*
+ * Implementation Notes
+ *
+ * --- Receive ---
+ *
+ * The basic algorithm for receiving bytes through this byte streamer copies a
+ * fifo key-hole width chunk from the fifo into a holding buffer and then doles
+ * out the bytes from the holding buffer. In some cases, when the buffer given
+ * happens to already be aligned in memory, this algorithm will bypass the
+ * holding buffer.
+ *
+ * Here is a picture to depict this process:
+ *
+ * Initial state:                 holding buffer
+ *                                +--------------+
+ *                                |   <empty>    |
+ *                                +--------------+
+ *                                               ^
+ *                                               |
+ *                                             index
+ *
+ * during XStrm_Read():
+ * first holding buffer fill:     holding buffer
+ *                                +--------------+
+ *                                |////<full>////|
+ *                                +--------------+
+ *                                ^
+ *                                |
+ *                              index
+ *
+ * first holding buffer read:     holding buffer
+ *                                 read   unread
+ *                                +--------------+
+ *                                |      |///////|
+ *                                +--------------+
+ *                                       ^
+ *                                       |
+ *                                     index
+ *
+ * ...
+ *
+ * last holding buffer read:     holding buffer
+ *                                +--------------+
+ *                                |   <empty>    |
+ *                                +--------------+
+ *                                               ^
+ *                                               |
+ *                                             index
+ *
+ * repeat this process ^^^
+ *
+ *
+ * --- Transmit ---
+ *
+ * The basic algorithm for transmitting bytes through this byte streamer copies
+ * bytes into a holding buffer and then writes the holding buffer into the fifo
+ * when it is full.  In some cases, when the buffer given happens to already be
+ * aligned in memory, this algorithm will bypass the holding buffer.
+ *
+ * Here is a picture to depict this process:
+ *
+ * Initial state:                 holding buffer
+ *                                +--------------+
+ *                                |   <empty>    |
+ *                                +--------------+
+ *                                ^
+ *                                |
+ *                              index
+ *
+ * during XStrm_Write():
+ * first holding buffer write:    holding buffer
+ *                                 writen  empty
+ *                                +--------------+
+ *                                |//////|       |
+ *                                +--------------+
+ *                                       ^
+ *                                       |
+ *                                     index
+ *
+ * ...
+ * last holding buffer write:     holding buffer
+ *                                +--------------+
+ *                                |////<full>////|
+ *                                +--------------+
+ *                                               ^
+ *                                               |
+ *                                             index
+ *
+ * holding buffer flush:          holding buffer
+ *                                +--------------+
+ *                                |   <empty>    |
+ *                                +--------------+
+ *                                ^
+ *                                |
+ *                              index
+ *
+ * repeat this process ^^^
+ */
+
+#ifndef min
+#define min(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+
+/*****************************************************************************/
+/*
+*
+* XStrm_RxInitialize initializes the XStrm_RxFifoStreamer object referenced by
+* <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the tx streamer on which to operate.
+*
+* @param    FifoWidth specifies the FIFO keyhole size in bytes.
+*
+* @param    FifoInstance references the FIFO driver instance that this streamer
+*           object should use to transfer data into the the actual fifo.
+*
+* @param    ReadFn specifies a routine to use to read data from the actual
+*           FIFO. It is assumed that this read routine will handle only reads
+*           from an aligned buffer. (Otherwise, why are we using this streamer
+*           driver?)
+*
+* @param    GetLenFn specifies a routine to use to initiate a receive on the
+*           actual FIFO.
+*
+* @param    GetOccupancyFn specifies a routine to use to retrieve the occupancy
+*           in the actual FIFO. The true occupancy value needs to come through
+*           this streamer driver becuase it holds some of the bytes.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XStrm_RxInitialize(XStrm_RxFifoStreamer * InstancePtr,
+			unsigned FifoWidth, void *FifoInstance,
+			XStrm_XferFnType ReadFn,
+			XStrm_GetLenFnType GetLenFn,
+			XStrm_GetOccupancyFnType GetOccupancyFn)
+{
+	/* Verify arguments */
+	XASSERT_VOID(InstancePtr != NULL);
+
+	InstancePtr->HeadIndex = FifoWidth;
+	InstancePtr->FifoWidth = FifoWidth;
+	InstancePtr->FifoInstance = FifoInstance;
+	InstancePtr->ReadFn = ReadFn;
+	InstancePtr->GetLenFn = GetLenFn;
+	InstancePtr->GetOccupancyFn = GetOccupancyFn;
+}
+
+/*****************************************************************************/
+/*
+*
+* XStrm_TxInitialize initializes the XStrm_TxFifoStreamer object referenced by
+* <i>InstancePtr</i>.
+*
+* @param    InstancePtr references the tx streamer on which to operate.
+*
+* @param    FifoWidth specifies the FIFO keyhole size in bytes.
+*
+* @param    FifoInstance references the FIFO driver instance that this streamer
+*           object should use to transfer data into the the actual fifo.
+*
+* @param    WriteFn specifies a routine to use to write data into the actual
+*           FIFO. It is assumed that this write routine will handle only writes
+*           from an aligned buffer. (Otherwise, why are we using this streamer
+*           driver?)
+*
+* @param    SetLenFn specifies a routine to use to initiate a transmit on the
+*           actual FIFO.
+*
+* @param    GetVacancyFn specifies a routine to use to retrieve the vacancy in
+*           the actual FIFO. The true vacancy value needs to come through this
+*           streamer driver becuase it holds some of the bytes.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XStrm_TxInitialize(XStrm_TxFifoStreamer * InstancePtr, unsigned FifoWidth,
+			void *FifoInstance, XStrm_XferFnType WriteFn,
+			XStrm_SetLenFnType SetLenFn,
+			XStrm_GetVacancyFnType GetVacancyFn)
+{
+	/* Verify arguments */
+	XASSERT_VOID(InstancePtr != NULL);
+
+	InstancePtr->TailIndex = 0;
+	InstancePtr->FifoWidth = FifoWidth;
+	InstancePtr->FifoInstance = FifoInstance;
+	InstancePtr->WriteFn = WriteFn;
+	InstancePtr->SetLenFn = SetLenFn;
+	InstancePtr->GetVacancyFn = GetVacancyFn;
+}
+
+/*****************************************************************************/
+/*
+*
+* XStrm_RxGetLen notifies the hardware that the program is ready to receive the
+* next frame from the receive channel of the FIFO, specified by
+* <i>InstancePtr</i>.
+*
+* Note that the program must first call XStrm_RxGetLen before pulling data
+* out of the receive channel of the FIFO with XStrm_Read.
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @return   XStrm_RxGetLen returns the number of bytes available in the next
+*           frame.
+*
+******************************************************************************/
+u32 XStrm_RxGetLen(XStrm_RxFifoStreamer * InstancePtr)
+{
+	u32 len;
+
+	InstancePtr->HeadIndex = InstancePtr->FifoWidth;
+	len = (*InstancePtr->GetLenFn) (InstancePtr->FifoInstance);
+	InstancePtr->FrmByteCnt = len;
+	return len;
+}
+
+/*****************************************************************************/
+/*
+*
+* XStrm_Read reads <i>Bytes</i> bytes from the FIFO specified by
+* <i>InstancePtr</i> to the block of memory, referenced by <i>BufPtr</i>. 
+*
+* Care must be taken to ensure that the number of bytes read with one or more
+* calls to XStrm_Read() does not exceed the number of bytes available given
+* from the last call to XStrm_RxGetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address to place the data read.
+*
+* @param    Bytes specifies the number of bytes to read.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XStrm_Read(XStrm_RxFifoStreamer * InstancePtr, void *BufPtr,
+		unsigned Bytes)
+{
+	u8 *DestPtr = (u8 *) BufPtr;
+	unsigned BytesRemaining = Bytes;
+	unsigned FifoWordsToXfer;
+	unsigned PartialBytes;
+	unsigned i;
+
+	while (BytesRemaining) {
+		xdbg_printf(XDBG_DEBUG_FIFO_RX,
+			    "XStrm_Read: BytesRemaining: %d\n", BytesRemaining);
+		/* Case 1: There are bytes in the holding buffer
+		 * 
+		 *   1) Read the bytes from the holding buffer to the target buffer.
+		 *   2) Loop back around and handle the rest of the transfer.
+		 */
+		if (InstancePtr->HeadIndex != InstancePtr->FifoWidth) {
+			xdbg_printf(XDBG_DEBUG_FIFO_RX,
+				    "XStrm_Read: Case 1: InstancePtr->HeadIndex [%d] != InstancePtr->FifoWidth [%d]\n",
+				    InstancePtr->HeadIndex,
+				    InstancePtr->FifoWidth);
+			i = InstancePtr->HeadIndex;
+
+			PartialBytes = min(BytesRemaining,
+					   InstancePtr->FifoWidth -
+					   InstancePtr->HeadIndex);
+			InstancePtr->HeadIndex += PartialBytes;
+			BytesRemaining -= PartialBytes;
+			InstancePtr->FrmByteCnt -= PartialBytes;
+			while (PartialBytes--) {
+				*DestPtr = InstancePtr->AlignedBuffer.bytes[i];
+				i++;
+				DestPtr++;
+			}
+		}
+		/* Case 2: There are no more bytes in the holding buffer and
+		 *         the target buffer is 32 bit aligned and
+		 *         the number of bytes remaining to transfer is greater
+		 *         than or equal to the fifo width.
+		 *
+		 *   1) We can go fast by reading a long string of fifo words right out
+		 *      of the fifo into the target buffer.
+		 *   2) Loop back around to transfer the last few bytes.
+		 */
+		else if ((((unsigned) DestPtr & 3) == 0) &&
+			 (BytesRemaining >= InstancePtr->FifoWidth)) {
+			xdbg_printf(XDBG_DEBUG_FIFO_RX,
+				    "XStrm_Read: Case 2: DestPtr: %p, BytesRemaining: %d, InstancePtr->FifoWidth: %d\n",
+				    DestPtr, BytesRemaining,
+				    InstancePtr->FifoWidth);
+			FifoWordsToXfer =
+				BytesRemaining / InstancePtr->FifoWidth;
+
+			(*(InstancePtr->ReadFn)) (InstancePtr->FifoInstance,
+						  DestPtr, FifoWordsToXfer);
+			DestPtr += FifoWordsToXfer * InstancePtr->FifoWidth;
+			BytesRemaining -=
+				FifoWordsToXfer * InstancePtr->FifoWidth;
+			InstancePtr->FrmByteCnt -=
+				FifoWordsToXfer * InstancePtr->FifoWidth;
+		}
+		/* Case 3: There are no more bytes in the holding buffer and
+		 *         the number of bytes remaining to transfer is less than
+		 *         the fifo width or
+		 *         things just don't line up.
+		 *
+		 *   1) Fill the holding buffer.
+		 *   2) Loop back around and handle the rest of the transfer.
+		 */
+		else {
+			xdbg_printf(XDBG_DEBUG_FIFO_RX, "XStrm_Read: Case 3\n");
+			/*
+			 * At the tail end, read one fifo word into the local holding
+			 * buffer and loop back around to take care of the transfer.
+			 */
+			(*InstancePtr->ReadFn) (InstancePtr->FifoInstance,
+						&(InstancePtr->AlignedBuffer.
+						  bytes[0]), 1);
+			InstancePtr->HeadIndex = 0;
+		}
+	}
+}
+
+/*****************************************************************************/
+/*
+*
+* XStrm_TxSetLen flushes to the FIFO, specified by <i>InstancePtr</i>, any
+* bytes remaining in internal buffers and begins a hardware transfer of data
+* out of the transmit channel of the FIFO. <i>Bytes</i> specifies the number
+* of bytes in the frame to transmit.
+*
+* @param    InstancePtr references the FIFO Streamer on which to operate.
+*
+* @param    Bytes specifies the frame length in bytes.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XStrm_TxSetLen(XStrm_TxFifoStreamer * InstancePtr, u32 Bytes)
+{
+	/*
+	 * First flush what's in the holding buffer
+	 */
+	if (InstancePtr->TailIndex != 0) {
+		(*InstancePtr->WriteFn) (InstancePtr->FifoInstance,
+					 &(InstancePtr->AlignedBuffer.bytes[0]),
+					 1);
+		InstancePtr->TailIndex = 0;
+	}
+
+	/*
+	 * Kick off the hw write
+	 */
+	(*(InstancePtr)->SetLenFn) (InstancePtr->FifoInstance, Bytes);
+}
+
+/*****************************************************************************/
+/*
+*
+* XStrm_Write writes <i>Bytes</i> bytes of the block of memory, referenced by
+* <i>BufPtr</i>, to the transmit channel of the FIFO referenced by
+* <i>InstancePtr</i>. 
+*
+* Care must be taken to ensure that the number of bytes written with one or
+* more calls to XStrm_Write() matches the number of bytes given in the next
+* call to XStrm_TxSetLen().
+*
+* @param    InstancePtr references the FIFO on which to operate.
+*
+* @param    BufPtr specifies the memory address of data to write.
+*
+* @param    Bytes specifies the number of bytes to write.
+*
+* @return   N/A
+*
+******************************************************************************/
+void XStrm_Write(XStrm_TxFifoStreamer * InstancePtr, void *BufPtr,
+		 unsigned Bytes)
+{
+	u8 *SrcPtr = (u8 *) BufPtr;
+	unsigned BytesRemaining = Bytes;
+	unsigned FifoWordsToXfer;
+	unsigned PartialBytes;
+	unsigned i;
+
+	while (BytesRemaining) {
+		xdbg_printf(XDBG_DEBUG_FIFO_TX,
+			    "XStrm_Write: BytesRemaining: %d\n",
+			    BytesRemaining);
+		/* Case 1: The holding buffer is full
+		 * 
+		 *   1) Write it to the fifo.
+		 *   2) Fall through to transfer more bytes in this iteration.
+		 */
+		if (InstancePtr->TailIndex == InstancePtr->FifoWidth) {
+			xdbg_printf(XDBG_DEBUG_FIFO_TX,
+				    "XStrm_Write: (case 1) TailIndex: %d; FifoWidth: %d; WriteFn: %p\n",
+				    InstancePtr->TailIndex,
+				    InstancePtr->FifoWidth,
+				    InstancePtr->WriteFn);
+			(*InstancePtr->WriteFn) (InstancePtr->FifoInstance,
+						 &(InstancePtr->AlignedBuffer.
+						   bytes[0]), 1);
+			InstancePtr->TailIndex = 0;
+		}
+		/* Case 2: There are no bytes in the holding buffer and
+		 *         the target buffer is 32 bit aligned and
+		 *         the number of bytes remaining to transfer is greater
+		 *         than or equal to the fifo width.
+		 *
+		 *   1) We can go fast by writing a long string of fifo words right out
+		 *      of the source buffer into the fifo.
+		 *   2) Loop back around to transfer the last few bytes.
+		 */
+		if ((InstancePtr->TailIndex == 0) &&
+		    (BytesRemaining >= InstancePtr->FifoWidth) &&
+		    (((unsigned) SrcPtr & 3) == 0)) {
+			FifoWordsToXfer =
+				BytesRemaining / InstancePtr->FifoWidth;
+
+			xdbg_printf(XDBG_DEBUG_FIFO_TX,
+				    "XStrm_Write: (case 2) TailIndex: %d; BytesRemaining: %d; FifoWidth: %d; SrcPtr: %p;\n InstancePtr: %p; WriteFn: %p (XLlFifo_iWrite_Aligned: %p),\nFifoWordsToXfer: %d (BytesRemaining: %d)\n",
+				    InstancePtr->TailIndex, BytesRemaining,
+				    InstancePtr->FifoWidth, SrcPtr, InstancePtr,
+				    InstancePtr->WriteFn,
+				    XLlFifo_iWrite_Aligned, FifoWordsToXfer,
+				    BytesRemaining);
+
+			(*InstancePtr->WriteFn) (InstancePtr->FifoInstance,
+						 SrcPtr, FifoWordsToXfer);
+			SrcPtr += FifoWordsToXfer * InstancePtr->FifoWidth;
+			BytesRemaining -=
+				FifoWordsToXfer * InstancePtr->FifoWidth;
+			xdbg_printf(XDBG_DEBUG_FIFO_TX,
+				    "XStrm_Write: (end case 2) TailIndex: %d; BytesRemaining: %d; SrcPtr: %p\n",
+				    InstancePtr->TailIndex, BytesRemaining,
+				    SrcPtr);
+		}
+		/* Case 3: The alignment of the "galaxies" didn't occur in
+		 *         Case 2 above, so we must pump the bytes through the
+		 *         holding buffer.
+		 * 
+		 *   1) Write bytes from the source buffer to the holding buffer
+		 *   2) Loop back around and handle the rest of the transfer.
+		 */
+		else {
+			i = InstancePtr->TailIndex;
+
+			PartialBytes =
+				min(BytesRemaining,
+				    InstancePtr->FifoWidth -
+				    InstancePtr->TailIndex);
+			BytesRemaining -= PartialBytes;
+			InstancePtr->TailIndex += PartialBytes;
+			while (PartialBytes--) {
+				xdbg_printf(XDBG_DEBUG_FIFO_TX,
+					    "XStrm_Write: (case 3) PartialBytes: %d\n",
+					    PartialBytes);
+				InstancePtr->AlignedBuffer.bytes[i] = *SrcPtr;
+				i++;
+				SrcPtr++;
+			}
+		}
+	}
+}
diff --git a/drivers/xilinx_common/xstreamer.h b/drivers/xilinx_common/xstreamer.h
new file mode 100644
index 0000000..21226e3
--- /dev/null
+++ b/drivers/xilinx_common/xstreamer.h
@@ -0,0 +1,325 @@
+/* $Id: */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2005-2008 Xilinx Inc.
+*       All rights reserved.
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*
+******************************************************************************/
+/*****************************************************************************/
+/*
+ *
+ * @file xstreamer.h
+ *
+ * The Xilinx byte streamer for packet FIFOs.
+ *
+ * <h2>Driver Description</h2>
+ *
+ * This driver enables higher layer software to access a hardware FIFO using
+ * any alignment in the data buffers while preserving alignment for the hardware
+ * FIFO access.
+ * 
+ * This driver treats send and receive channels separately, using different
+ * types of instance objects for each.
+ * 
+ * This driver makes use of another FIFO driver to access the specific FIFO
+ * hardware through use of the routines passed into the Tx/RxInitialize
+ * routines.
+ * 
+ * <h2>Initialization</h2>
+ *
+ * Send and receive channels are intialized separately. The receive channel is
+ * initiailzed using XStrm_RxInitialize(). The send channel is initialized
+ * using XStrm_TxInitialize().
+ *
+ * 
+ * <h2>Usage</h2>
+ * It is fairly simple to use the API provided by this byte streamer
+ * driver. The only somewhat tricky part is that the calling code must
+ * correctly call a couple routines in the right sequence for receive and
+ * transmit.
+ *
+ * 	This sequence is described here. Check the routine functional 
+ * descriptions for information on how to use a specific API routine.
+ *
+ * <h3>Receive</h3>
+ * A frame is received by using the following sequence:<br>
+ * 1) call XStrm_RxGetLen() to get the length of the next incoming frame.<br>
+ * 2) call XStrm_Read() one or more times to read the number of bytes
+ * 	   reported by XStrm_RxGetLen().<br>
+ *
+ * For example:
+ * <pre>
+ * 	frame_len = XStrm_RxGetLen(&RxInstance);
+ * 	while (frame_len) {
+ * 		unsigned bytes = min(sizeof(buffer), frame_len);
+ * 		XStrm_Read(&RxInstance, buffer, bytes);
+ * 		// do something with buffer here
+ * 		frame_len -= bytes;
+ * 	}
+ * </pre>
+ *
+ * Other restrictions on the sequence of API calls may apply depending on
+ * the specific FIFO driver used by this byte streamer driver.
+ *
+ * <h3>Transmit</h3>
+ * A frame is transmittted by using the following sequence:<br>
+ * 1) call XStrm_Write() one or more times to write all the of bytes in
+ *    the next frame.<br>
+ * 2) call XStrm_TxSetLen() to begin the transmission of frame just
+ *    written.<br>
+ *
+ * For example:
+ * <pre>
+ * 	frame_left = frame_len;
+ * 	while (frame_left) {
+ * 		unsigned bytes = min(sizeof(buffer), frame_left);
+ * 		XStrm_Write(&TxInstance, buffer, bytes);
+ * 		// do something here to refill buffer
+ * 	}
+ * 	XStrm_TxSetLen(&RxInstance, frame_len);
+ * </pre>
+ *
+ * Other restrictions on the sequence of API calls may apply depending on
+ * the specific FIFO driver used by this byte streamer driver.
+ *
+ * <pre>
+ * MODIFICATION HISTORY:
+ *
+ * Ver   Who  Date     Changes
+ * ----- ---- -------- -------------------------------------------------------
+ * 1.00a jvb  10/12/06 First release
+ * </pre>
+ *
+ *****************************************************************************/
+#ifndef XSTREAMER_H		/* prevent circular inclusions */
+#define XSTREAMER_H		/* by using preprocessor symbols */
+
+/* force C linkage */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+#include "xdebug.h"
+
+/*
+ * key hole size in 32 bit words
+ */
+#define LARGEST_FIFO_KEYHOLE_SIZE_WORDS 4
+
+/*
+ * This union is used simply to force a 32bit alignment on the
+ * buffer. Only the 'bytes' member is really used.
+ */
+union XStrm_AlignedBufferType {
+	u32 _words[LARGEST_FIFO_KEYHOLE_SIZE_WORDS];
+	char bytes[LARGEST_FIFO_KEYHOLE_SIZE_WORDS * 4];
+};
+
+typedef int(*XStrm_XferFnType) (void *FifoInstance, void *BufPtr,
+                                    unsigned WordCount);
+typedef u32 (*XStrm_GetLenFnType) (void *FifoInstance);
+typedef void (*XStrm_SetLenFnType) (void *FifoInstance,
+                                    u32 ByteCount);
+typedef u32 (*XStrm_GetOccupancyFnType) (void *FifoInstance);
+typedef u32 (*XStrm_GetVacancyFnType) (void *FifoInstance);
+
+/**
+ * This typedef defines a run-time instance of a receive byte-streamer.
+ */
+typedef struct XStrm_RxFifoStreamer {
+	union XStrm_AlignedBufferType AlignedBuffer;
+	unsigned HeadIndex;  /**< HeadIndex is the index to the AlignedBuffer
+	                      *   as bytes.
+                              */
+	unsigned FifoWidth;  /**< FifoWidth is the FIFO key hole width in bytes.
+	                      */
+	unsigned FrmByteCnt; /**< FrmByteCnt is the number of bytes in the next
+			      *   Frame.
+			      */
+	void *FifoInstance;  /**< FifoInstance is the FIFO driver instance to
+	                      *   pass to ReadFn, GetLenFn, and GetOccupancyFn
+	                      *   routines.
+	                      */
+	XStrm_XferFnType ReadFn;     /**< ReadFn is the routine the streamer
+	                              *   uses to receive bytes from the Fifo.
+	                              */
+	XStrm_GetLenFnType GetLenFn; /**< GetLenFn is the routine the streamer
+	                              *   uses to initiate receive operations
+	                              *   on the FIFO.
+                                      */
+	XStrm_GetOccupancyFnType GetOccupancyFn; /**< GetOccupancyFn is the
+	                                          *   routine the streamer uses
+	                                          *   to get the occupancy from
+	                                          *   the FIFO.
+	                                          */
+} XStrm_RxFifoStreamer;
+
+/**
+ * This typedef defines a run-time instance of a transmit byte-streamer.
+ */
+typedef struct XStrm_TxFifoStreamer {
+	union XStrm_AlignedBufferType AlignedBuffer;
+	unsigned TailIndex; /**< TailIndex is the index to the AlignedBuffer
+	                     *   as bytes
+                             */
+	unsigned FifoWidth; /**< FifoWidth is the FIFO key hole width in bytes.
+	                     */
+
+	void *FifoInstance; /**< FifoInstance is the FIFO driver instance to
+	                     *   pass to WriteFn, SetLenFn, and GetVacancyFn
+	                     *   routines.
+	                     */
+	XStrm_XferFnType WriteFn; /**< WriteFn is the routine the streamer
+	                           *   uses to transmit bytes to the Fifo.
+	                           */
+	XStrm_SetLenFnType SetLenFn; /**< SetLenFn is the routine the streamer
+	                              *   uses to initiate transmit operations
+	                              *   on the FIFO.
+                                      */
+	XStrm_GetVacancyFnType GetVacancyFn; /**< GetVaccancyFn is the routine
+	                                      *   the streamer uses to get the
+	                                      *   vacancy from the FIFO.
+	                                      */
+} XStrm_TxFifoStreamer;
+
+/*****************************************************************************/
+/*
+*
+* XStrm_TxVacancy returns the number of unused 32-bit words available (vacancy)
+* between the streamer, specified by <i>InstancePtr</i>, and the FIFO this
+* streamer is using.
+*
+* @param    InstancePtr references the streamer on which to operate.
+*
+* @return   XStrm_TxVacancy returns the vacancy count in number of 32 bit words.
+*
+* @note
+*
+* C Signature: u32 XStrm_TxVacancy(XStrm_TxFifoStreamer *InstancePtr)
+*
+* The amount of bytes in the holding buffer (rounded up to whole 32-bit words)
+* is subtracted from the vacancy value of FIFO this streamer is using. This is
+* to ensure the caller can write the number words given in the return value and
+* not overflow the FIFO.
+*
+******************************************************************************/
+#define XStrm_TxVacancy(InstancePtr) \
+	(((*(InstancePtr)->GetVacancyFn)((InstancePtr)->FifoInstance)) - \
+			(((InstancePtr)->TailIndex + 3) / 4))
+
+/*****************************************************************************/
+/*
+*
+* XStrm_RxOccupancy returns the number of 32-bit words available (occupancy) to
+* be read from the streamer, specified by <i>InstancePtr</i>, and FIFO this
+* steamer is using.
+*
+* @param    InstancePtr references the streamer on which to operate.
+*
+* @return   XStrm_RxOccupancy returns the occupancy count in number of 32 bit
+*           words.
+*
+* @note
+*
+* C Signature: u32 XStrm_RxOccupancy(XStrm_RxFifoStreamer *InstancePtr)
+*
+* The amount of bytes in the holding buffer (rounded up to whole 32-bit words)
+* is added to the occupancy value of FIFO this streamer is using. This is to
+* ensure the caller will get a little more accurate occupancy value.
+*
+******************************************************************************/
+#ifdef DEBUG
+extern u32 _xstrm_ro_value;
+extern u32 _xstrm_buffered;
+#define XStrm_RxOccupancy(InstancePtr) \
+        (_xstrm_ro_value = ((*(InstancePtr)->GetOccupancyFn)((InstancePtr)->FifoInstance)), \
+	xdbg_printf(XDBG_DEBUG_FIFO_RX, "reg: %d; frmbytecnt: %d\n", \
+		_xstrm_ro_value, (InstancePtr)->FrmByteCnt), \
+	(((InstancePtr)->FrmByteCnt) ? \
+		_xstrm_buffered = ((InstancePtr)->FifoWidth - (InstancePtr)->HeadIndex) : \
+		0), \
+	xdbg_printf(XDBG_DEBUG_FIFO_RX, "buffered_bytes: %d\n", _xstrm_buffered), \
+	xdbg_printf(XDBG_DEBUG_FIFO_RX, "buffered (rounded): %d\n", _xstrm_buffered), \
+	(_xstrm_ro_value + _xstrm_buffered))
+#else
+#define XStrm_RxOccupancy(InstancePtr) \
+	( \
+	  ((*(InstancePtr)->GetOccupancyFn)((InstancePtr)->FifoInstance)) + \
+	  ( \
+	    ((InstancePtr)->FrmByteCnt) ? \
+	      ((InstancePtr)->FifoWidth - (InstancePtr)->HeadIndex) : \
+	      0 \
+	  ) \
+	)
+#endif
+
+/****************************************************************************/
+/*
+*
+* XStrm_IsRxInternalEmpty returns true if the streamer, specified by
+* <i>InstancePtr</i>, is not holding any bytes in it's  internal buffers. Note
+* that this routine does not reflect information about the state of the
+* FIFO used by this streamer.
+*
+* @param    InstancePtr references the streamer on which to operate.
+*
+* @return   XStrm_IsRxInternalEmpty returns TRUE when the streamer is not
+*           holding any bytes in it's internal buffers. Otherwise,
+*           XStrm_IsRxInternalEmpty returns FALSE.
+*
+* @note
+* C-style signature:
+*    int XStrm_IsRxInternalEmpty(XStrm_RxFifoStreamer *InstancePtr)
+*
+*****************************************************************************/
+#define XStrm_IsRxInternalEmpty(InstancePtr) \
+	(((InstancePtr)->HeadIndex == (InstancePtr)->FifoWidth) ? TRUE : FALSE)
+
+void XStrm_RxInitialize(XStrm_RxFifoStreamer *InstancePtr,
+                        unsigned FifoWidth, void *FifoInstance,
+                        XStrm_XferFnType ReadFn,
+                        XStrm_GetLenFnType GetLenFn,
+                        XStrm_GetOccupancyFnType GetOccupancyFn);
+
+void XStrm_TxInitialize(XStrm_TxFifoStreamer *InstancePtr,
+                        unsigned FifoWidth, void *FifoInstance,
+                        XStrm_XferFnType WriteFn,
+                        XStrm_SetLenFnType SetLenFn,
+                        XStrm_GetVacancyFnType GetVacancyFn);
+
+void XStrm_TxSetLen(XStrm_TxFifoStreamer *InstancePtr, u32 Bytes);
+void XStrm_Write(XStrm_TxFifoStreamer *InstancePtr, void *BufPtr,
+                    unsigned bytes);
+
+u32 XStrm_RxGetLen(XStrm_RxFifoStreamer *InstancePtr);
+void XStrm_Read(XStrm_RxFifoStreamer *InstancePtr, void *BufPtr,
+                   unsigned bytes);
+
+#ifdef __cplusplus
+}
+#endif
+#endif				/* XSTREAMER_H  end of preprocessor protection symbols */
diff --git a/drivers/xilinx_common/xversion.c b/drivers/xilinx_common/xversion.c
new file mode 100644
index 0000000..2859bd3
--- /dev/null
+++ b/drivers/xilinx_common/xversion.c
@@ -0,0 +1,341 @@
+/* $Id: xversion.c,v 1.1 2006/12/13 14:23:34 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file xversion.c
+*
+* This file contains the implementation of the XVersion component. This
+* component represents a version ID.  It is encapsulated within a component
+* so that it's type and implementation can change without affecting users of
+* it.
+*
+* The version is formatted as X.YYZ where X = 0 - 9, Y = 00 - 99, Z = a - z
+* X is the major revision, YY is the minor revision, and Z is the
+* compatability revision.
+*
+* Packed versions are also utilized for the configuration ROM such that
+* memory is minimized. A packed version consumes only 16 bits and is
+* formatted as follows.
+*
+* <pre>
+* Revision                  Range       Bit Positions
+*
+* Major Revision            0 - 9       Bits 15 - 12
+* Minor Revision            0 - 99      Bits 11 - 5
+* Compatability Revision    a - z       Bits 4 - 0
+*
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   11/03/04 Improved support for doxygen.
+</pre>
+*
+******************************************************************************/
+
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xversion.h"
+
+/************************** Constant Definitions *****************************/
+
+/* the following constants define the masks and shift values to allow the
+ * revisions to be packed and unpacked, a packed version is packed into a 16
+ * bit value in the following format, XXXXYYYYYYYZZZZZ, where XXXX is the
+ * major revision, YYYYYYY is the minor revision, and ZZZZZ is the compatability
+ * revision
+ */
+#define XVE_MAJOR_SHIFT_VALUE       12
+#define XVE_MINOR_ONLY_MASK         0x0FE0
+#define XVE_MINOR_SHIFT_VALUE       5
+#define XVE_COMP_ONLY_MASK          0x001F
+
+/* the following constants define the specific characters of a version string
+ * for each character of the revision, a version string is in the following
+ * format, "X.YYZ" where X is the major revision (0 - 9), YY is the minor
+ * revision (00 - 99), and Z is the compatability revision (a - z)
+ */
+#define XVE_MAJOR_CHAR      0	/* major revision 0 - 9 */
+#define XVE_MINOR_TENS_CHAR 2	/* minor revision tens 0 - 9 */
+#define XVE_MINOR_ONES_CHAR 3	/* minor revision ones 0 - 9 */
+#define XVE_COMP_CHAR       4	/* compatability revision a - z */
+#define XVE_END_STRING_CHAR 5
+
+/**************************** Type Definitions *******************************/
+
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+static u32 IsVersionStringValid(s8 *StringPtr);
+
+/*****************************************************************************/
+/**
+*
+* Unpacks a packed version into the specified version. Versions are packed
+* into the configuration ROM to reduce the amount storage. A packed version
+* is a binary format as oppossed to a non-packed version which is implemented
+* as a string.
+*
+* @param    InstancePtr points to the version to unpack the packed version into.
+* @param    PackedVersion contains the packed version to unpack.
+*
+* @return   None.
+*
+* @note     None.
+*
+******************************************************************************/
+void XVersion_UnPack(XVersion * InstancePtr, u16 PackedVersion)
+{
+	/* not implemented yet since CROM related */
+}
+
+/*****************************************************************************/
+/**
+*
+* Packs a version into the specified packed version. Versions are packed into
+* the configuration ROM to reduce the amount storage.
+*
+* @param    InstancePtr points to the version to pack.
+* @param    PackedVersionPtr points to the packed version which will receive
+*           the new packed version.
+*
+* @return
+*
+* A status, XST_SUCCESS, indicating the packing was accomplished
+* successfully, or an error, XST_INVALID_VERSION, indicating the specified
+* input version was not valid such that the pack did not occur
+* <br><br>
+* The packed version pointed to by PackedVersionPtr is modified with the new
+* packed version if the status indicates success.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XVersion_Pack(XVersion * InstancePtr, u16 *PackedVersionPtr)
+{
+	/* not implemented yet since CROM related */
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* Determines if two versions are equal.
+*
+* @param    InstancePtr points to the first version to be compared.
+* @param    VersionPtr points to a second version to be compared.
+*
+* @return
+*
+* TRUE if the versions are equal, FALSE otherwise.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+u32 XVersion_IsEqual(XVersion * InstancePtr, XVersion * VersionPtr)
+{
+	u8 *Version1 = (u8 *) InstancePtr;
+	u8 *Version2 = (u8 *) VersionPtr;
+	int Index;
+
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(VersionPtr != NULL);
+
+	/* check each byte of the versions to see if they are the same,
+	 * return at any point a byte differs between them
+	 */
+	for (Index = 0; Index < sizeof(XVersion); Index++) {
+		if (Version1[Index] != Version2[Index]) {
+			return FALSE;
+		}
+	}
+
+	/* No byte was found to be different between the versions, so indicate
+	 * the versions are equal
+	 */
+	return TRUE;
+}
+
+/*****************************************************************************/
+/**
+*
+* Converts a version to a null terminated string.
+*
+* @param    InstancePtr points to the version to convert.
+* @param    StringPtr points to the string which will be the result of the
+*           conversion. This does not need to point to a null terminated
+*           string as an input, but must point to storage which is an adequate
+*           amount to hold the result string.
+*
+* @return
+*
+* The null terminated string is inserted at the location pointed to by
+* StringPtr if the status indicates success.
+*
+* @note
+*
+* It is necessary for the caller to have already allocated the storage to
+* contain the string.  The amount of memory necessary for the string is
+* specified in the version header file.
+*
+******************************************************************************/
+void XVersion_ToString(XVersion * InstancePtr, s8 *StringPtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(StringPtr != NULL);
+
+	/* since version is implemented as a string, just copy the specified
+	 * input into the specified output
+	 */
+	XVersion_Copy(InstancePtr, (XVersion *) StringPtr);
+}
+
+/*****************************************************************************/
+/**
+*
+* Initializes a version from a null terminated string. Since the string may not
+* be a format which is compatible with the version, an error could occur.
+*
+* @param    InstancePtr points to the version which is to be initialized.
+* @param    StringPtr points to a null terminated string which will be
+*           converted to a version.  The format of the string must match the
+*           version string format which is X.YYX where X = 0 - 9, YY = 00 - 99,
+*           Z = a - z.
+*
+* @return
+*
+* A status, XST_SUCCESS, indicating the conversion was accomplished
+* successfully, or XST_INVALID_VERSION indicating the version string format
+* was not valid.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+int XVersion_FromString(XVersion * InstancePtr, s8 *StringPtr)
+{
+	/* assert to verify input arguments */
+
+	XASSERT_NONVOID(InstancePtr != NULL);
+	XASSERT_NONVOID(StringPtr != NULL);
+
+	/* if the version string specified is not valid, return an error */
+
+	if (!IsVersionStringValid(StringPtr)) {
+		return XST_INVALID_VERSION;
+	}
+
+	/* copy the specified string into the specified version and indicate the
+	 * conversion was successful
+	 */
+	XVersion_Copy((XVersion *) StringPtr, InstancePtr);
+
+	return XST_SUCCESS;
+}
+
+/*****************************************************************************/
+/**
+*
+* Copies the contents of a version to another version.
+*
+* @param    InstancePtr points to the version which is the source of data for
+*           the copy operation.
+* @param    VersionPtr points to another version which is the destination of
+*           the copy operation.
+*
+* @return
+*
+* None.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+void XVersion_Copy(XVersion * InstancePtr, XVersion * VersionPtr)
+{
+	u8 *Source = (u8 *) InstancePtr;
+	u8 *Destination = (u8 *) VersionPtr;
+	int Index;
+
+	/* assert to verify input arguments */
+
+	XASSERT_VOID(InstancePtr != NULL);
+	XASSERT_VOID(VersionPtr != NULL);
+
+	/* copy each byte of the source version to the destination version */
+
+	for (Index = 0; Index < sizeof(XVersion); Index++) {
+		Destination[Index] = Source[Index];
+	}
+}
+
+/*****************************************************************************/
+/**
+*
+* Determines if the specified version is valid.
+*
+* @param    StringPtr points to the string to be validated.
+*
+* @return
+*
+* TRUE if the version string is a valid format, FALSE otherwise.
+*
+* @note
+*
+* None.
+*
+******************************************************************************/
+static u32 IsVersionStringValid(s8 *StringPtr)
+{
+	/* if the input string is not a valid format, "X.YYZ" where X = 0 - 9,
+	 * YY = 00 - 99, and Z = a - z, then indicate it's not valid
+	 */
+	if ((StringPtr[XVE_MAJOR_CHAR] < '0') ||
+	    (StringPtr[XVE_MAJOR_CHAR] > '9') ||
+	    (StringPtr[XVE_MINOR_TENS_CHAR] < '0') ||
+	    (StringPtr[XVE_MINOR_TENS_CHAR] > '9') ||
+	    (StringPtr[XVE_MINOR_ONES_CHAR] < '0') ||
+	    (StringPtr[XVE_MINOR_ONES_CHAR] > '9') ||
+	    (StringPtr[XVE_COMP_CHAR] < 'a') ||
+	    (StringPtr[XVE_COMP_CHAR] > 'z')) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
diff --git a/drivers/xilinx_common/xversion.h b/drivers/xilinx_common/xversion.h
new file mode 100644
index 0000000..eed9235
--- /dev/null
+++ b/drivers/xilinx_common/xversion.h
@@ -0,0 +1,98 @@
+/* $Id: xversion.h,v 1.1 2006/12/13 14:23:41 imanuilov Exp $ */
+/******************************************************************************
+*
+*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
+*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
+*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
+*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
+*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
+*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
+*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
+*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
+*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
+*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
+*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
+*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*       FOR A PARTICULAR PURPOSE.
+*
+*       (c) Copyright 2002 Xilinx Inc.
+*       All rights reserved.
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+* @file xversion.h
+*
+* This file contains the interface for the XVersion component. This
+* component represents a version ID.  It is encapsulated within a component
+* so that it's type and implementation can change without affecting users of
+* it.
+*
+* The version is formatted as X.YYZ where X = 0 - 9, Y = 00 - 99, Z = a - z
+* X is the major revision, YY is the minor revision, and Z is the
+* compatability revision.
+*
+* Packed versions are also utilized for the configuration ROM such that
+* memory is minimized. A packed version consumes only 16 bits and is
+* formatted as follows.
+*
+* <pre>
+* Revision                  Range       Bit Positions
+*
+* Major Revision            0 - 9       Bits 15 - 12
+* Minor Revision            0 - 99      Bits 11 - 5
+* Compatability Revision    a - z       Bits 4 - 0
+*
+* MODIFICATION HISTORY:
+*
+* Ver   Who    Date   Changes
+* ----- ---- -------- -------------------------------------------------------
+* 1.00a xd   11/03/04 Improved support for doxygen.
+* </pre>
+*
+******************************************************************************/
+
+#ifndef XVERSION_H		/* prevent circular inclusions */
+#define XVERSION_H		/* by using protection macros */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+
+#include "xbasic_types.h"
+#include "xstatus.h"
+
+/************************** Constant Definitions *****************************/
+
+
+/**************************** Type Definitions *******************************/
+
+/* the following data type is used to hold a null terminated version string
+ * consisting of the following format, "X.YYX"
+ */
+typedef s8 XVersion[6];
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+
+/************************** Function Prototypes ******************************/
+
+void XVersion_UnPack(XVersion * InstancePtr, u16 PackedVersion);
+
+int XVersion_Pack(XVersion * InstancePtr, u16 *PackedVersion);
+
+u32 XVersion_IsEqual(XVersion * InstancePtr, XVersion * VersionPtr);
+
+void XVersion_ToString(XVersion * InstancePtr, s8 *StringPtr);
+
+int XVersion_FromString(XVersion * InstancePtr, s8 *StringPtr);
+
+void XVersion_Copy(XVersion * InstancePtr, XVersion * VersionPtr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* end of protection macro */
-- 
1.7.5.4

